function: ${"ja":"実数表示", "natja":"実数表示", "en":"printDouble", "naten":"printDouble"}$(double: x) => () = jsload("console", "log");
function: ${"ja":"デバッグ表示", "natja":"デバッグ表示", "en":"debug", "naten":"debug"}$(double: x) => () = jsload("console", "debug");
function: ${"ja":"行列表示", "natja":"行列表示", "en":"printMatrix", "naten":"printMatrix"}$(double: offset[4][4]) => () = jsload("console", "logMatrix");
function: ${"ja":"アドレス表示", "natja":"アドレス表示", "en":"printAddress", "naten":"printAddress"}$(*void: x) => () = jsload("console", "log");
function: ${"ja":"_文字列表示", "natja":"_文字列表示", "en":"_printString", "naten":"_printString"}$(*char: x, int: 長さ) => () = jsload("console", "logstring");
function: ${"ja":"時間計測", "natja":"時間計測", "en":"getTime", "naten":"getTime"}$() => (double: 時間) = jsload("std", "performanceNow");
function: ${"ja":"glClearDepth", "natja":"glClearDepth", "en":"glClearDepth", "naten":"glClearDepth"}$(short: i) => () = jsload("graphics", "clearDepth");
function: ${"ja":"glDepthFunc", "natja":"glDepthFunc", "en":"glDepthFunc", "naten":"glDepthFunc"}$(short: i) => () = jsload("graphics", "depthFunc");
function: ${"ja":"glEnable", "natja":"glEnable", "en":"glEnable", "naten":"glEnable"}$(short: i) => () = jsload("graphics", "enable");
function: ${"ja":"glDisable", "natja":"glDisable", "en":"glDisable", "naten":"glDisable"}$(short: i) => () = jsload("graphics", "disable");
function: ${"ja":"glCreateProgram", "natja":"glCreateProgram", "en":"glCreateProgram", "naten":"glCreateProgram"}$() => (short: prog) = jsload("graphics", "createProgram");
function: ${"ja":"glCreateBuffer", "natja":"glCreateBuffer", "en":"glCreateBuffer", "naten":"glCreateBuffer"}$() => (short: buffer) = jsload("graphics", "createBuffer");
function: ${"ja":"glBindBuffer", "natja":"glBindBuffer", "en":"glBindBuffer", "naten":"glBindBuffer"}$(short: i, short: j) => () = jsload("graphics", "bindBuffer");
function: ${"ja":"glBufferData", "natja":"glBufferData", "en":"glBufferData", "naten":"glBufferData"}$(short: i, *double: offset, short: size, short: j) => () = jsload("graphics", "bufferData");
function: ${"ja":"glElementBufferData", "natja":"glElementBufferData", "en":"glElementBufferData", "naten":"glElementBufferData"}$(short: i, *short: offset, short: size, short: j) => () = jsload("graphics", "elementBufferData");
function: ${"ja":"glUseProgram", "natja":"glUseProgram", "en":"glUseProgram", "naten":"glUseProgram"}$(short: i) => () = jsload("graphics", "useProgram");
function: ${"ja":"glGetAttribLocation", "natja":"glGetAttribLocation", "en":"glGetAttribLocation", "naten":"glGetAttribLocation"}$(short: i, *char: offset, short: size) => (short: loc) = jsload("graphics", "getAttribLocation");
function: ${"ja":"glVertexAttribPointer", "natja":"glVertexAttribPointer", "en":"glVertexAttribPointer", "naten":"glVertexAttribPointer"}$(short: index, short: size, short: ty, short: normalized, short: stride, short: offset) => () = jsload("graphics", "vertexAttribPointer");
function: ${"ja":"glEnableVertexAttribArray", "natja":"glEnableVertexAttribArray", "en":"glEnableVertexAttribArray", "naten":"glEnableVertexAttribArray"}$(short: index) => () = jsload("graphics", "enableVertexAttribArray");
function: ${"ja":"glDrawArrays", "natja":"glDrawArrays", "en":"glDrawArrays", "naten":"glDrawArrays"}$(short: i, short: first, short: count) => () = jsload("graphics", "drawArrays");
function: ${"ja":"_glGetUniformLocation", "natja":"_glGetUniformLocation", "en":"_glGetUniformLocation", "naten":"_glGetUniformLocation"}$(short: i, *char: offset, short: size) => (short: loc) = jsload("graphics", "getUniformLocation");
function: ${"ja":"glUniformMatrix2fv", "natja":"glUniformMatrix2fv", "en":"glUniformMatrix2fv", "naten":"glUniformMatrix2fv"}$(short: loc, short: trans, *double: offset) => () = jsload("graphics", "uniformMatrix2fv");
function: ${"ja":"glUniformMatrix3fv", "natja":"glUniformMatrix3fv", "en":"glUniformMatrix3fv", "naten":"glUniformMatrix3fv"}$(short: loc, short: trans, *double: offset) => () = jsload("graphics", "uniformMatrix3fv");
function: ${"ja":"glUniformMatrix4fv", "natja":"glUniformMatrix4fv", "en":"glUniformMatrix4fv", "naten":"glUniformMatrix4fv"}$(short: loc, short: trans, double: offset[16]) => () = jsload("graphics", "uniformMatrix4fv");
function: ${"ja":"glUniform1f", "natja":"glUniform1f", "en":"glUniform1f", "naten":"glUniform1f"}$(short: loc, double: v0) => () = jsload("graphics", "uniform1f");
function: ${"ja":"glUniform1fv", "natja":"glUniform1fv", "en":"glUniform1fv", "naten":"glUniform1fv"}$(short: loc, double: v0) => () = jsload("graphics", "uniform1fv");
function: ${"ja":"glUniform1i", "natja":"glUniform1i", "en":"glUniform1i", "naten":"glUniform1i"}$(short: loc, short: v0) => () = jsload("graphics", "uniform1i");
function: ${"ja":"glUniform1iv", "natja":"glUniform1iv", "en":"glUniform1iv", "naten":"glUniform1iv"}$(short: loc, short: v0) => () = jsload("graphics", "uniform1iv");
function: ${"ja":"glUniform2f", "natja":"glUniform2f", "en":"glUniform2f", "naten":"glUniform2f"}$(short: loc, double: v0, double: v1) => () = jsload("graphics", "uniform2f");
function: ${"ja":"glUniform2fv", "natja":"glUniform2fv", "en":"glUniform2fv", "naten":"glUniform2fv"}$(short: loc, double: v0, double: v1) => () = jsload("graphics", "uniform2fv");
function: ${"ja":"glUniform2i", "natja":"glUniform2i", "en":"glUniform2i", "naten":"glUniform2i"}$(short: loc, short: v0, short: v1) => () = jsload("graphics", "uniform2i");
function: ${"ja":"glUniform2iv", "natja":"glUniform2iv", "en":"glUniform2iv", "naten":"glUniform2iv"}$(short: loc, short: v0, short: v1) => () = jsload("graphics", "uniform2iv");
function: ${"ja":"glUniform3f", "natja":"glUniform3f", "en":"glUniform3f", "naten":"glUniform3f"}$(short: loc, double: v0, double: v1, double: v2) => () = jsload("graphics", "uniform3f");
function: ${"ja":"glUniform3fv", "natja":"glUniform3fv", "en":"glUniform3fv", "naten":"glUniform3fv"}$(short: loc, double: v0, double: v1, double: v2) => () = jsload("graphics", "uniform3fv");
function: ${"ja":"glUniform3i", "natja":"glUniform3i", "en":"glUniform3i", "naten":"glUniform3i"}$(short: loc, short: v0, short: v1, short: v2) => () = jsload("graphics", "uniform3i");
function: ${"ja":"glUniform3iv", "natja":"glUniform3iv", "en":"glUniform3iv", "naten":"glUniform3iv"}$(short: loc, short: v0, short: v1, short: v2) => () = jsload("graphics", "uniform3iv");
function: ${"ja":"glUniform4f", "natja":"glUniform4f", "en":"glUniform4f", "naten":"glUniform4f"}$(short: loc, double: v0, double: v1, double: v2, double: v3) => () = jsload("graphics", "uniform4f");
function: ${"ja":"glUniform4fv", "natja":"glUniform4fv", "en":"glUniform4fv", "naten":"glUniform4fv"}$(short: loc, double: v0, double: v1, double: v2, double: v3) => () = jsload("graphics", "uniform4fv");
function: ${"ja":"glUniform4i", "natja":"glUniform4i", "en":"glUniform4i", "naten":"glUniform4i"}$(short: loc, short: v0, short: v1, short: v2, short: v3) => () = jsload("graphics", "uniform4i");
function: ${"ja":"glUniform4iv", "natja":"glUniform4iv", "en":"glUniform4iv", "naten":"glUniform4iv"}$(short: loc, short: v0, short: v1, short: v2, short: v3) => () = jsload("graphics", "uniform4iv");
function: ${"ja":"glClearColor", "natja":"glClearColor", "en":"glClearColor", "naten":"glClearColor"}$(double: r, double: g, double: b, double: a) => () = jsload("graphics", "clearColor");
function: ${"ja":"glClear", "natja":"glClear", "en":"glClear", "naten":"glClear"}$(short: color) => () = jsload("graphics", "clear");
function: ${"ja":"glDrawElements", "natja":"glDrawElements", "en":"glDrawElements", "naten":"glDrawElements"}$(short: i, short: count, short: ty, short: offset) => () = jsload("graphics", "drawElements");
function: ${"ja":"glBlendFunc", "natja":"glBlendFunc", "en":"glBlendFunc", "naten":"glBlendFunc"}$(short: i, short: j) => () = jsload("graphics", "blendFunc");
function: ${"ja":"キーチェック", "natja":"キーチェック", "en":"checkKeyPress", "naten":"checkKeyPress"}$(short: keyCode) => (int: pressed) = jsload("std", "checkKeyPress");
function: ${"ja":"マウスチェック", "natja":"マウスチェック", "en":"checkMousePress", "naten":"checkMousePress"}$() => (int: pressed) = jsload("std", "checkMousePress");
function: ${"ja":"マウス相対座標X", "natja":"マウス相対座標X", "en":"checkRelativeMouseX", "naten":"checkRelativeMouseX"}$() => (double: x) = jsload("std", "checkRelativeMouseX");
function: ${"ja":"マウス相対座標Y", "natja":"マウス相対座標Y", "en":"checkRelativeMouseY", "naten":"checkRelativeMouseY"}$() => (double: x) = jsload("std", "checkRelativeMouseY");
function: ${"ja":"マウス絶対座標X", "natja":"マウス絶対座標X", "en":"checkAbsoluteMouseX", "naten":"checkAbsoluteMouseX"}$() => (double: x) = jsload("std", "checkAbsoluteMouseX");
function: ${"ja":"マウス絶対座標Y", "natja":"マウス絶対座標Y", "en":"checkAbsoluteMouseY", "naten":"checkAbsoluteMouseY"}$() => (double: x) = jsload("std", "checkAbsoluteMouseY");
function: ${"ja":"スクロール座標", "natja":"スクロール座標", "en":"checkScroll", "naten":"checkScroll"}$() => (double: x) = jsload("std", "checkScrollY");
function: ${"ja":"ランダム数生成", "natja":"ランダム数生成", "en":"rand", "naten":"rand"}$() => (double: x) = jsload("std", "rand");
function: ${"ja":"メモリ確保", "natja":"メモリ確保", "en":"allocMemory", "naten":"allocMemory"}$(short: size) => (*void: p) = jsload("std", "alloc");
function: ${"ja":"テクスチャロード", "natja":"テクスチャロード", "en":"_loadTexture", "naten":"_loadTexture"}$(*char: offset, short: length) => (short: a) = jsload("graphics", "loadTexture");
function: ${"ja":"glActiveTexture", "natja":"glActiveTexture", "en":"glActiveTexture", "naten":"glActiveTexture"}$(short: i) => () = jsload("graphics", "activeTexture");
function: ${"ja":"glBindTexture", "natja":"glBindTexture", "en":"glBindTexture", "naten":"glBindTexture"}$(short: i, short: j) => () = jsload("graphics", "bindTexture");
function: ${"ja":"マウスキャプチャ", "natja":"マウスキャプチャ", "en":"captureMouse", "naten":"captureMouse"}$() => () = jsload("graphics", "lockPointer");
function: ${"ja":"Arduino設定", "natja":"Arduino設定", "en":"ArduinoSetup", "naten":"ArduinoSetup"}$(int: vendorId, function: () => (): c) => () = jsload("arduino", "setUp");
function: ${"ja":"Arduinoコマンド送信", "natja":"Arduinoコマンド送信", "en":"ArduinoSendCommand", "naten":"ArduinoSendCommand"}$(char: コマンド, short: data) => () = jsload("arduino", "sendCommand");
function: ${"ja":"Arduinoデータ受信", "natja":"Arduinoデータ受信", "en":"ArduinoReceiveData", "naten":"ArduinoReceiveData"}$() => () = jsload("arduino", "checkInput");
function: ${"ja":"Arduinoアナログ入力", "natja":"Arduinoアナログ入力", "en":"ArduinoAnalogInput", "naten":"ArduinoAnalogInput"}$(int: ピン番号) => (short: データ) = jsload("arduino", "analogRead");
function: ${"ja":"Arduinoデジタル入力", "natja":"Arduinoデジタル入力", "en":"ArduinoDigitalInput", "naten":"ArduinoDigitalInput"}$(int: ピン番号) => (short: データ) = jsload("arduino", "digitalRead");
function: ${"ja":"ArduinoHCSR04距離入力", "natja":"ArduinoHCSR04距離入力", "en":"ArduinoHCSR04DistanceInput", "naten":"ArduinoHCSR04DistanceInput"}$(int: ピン番号) => (short: データ) = jsload("arduino", "distanceRead");
function: getTeapot() => (*void: s) = jsload("graphics", "getTeapot");
function: getMountains() => (*void: s) = jsload("graphics", "getMountains");
function: getTeddybear() => (*void: s) = jsload("graphics", "getTeddybear");
function: getCow() => (*void: s) = jsload("graphics", "getCow");
function: getFox() => (*void: s) = jsload("graphics", "getFox");
function: getRobot() => (*void: s) = jsload("graphics", "getRobot");
function: jsArcSin(double: x) => (double: r) = jsload("std", "asin");
function: jsArcCos(double: x) => (double: r) = jsload("std", "acos");
function: jsArcTan(double: x) => (double: r) = jsload("std", "atan");
function: jsLog(double: x) => (double: r) = jsload("std", "log");
function: jsEPow(double: x) => (double: r) = jsload("std", "ePow");
function: jsPow(double: x, double: y) => (double: r) = jsload("std", "exp");
function: updateLinetraceTime(double: x) => () = jsload("linetrace", "updateLinetraceTime");
function: ${"ja":"sin", "natja":"sin", "en":"sin", "naten":"sin"}$(double: input) => (double: 結果){
	double: PI = 3.14159265358979312;
	int: temp = input / (2.0 * PI);
	double: rad = input - (2.0 * PI * temp);
	double: plusminus = 1.0;
	if(rad < 0.0){
		rad = rad + (2.0 * PI);
	}
	if(rad > PI){
		plusminus = 0 - 1.0;
		if(rad > 1.5 * PI){
			rad = (2.0 * PI) - rad;
		}else{
			rad = rad - PI;
		}
	}else{
		if(rad > 0.5 * PI){
			rad = PI - rad;
		}
	}
	if(rad > 0.25 * PI){
		rad = (0.5 * PI) - rad;
		double: doubleRad = rad * rad;
		結果 = 1.0 - (doubleRad) / 2.0 + (doubleRad * doubleRad) / 24.0 - (doubleRad * doubleRad * doubleRad) / 720.0 + (doubleRad * doubleRad * doubleRad * doubleRad) / 40320.0 - (doubleRad * doubleRad * doubleRad * doubleRad * doubleRad) / 3628800.0 + (doubleRad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad) / 479001600.0;
		結果 = 結果 * plusminus;
	}else{
		double: doubleRad = rad * rad;
		結果 = rad - (rad * doubleRad) / 6.0 + (rad * doubleRad * doubleRad) / 120.0 - (rad * doubleRad * doubleRad * doubleRad) / 5040.0 + (rad * doubleRad * doubleRad * doubleRad * doubleRad) / 362880.0 - (rad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad) / 39916800.0 + (rad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad) / 6227020800.0 - (rad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad) / 1307674368000.0;
		結果 = 結果 * plusminus;
	}
}
function: ${"ja":"cos", "natja":"cos", "en":"cos", "naten":"cos"}$(double: input) => (double: 結果){
	double: PI = 3.14159265358979312;
	int: temp = input / (2 * PI);
	double: rad = input - (2 * PI * temp);
	double: plusminus = 1.0;
	if(rad < 0.0){
		rad = rad + (2.0 * PI);
	}
	if(rad > PI){
		if(rad > 1.5 * PI){
			rad = (2.0 * PI) - rad;
		}else{
			plusminus = 0 - 1.0;
			rad = rad - PI;
		}
	}else{
		if(rad > 0.5 * PI){
			plusminus = 0 - 1.0;
			rad = PI - rad;
		}
	}
	if(rad < 0.25 * PI){
		double: doubleRad = rad * rad;
		結果 = 1.0 - (doubleRad) / 2.0 + (doubleRad * doubleRad) / 24.0 - (doubleRad * doubleRad * doubleRad) / 720.0 + (doubleRad * doubleRad * doubleRad * doubleRad) / 40320.0 - (doubleRad * doubleRad * doubleRad * doubleRad * doubleRad) / 3628800.0 + (doubleRad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad) / 479001600.0;
		結果 = 結果 * plusminus;
	}else{
		rad = (0.5 * PI) - rad;
		double: doubleRad = rad * rad;
		結果 = rad - (rad * doubleRad) / 6.0 + (rad * doubleRad * doubleRad) / 120.0 - (rad * doubleRad * doubleRad * doubleRad) / 5040.0 + (rad * doubleRad * doubleRad * doubleRad * doubleRad) / 362880.0 - (rad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad) / 39916800.0 + (rad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad) / 6227020800.0 - (rad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad) / 1307674368000.0;
		結果 = 結果 * plusminus;
	}
}
function: ${"ja":"tan", "natja":"tan", "en":"tan", "naten":"tan"}$(double: rad) => (double: 結果){
	double: PI = 3.14159265358979312;
	double: sqRad = rad * rad;
	結果 = sin(rad) / cos(rad);
}
function: ${"ja":"絶対値", "natja":"絶対値", "en":"abs", "naten":"abs"}$(double: a) => (double: b){
	if(a >= 0){
		b = a;
	}else{
		b = (0 - (a));
	}
}
function: ${"ja":"ラジアンへ", "natja":"ラジアンへ", "en":"toRad", "naten":"toRad"}$(double: deg) => (double: rad){
	double: PI = 3.14159265358979312;
	rad = (deg / 180) * PI;
}
function: ${"ja":"平方根", "natja":"平方根", "en":"root", "naten":"root"}$(double: x) => (double: y){
	y = 5;
	(int: i = 0;)from(i == 20)to(i = i + 1;){
		y = 0.5 * (y + (x / y));
	}
}
function: ${"ja":"線分当たり判定", "natja":"線分当たり判定", "en":"checkLineCross", "naten":"checkLineCross"}$(double: ax, double: ay, double: bx, double: byp, double: cx, double: cy, double: dx, double: dy) => (bool: b){
	double: ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);
	double: tb = (cx - dx) * (byp - cy) + (cy - dy) * (cx - bx);
	double: tc = (ax - bx) * (cy - ay) + (ay - byp) * (ax - cx);
	double: td = (ax - bx) * (dy - ay) + (ay - byp) * (ax - dx);
	b = ((tc * td) < 0) && ((ta * tb) < 0);
}
template<T>: class: ${"ja":"配列", "natja":"配列", "en":"Array", "naten":"Array"}${
public: 	*T: content;
	int: size;
	int: allocated;
	function: Array() => (){
		size = 0;
		allocated = 4;
		content = allocMemory(sizeof(*content) * allocated);
	}
	function: ${"ja":"取得", "natja":"取得", "en":"get", "naten":"get"}$(int: index) => (T: result){
		return(content[index]);
	}
	function: ${"ja":"追加", "natja":"追加", "en":"push", "naten":"push"}$(T: new) => (){
		if(size == allocated){
			allocated = allocated * 2;
			*T: temp = content;
			content = allocMemory(sizeof(*content) * allocated);
			(int: i = 0;)from(i == (allocated / 2))to(i = i + 1;){
				content[i] = temp[i];
			}
		}
		content[size] = new;
		size = size + 1;
	}
	function: ${"ja":"長さ", "natja":"長さ", "en":"length", "naten":"length"}$() => (int: a){
		a = size;
	}
	function: ${"ja":"ポップ", "natja":"ポップ", "en":"pop", "naten":"pop"}$() => (){
		size = size - 1;
	}
	function: operator = (*T: offset, int: l) => (){
		content = offset;
		size = l;
	}
	function: operator = (Array<T>: a) => (){
		content = allocMemory(sizeof(*content) * (a.allocated));
		size = a.size;
		allocated = a.allocated;
		repeat(size){
			content[counter] = a.content[counter];
		}
	}
	function: operator == (Array<T>: a) => (bool: b){
		b = true;
		if(size != a.size){
			return(false);
		}
		repeat(size){
			if(content[counter] != a.content[counter]){
				return(false);
			}
		}
	}
	function: operator == (*T: offset, int: l) => (bool: b){
		b = true;
		if(size != l){
			return(false);
		}
		repeat(size){
			if(content[counter] != offset[counter]){
				return(false);
			}
		}
	}
	function: operator != (Array<T>: a) => (bool: b){
		b = false;
		if(size != a.size){
			return(true);
		}
		repeat(size){
			if(content[counter] != a.content[counter]){
				return(true);
			}
		}
	}
	function: operator != (*T: offset, int: l) => (bool: b){
		b = false;
		if(size != l){
			return(true);
		}
		repeat(size){
			if(content[counter] != offset[counter]){
				return(true);
			}
		}
	}
	function: operator + (Array<T>: a) => (Array<T>: b){
		Array<T>: 結果;
		repeat(size){
			結果.push(content[counter]);
		}
		repeat(a.size){
			結果.push(a.get(counter));
		}
		return(結果);
	}
	function: operator + (*T: offset, int: l) => (Array<T>: b){
		Array<T>: 結果;
		repeat(size){
			結果.push(content[counter]);
		}
		repeat(l){
			結果.push(offset[counter]);
		}
		return(結果);
	}
	function: ${"ja":"全要素操作", "natja":"全要素操作", "en":"forEach", "naten":"forEach"}$(function: (T: a) => (): c) => (){
		repeat(size){
			c(content[counter]);
		}
	}
	function: ${"ja":"全要素変更", "natja":"全要素変更", "en":"map", "naten":"map"}$(function: (T: a) => (T: b): c) => (){
		Array<T>: 結果;
		結果.content = allocMemory(sizeof(*content) * (allocated));
		結果.size = size;
		結果.allocated = allocated;
		repeat(size){
			結果.content[counter] = c(content[counter]);
		}
		return(結果);
	}
	function: __ソート(int: s, int: e, function: (T: a, T: b) => (int: r): c) => (){
		if(s < e){
			int: loc = e;
			T: pivot = content[loc];
			int: i = s - 1;
			int: l = e - s;
			repeat(l){
				if(c(content[counter + s], pivot) < 0){
					i = i + 1;
					T: temp = content[counter + s];
					content[counter + s] = content[i];
					content[i] = temp;
				}
			}
			T: temp = content[loc];
			content[loc] = content[i + 1];
			content[i + 1] = temp;
			__ソート(s, i, c);
			__ソート(i + 2, e, c);
		}
	}
	function: ${"ja":"ソート", "natja":"ソート", "en":"sort", "naten":"sort"}$(function: (T: a, T: b) => (int: r): c) => (){
		__ソート(0, size - 1, c);
	}
	function: ${"ja":"フィルター", "natja":"フィルター", "en":"filter", "naten":"filter"}$(function: (T: a) => (bool: r): c) => (Array<T>: b){
		Array<T>: 結果;
		repeat(size){
			if(c(content[counter])){
				結果.push(content[counter]);
			}
		}
		return(結果);
	}
	function: ${"ja":"削除", "natja":"削除", "en":"remove", "naten":"remove"}$(int: i) => (Array<T>: b){
		Array<T>: 結果;
		repeat(size){
			if(counter != i){
				結果.push(content[counter]);
			}
		}
		return(結果);
	}
	function: ${"ja":"範囲削除", "natja":"範囲削除", "en":"removeRange", "naten":"removeRange"}$(int: i, int: r) => (Array<T>: b){
		Array<T>: 結果;
		repeat(size){
			if((counter < i) || (counter >= (i + r))){
				結果.push(content[counter]);
			}
		}
		return(結果);
	}
	function: ${"ja":"部分列", "natja":"部分列", "en":"subseq", "naten":"subseq"}$(int: s, int: e) => (Array<T>: b){
		Array<T>: 結果;
		if(s >= e){
			return(結果);
		}
		repeat(size){
			if((s <= counter) && (counter < e)){
				結果.push(content[counter]);
			}
		}
		return(結果);
	}
	function: ${"ja":"範囲部分列", "natja":"範囲部分列", "en":"subseqRange", "naten":"subseqRange"}$(int: s, int: l) => (Array<T>: b){
		Array<T>: 結果;
		if(s >= size){
			return(結果);
		}
		repeat(size){
			if((s <= counter) && (counter < (s + l))){
				結果.push(content[counter]);
			}
		}
		return(結果);
	}
	function: ${"ja":"置換", "natja":"置換", "en":"replace", "naten":"replace"}$(T: a, T: b) => (){
		repeat(size){
			if(content[counter] == a){
				content[counter] = b;
			}
		}
	}
	function: ${"ja":"範囲置換", "natja":"範囲置換", "en":"replaceRange", "naten":"replaceRange"}$(int: s, int: l, T: a) => (){
		repeat(size){
			if((s <= counter) && (counter < (s + l))){
				content[counter] = a;
			}
		}
	}
	function: ${"ja":"範囲置換", "natja":"範囲置換", "en":"replaceRange", "naten":"replaceRange"}$(int: s, int: l, Array<T>: a) => (){
		repeat(size){
			if((s <= counter) && (counter < (s + l))){
				content[counter] = a.content[counter - s];
			}
		}
	}
	function: ${"ja":"探索", "natja":"探索", "en":"find", "naten":"find"}$(T: b) => (int: i){
		repeat(size){
			if(content[counter] == b){
				return(counter);
			}
		}
		return(size);
	}
}
function: ${"ja":"整数文字変換", "natja":"整数文字変換", "en":"intToChar", "naten":"intToChar"}$(int: a) => (char: b){
	a = a % (10);
	if(a == 0){
		b = '0';
	}else if(a == 1){
		b = '1';
	}
	else if(a == 2){
		b = '2';
	}else if(a == 3){
		b = '3';
	}else if(a == 4){
		b = '4';
	}else if(a == 5){
		b = '5';
	}else if(a == 6){
		b = '6';
	}else if(a == 7){
		b = '7';
	}else if(a == 8){
		b = '8';
	}else if(a == 9){
		b = '9';
	}
}
class: ${"ja":"文字列", "natja":"文字列", "en":"string", "naten":"string"}${
public: 	*char: content;
	int: length;
	function: string(*char: offset, int: l) => (){
		content = offset;
		length = l;
	}
	function: string() => (){
		content = allocMemory(0);
		length = 0;
	}
	function: operator = (*char: offset, int: l) => (){
		content = offset;
		length = l;
	}
	function: operator = (string: a) => (){
		content = allocMemory(sizeof(*content) * (a.length));
		length = a.length;
		repeat(length){
			content[counter] = a.content[counter];
		}
	}
	function: operator = (char: a) => (){
		content = allocMemory(sizeof(*content));
		length = 1;
		content[0] = a;
	}
	function: operator + (char: a) => (string: b){
		b.content = allocMemory(sizeof(*content) * (length + 1));
		repeat(length){
			b.content[counter] = content[counter];
		}
		b.content[length] = a;
		b.length = length + 1;
	}
	function: operator + (*char: offset, int: l) => (string: b){
		b.content = allocMemory(sizeof(*content) * (length + l));
		repeat(length){
			b.content[counter] = content[counter];
		}
		repeat(l){
			b.content[length + counter] = offset[counter];
		}
		b.length = length + l;
	}
	function: operator + (string: a) => (string: b){
		b.content = allocMemory(sizeof(*content) * (length + a.length));
		repeat(length){
			b.content[counter] = content[counter];
		}
		repeat(a.length){
			b.content[length + counter] = a.content[counter];
		}
		b.length = length + a.length;
	}
	function: operator + (int: a) => (string: b){
		string: str = intToChar(a);
		if(abs(a) >= 10){
			(a <= 10)to{
				a = a / (10);
				string: temp = intToChar(a);
				str = temp + str;
			}
		}
		b.content = allocMemory(sizeof(*content) * length);
		repeat(length){
			b.content[counter] = content[counter];
		}
		b.length = length;
		b = b + str;
	}
	function: operator + (short: a) => (string: b){
		string: str = intToChar(a);
		(a <= 10)to{
			a = a / (10);
			string: temp = intToChar(a);
			str = temp + str;
		}
		b.content = allocMemory(sizeof(*content) * length);
		repeat(length){
			b.content[counter] = content[counter];
		}
		b.length = length;
		b = b + str;
	}
	function: operator + (double: a) => (string: b){
		int: inta = a;
		double: reala = a - inta;
		string: str = "";
		str = str + inta;
		str = str + ".";
		repeat(6){
			reala = reala * (10.0);
			str = str + intToChar(reala);
		}
		b.content = allocMemory(sizeof(*content) * length);
		repeat(length){
			b.content[counter] = content[counter];
		}
		b.length = length;
		b = b + str;
	}
	function: operator == (string: a) => (bool: b){
		b = true;
		if(length != a.length){
			return(false);
		}
		repeat(length){
			if(content[counter] != a.content[counter]){
				return(false);
			}
		}
	}
	function: operator == (*char: offset, int: l) => (bool: b){
		b = true;
		if(length != l){
			return(false);
		}
		repeat(length){
			if(content[counter] != offset[counter]){
				return(false);
			}
		}
	}
	function: operator != (string: a) => (bool: b){
		b = false;
		if(length != a.length){
			return(true);
		}
		repeat(length){
			if(content[counter] != a.content[counter]){
				return(true);
			}
		}
	}
	function: operator != (*char: offset, int: l) => (bool: b){
		b = false;
		if(length != l){
			return(true);
		}
		repeat(length){
			if(content[counter] != offset[counter]){
				return(true);
			}
		}
	}
	function: ${"ja":"切り取り", "natja":"切り取り", "en":"substr", "naten":"substr"}$(int: s, int: e) => (string: b){
		if(s > length){
			s = length;
		}
		if(e > length){
			e = length;
		}
		b.content = allocMemory(sizeof(*content) * (e - s));
		b.length = e - s;
		(int: i = s;)from(i == e)to(i = i + 1;){
			b.content[i - s] = content[i];
		}
	}
	function: ${"ja":"範囲切り取り", "natja":"範囲切り取り", "en":"substrRange", "naten":"substrRange"}$(int: s, int: l) => (string: b){
		if(s > length){
			s = length;
		}
		if(s + l > length){
			l = length - s;
		}
		b.content = allocMemory(sizeof(*content) * l);
		b.length = l;
		(int: i = s;)from(i == (s + l))to(i = i + 1;){
			b.content[i - s] = content[i];
		}
	}
	function: ${"ja":"分割", "natja":"分割", "en":"separate", "naten":"separate"}$(char: a) => (Array<string>: b){
		Array<string>: 結果;
		int: 開始 = 0;
		repeat(length){
			if(content[counter] == a){
				string: temp = substr(開始, counter);
				結果.push(temp);
				開始 = counter + 1;
			}
		}
		結果.push(substr(開始, length));
		return(結果);
	}
	function: ${"ja":"整数変換", "natja":"整数変換", "en":"toInteger", "naten":"toInteger"}$() => (int: a){
		a = 0;
		repeat(length){
			char: c = content[counter];
			if(c != '-'){
				a = a * (10);
			}
			if(c == '1'){
				a = a + 1;
			}
			if(c == '2'){
				a = a + 2;
			}
			if(c == '3'){
				a = a + 3;
			}
			if(c == '4'){
				a = a + 4;
			}
			if(c == '5'){
				a = a + 5;
			}
			if(c == '6'){
				a = a + 6;
			}
			if(c == '7'){
				a = a + 7;
			}
			if(c == '8'){
				a = a + 8;
			}
			if(c == '9'){
				a = a + 9;
			}
		}
		if(content[0] == '-'){
			a = a * ((0 - (1.0)));
		}
	}
	function: ${"ja":"実数変換", "natja":"実数変換", "en":"toDouble", "naten":"toDouble"}$() => (double: a){
		a = 0;
		if(content[0] == '-'){
			string: str = substrRange(1, length);
			a = str.toDouble() * (0 - (1.0));
		}else{
			Array<string>: b = separate('.');
			if(b.length() != 2){
				return(0.0);
			}
			a = a + b.content[0].toInteger();
			double: temp = b.content[1].toInteger();
			repeat(b.content[1].length){
				temp = temp * (0.100000000000000006);
			}
			a = a + temp;
		}
	}
	function: ${"ja":"置換", "natja":"置換", "en":"replace", "naten":"replace"}$(string: a, string: b) => (string: c){
		string: 結果;
		int: 開始 = 0;
		repeat(length){
			if(content[counter] == a.content[0]){
				if(substrRange(counter, a.length) == a){
					結果 = 結果 + substr(開始, counter);
					結果 = 結果 + b;
					counter = counter + a.length;
					開始 = counter;
				}
			}
		}
		結果 = 結果 + substr(開始, length);
		return(結果);
	}
}
function: ${"ja":"文字列表示", "natja":"文字列表示", "en":"printString", "naten":"printString"}$(string: a) => (){
	_printString(a.content, a.length);
}
function: ${"ja":"表示", "natja":"表示", "en":"print", "naten":"print"}$(double: x) => (){
	printDouble(x);
}
function: ${"ja":"表示", "natja":"表示", "en":"print", "naten":"print"}$(int: n) => (){
	printDouble(n);
}
function: ${"ja":"表示", "natja":"表示", "en":"print", "naten":"print"}$(short: n) => (){
	printDouble(n);
}
function: ${"ja":"表示", "natja":"表示", "en":"print", "naten":"print"}$(string: a) => (){
	printString(a);
}
function: ${"ja":"glGetUniformLocation", "natja":"glGetUniformLocation", "en":"glGetUniformLocation", "naten":"glGetUniformLocation"}$(short: i, string: a) => (short: loc){
	loc = _glGetUniformLocation(i, a.content, a.length);
}
function: ${"ja":"サンプルモデルロード", "natja":"サンプルモデルロード", "en":"loadSampleModel", "naten":"loadSampleModel"}$(string: a) => (string: b){
	*string: data = "";
	if(a == "teapot"){
		data = getTeapot();
	}
	if(a == "mountains"){
		data = getMountains();
	}
	if(a == "teddybear"){
		data = getTeddybear();
	}
	if(a == "cow"){
		data = getCow();
	}
	if(a == "fox"){
		data = getFox();
	}
	if(a == "robot"){
		data = getRobot();
	}
	b = *data;
}
class: ${"ja":"ベクトル3D", "natja":"ベクトル3D", "en":"Vector3D", "naten":"Vector3D"}${
public: 	double: x;
	double: y;
	double: z;
	function: Vector3D(double: a, double: b, double: c) => (){
		x = a;
		y = b;
		z = c;
	}
	function: ${"ja":"長さ", "natja":"長さ", "en":"length", "naten":"length"}$() => (double: l){
		l = root(x * x + y * y + z * z);
	}
	function: ${"ja":"正規化", "natja":"正規化", "en":"normalize", "naten":"normalize"}$() => (){
		double: l = root((x * x) + (y * y) + (z * z));
		x = x / l;
		y = y / l;
		z = z / l;
	}
	function: operator + (Vector3D: a) => (Vector3D: b){
		b.x = a.x + x;
		b.y = a.y + y;
		b.z = a.z + z;
	}
	function: operator - (Vector3D: a) => (Vector3D: b){
		b.x = x - a.x;
		b.y = y - a.y;
		b.z = z - a.z;
	}
	function: operator * (double: k) => (Vector3D: b){
		b.x = x * k;
		b.y = y * k;
		b.z = z * k;
	}
	function: operator * (Vector3D: a) => (Vector3D: b){
		b.x = y * a.z - z * a.y;
		b.y = z * a.x - x * a.z;
		b.z = x * a.y - y * a.x;
	}
	function: operator / (double: k) => (Vector3D: b){
		b.x = x / k;
		b.y = y / k;
		b.z = z / k;
	}
	function: operator == (Vector3D: a) => (bool: b){
		b = ((a.x == x) && (a.y == y) && (a.z == z));
	}
	function: operator != (Vector3D: a) => (bool: b){
		b = ((a.x != x) || (a.y != y) || (a.z != z));
	}
}
function: ${"ja":"ベクトル3Dの和", "natja":"ベクトル3Dの和", "en":"addVector3D", "naten":"addVector3D"}$(Vector3D: a, Vector3D: b) => (Vector3D: result){
	result.x = a.x + b.x;
	result.y = a.y + b.y;
	result.z = a.z + b.z;
}
function: ${"ja":"ベクトル3Dの差", "natja":"ベクトル3Dの差", "en":"subVector3D", "naten":"subVector3D"}$(Vector3D: a, Vector3D: b) => (Vector3D: result){
	result.x = a.x - b.x;
	result.y = a.y - b.y;
	result.z = a.z - b.z;
}
function: ${"ja":"ベクトル3Dの内積", "natja":"ベクトル3Dの内積", "en":"dotVector3D", "naten":"dotVector3D"}$(Vector3D: a, Vector3D: b) => (double: x){
	x = (a.x * b.x) + (a.y * b.y) + (a.z * b.z);
}
function: ${"ja":"ベクトル3Dの外積", "natja":"ベクトル3Dの外積", "en":"crossVector3D", "naten":"crossVector3D"}$(Vector3D: a, Vector3D: b) => (Vector3D: result){
	result.x = (a.y * b.z) - (a.z * b.y);
	result.y = (a.z * b.x) - (a.x * b.z);
	result.z = (a.x * b.y) - (a.y * b.x);
}
function: ${"ja":"ベクトル3D拡大", "natja":"ベクトル3D拡大", "en":"extendVector3D", "naten":"extendVector3D"}$(Vector3D: a, double: x) => (Vector3D: result){
	result.x = a.x * x;
	result.y = a.y * x;
	result.z = a.z * x;
}
function: ${"ja":"ベクトル3D縮小", "natja":"ベクトル3D縮小", "en":"divVector3D", "naten":"divVector3D"}$(Vector3D: a, double: x) => (Vector3D: result){
	if(x == 0.0){
		print(10000000);
	}
	result.x = a.x / x;
	result.y = a.y / x;
	result.z = a.z / x;
}
class: ${"ja":"行列4x4", "natja":"行列4x4", "en":"Matrix4x4", "naten":"Matrix4x4"}${
public: 	double: matrix[16];
	function: Matrix4x4() => (){
		matrix = [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0];
	}
	function: ${"ja":"単位化", "natja":"単位化", "en":"identity", "naten":"identity"}$() => (){
		matrix = [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0];
	}
	function: ${"ja":"移動", "natja":"移動", "en":"translate", "naten":"translate"}$(Vector3D: offset) => (){
		double: mat12 = matrix[12];
		double: mat13 = matrix[13];
		double: mat14 = matrix[14];
		double: mat15 = matrix[15];
		matrix[12] = matrix[0] * offset.x + matrix[4] * offset.y + matrix[8] * offset.z + mat12;
		matrix[13] = matrix[1] * offset.x + matrix[5] * offset.y + matrix[9] * offset.z + mat13;
		matrix[14] = matrix[2] * offset.x + matrix[6] * offset.y + matrix[10] * offset.z + mat13;
		matrix[15] = matrix[3] * offset.x + matrix[7] * offset.y + matrix[11] * offset.z + mat15;
	}
	function: ${"ja":"回転", "natja":"回転", "en":"rotate", "naten":"rotate"}$(Vector3D: axis, double: theta) => (){
		axis.normalize();
		double: s = sin(theta);
		double: c = cos(theta);
		double: t = 1.0 - c;
		double: a00 = matrix[0];
		double: a01 = matrix[1];
		double: a02 = matrix[2];
		double: a03 = matrix[3];
		double: a10 = matrix[4];
		double: a11 = matrix[5];
		double: a12 = matrix[6];
		double: a13 = matrix[7];
		double: a20 = matrix[8];
		double: a21 = matrix[9];
		double: a22 = matrix[10];
		double: a23 = matrix[11];
		double: b00 = axis.x * axis.x * t + c;
		double: b01 = axis.y * axis.x * t + axis.z * s;
		double: b02 = axis.z * axis.x * t - axis.y * s;
		double: b10 = axis.x * axis.y * t - axis.z * s;
		double: b11 = axis.y * axis.y * t + c;
		double: b12 = axis.z * axis.y * t + axis.x * s;
		double: b20 = axis.x * axis.z * t + axis.y * s;
		double: b21 = axis.y * axis.z * t - axis.x * s;
		double: b22 = axis.z * axis.z * t + c;
		matrix[0] = a00 * b00 + a10 * b01 + a20 * b02;
		matrix[1] = a01 * b00 + a11 * b01 + a21 * b02;
		matrix[2] = a02 * b00 + a12 * b01 + a22 * b02;
		matrix[3] = a03 * b00 + a13 * b01 + a23 * b02;
		matrix[4] = a00 * b10 + a10 * b11 + a20 * b12;
		matrix[5] = a01 * b10 + a11 * b11 + a21 * b12;
		matrix[6] = a02 * b10 + a12 * b11 + a22 * b12;
		matrix[7] = a03 * b10 + a13 * b11 + a23 * b12;
		matrix[8] = a00 * b20 + a10 * b21 + a20 * b22;
		matrix[9] = a01 * b20 + a11 * b21 + a21 * b22;
		matrix[10] = a02 * b20 + a12 * b21 + a22 * b22;
		matrix[11] = a03 * b20 + a13 * b21 + a23 * b22;
	}
	function: ${"ja":"拡大縮小", "natja":"拡大縮小", "en":"scale", "naten":"scale"}$(double: x, double: y, double: z) => (){
		matrix[0] = matrix[0] * x;
		matrix[1] = matrix[1] * x;
		matrix[2] = matrix[2] * x;
		matrix[3] = matrix[3] * x;
		matrix[4] = matrix[4] * y;
		matrix[5] = matrix[5] * y;
		matrix[6] = matrix[6] * y;
		matrix[7] = matrix[7] * y;
		matrix[8] = matrix[8] * z;
		matrix[9] = matrix[9] * z;
		matrix[10] = matrix[10] * z;
		matrix[11] = matrix[11] * z;
	}
	function: operator * (Matrix4x4: a) => (Matrix4x4: b){
		b.matrix[0] = a.matrix[0] * matrix[0] + a.matrix[1] * matrix[4] + a.matrix[2] * matrix[8] + a.matrix[3] * matrix[12];
		b.matrix[1] = a.matrix[0] * matrix[1] + a.matrix[1] * matrix[5] + a.matrix[2] * matrix[9] + a.matrix[3] * matrix[13];
		b.matrix[2] = a.matrix[0] * matrix[2] + a.matrix[1] * matrix[6] + a.matrix[2] * matrix[10] + a.matrix[3] * matrix[14];
		b.matrix[3] = a.matrix[0] * matrix[3] + a.matrix[1] * matrix[7] + a.matrix[2] * matrix[11] + a.matrix[3] * matrix[15];
		b.matrix[4] = a.matrix[4] * matrix[0] + a.matrix[5] * matrix[4] + a.matrix[6] * matrix[8] + a.matrix[7] * matrix[12];
		b.matrix[5] = a.matrix[4] * matrix[1] + a.matrix[5] * matrix[5] + a.matrix[6] * matrix[9] + a.matrix[7] * matrix[13];
		b.matrix[6] = a.matrix[4] * matrix[2] + a.matrix[5] * matrix[6] + a.matrix[6] * matrix[10] + a.matrix[7] * matrix[14];
		b.matrix[7] = a.matrix[4] * matrix[3] + a.matrix[5] * matrix[7] + a.matrix[6] * matrix[11] + a.matrix[7] * matrix[15];
		b.matrix[8] = a.matrix[8] * matrix[0] + a.matrix[9] * matrix[4] + a.matrix[10] * matrix[8] + a.matrix[11] * matrix[12];
		b.matrix[9] = a.matrix[8] * matrix[1] + a.matrix[9] * matrix[5] + a.matrix[10] * matrix[9] + a.matrix[11] * matrix[13];
		b.matrix[10] = a.matrix[8] * matrix[2] + a.matrix[9] * matrix[6] + a.matrix[10] * matrix[10] + a.matrix[11] * matrix[14];
		b.matrix[11] = a.matrix[8] * matrix[3] + a.matrix[9] * matrix[7] + a.matrix[10] * matrix[11] + a.matrix[11] * matrix[15];
		b.matrix[12] = a.matrix[12] * matrix[0] + a.matrix[13] * matrix[4] + a.matrix[14] * matrix[8] + a.matrix[15] * matrix[12];
		b.matrix[13] = a.matrix[12] * matrix[1] + a.matrix[13] * matrix[5] + a.matrix[14] * matrix[9] + a.matrix[15] * matrix[13];
		b.matrix[14] = a.matrix[12] * matrix[2] + a.matrix[13] * matrix[6] + a.matrix[14] * matrix[10] + a.matrix[15] * matrix[14];
		b.matrix[15] = a.matrix[12] * matrix[3] + a.matrix[13] * matrix[7] + a.matrix[14] * matrix[11] + a.matrix[15] * matrix[15];
	}
}
function: ${"ja":"カメラ行列", "natja":"カメラ行列", "en":"setCameraMat", "naten":"setCameraMat"}$(Matrix4x4: m, Vector3D: pos, Vector3D: lookAt, Vector3D: up) => (Matrix4x4: res){
	Vector3D: newForward(lookAt.x - pos.x, lookAt.y - pos.y, lookAt.z - pos.z);
	Vector3D: a(0.0, 0.0, 0.0);
	a = extendVector3D(newForward, dotVector3D(up, newForward));
	Vector3D: newUp(up.x - a.x, up.y - a.y, up.z - a.z);
	newUp.normalize();
	Vector3D: newRight(0, 0, 0);
	newRight = crossVector3D(newUp, newForward);
	m.matrix = [newRight.x, newUp.x, newForward.x, 0.0, newRight.y, newUp.y, newForward.y, 0.0, newRight.z, newUp.z, newForward.z, 0.0, 0 - dotVector3D(newRight, pos), 0 - dotVector3D(newUp, pos), 0 - dotVector3D(newForward, pos), 1.0];
	return(m);
}
function: ${"ja":"視点行列3D", "natja":"視点行列3D", "en":"perspectiveMat3D", "naten":"perspectiveMat3D"}$(Matrix4x4: m, double: fov, double: width, double: height, double: zN, double: zF) => (Matrix4x4: result){
	double: PI = 3.14159265358979312;
	double: fov = 1.0 / tan((90.0 / 360.0) * PI);
	double: aspectRatio = width / height;
	double: zNear = zN;
	double: zFar = zF;
	double: zQ = zF / (zF - zN);
	m.matrix = [aspectRatio * fov, 0.0, 0.0, 0.0, 0.0, fov, 0.0, 0.0, 0.0, 0.0, zQ, 1.0, 0.0, 0.0, (0 - zFar * zNear) / (zFar - zNear), 0.0];
	return(m);
}
function: ${"ja":"視点行列2D", "natja":"視点行列2D", "en":"perspectiveMat2D", "naten":"perspectiveMat2D"}$(Matrix4x4: m, double: left, double: right, double: bottom, double: top, double: near, double: far) => (Matrix4x4: result){
	m.matrix = [2.0 / (right - left), 0.0, 0.0, 0.0, 0.0, 2.0 / (top - bottom), 0.0, 0.0, 0.0, 0.0, 0 - 2.0 / (near - far), 0.0, 0 - (right + left) / (right - left), 0 - (top + bottom) / (top - bottom), 0 - (far + near) / (far - near), 1.0];
	return(m);
}
function: ${"ja":"行列4x4の積", "natja":"行列4x4の積", "en":"mulMatrix4x4", "naten":"mulMatrix4x4"}$(Matrix4x4: a, Matrix4x4: b) => (Matrix4x4: out){
	out.matrix[0] = b.matrix[0] * a.matrix[0] + b.matrix[1] * a.matrix[4] + b.matrix[2] * a.matrix[8] + b.matrix[3] * a.matrix[12];
	out.matrix[1] = b.matrix[0] * a.matrix[1] + b.matrix[1] * a.matrix[5] + b.matrix[2] * a.matrix[9] + b.matrix[3] * a.matrix[13];
	out.matrix[2] = b.matrix[0] * a.matrix[2] + b.matrix[1] * a.matrix[6] + b.matrix[2] * a.matrix[10] + b.matrix[3] * a.matrix[14];
	out.matrix[3] = b.matrix[0] * a.matrix[3] + b.matrix[1] * a.matrix[7] + b.matrix[2] * a.matrix[11] + b.matrix[3] * a.matrix[15];
	out.matrix[4] = b.matrix[4] * a.matrix[0] + b.matrix[5] * a.matrix[4] + b.matrix[6] * a.matrix[8] + b.matrix[7] * a.matrix[12];
	out.matrix[5] = b.matrix[4] * a.matrix[1] + b.matrix[5] * a.matrix[5] + b.matrix[6] * a.matrix[9] + b.matrix[7] * a.matrix[13];
	out.matrix[6] = b.matrix[4] * a.matrix[2] + b.matrix[5] * a.matrix[6] + b.matrix[6] * a.matrix[10] + b.matrix[7] * a.matrix[14];
	out.matrix[7] = b.matrix[4] * a.matrix[3] + b.matrix[5] * a.matrix[7] + b.matrix[6] * a.matrix[11] + b.matrix[7] * a.matrix[15];
	out.matrix[8] = b.matrix[8] * a.matrix[0] + b.matrix[9] * a.matrix[4] + b.matrix[10] * a.matrix[8] + b.matrix[11] * a.matrix[12];
	out.matrix[9] = b.matrix[8] * a.matrix[1] + b.matrix[9] * a.matrix[5] + b.matrix[10] * a.matrix[9] + b.matrix[11] * a.matrix[13];
	out.matrix[10] = b.matrix[8] * a.matrix[2] + b.matrix[9] * a.matrix[6] + b.matrix[10] * a.matrix[10] + b.matrix[11] * a.matrix[14];
	out.matrix[11] = b.matrix[8] * a.matrix[3] + b.matrix[9] * a.matrix[7] + b.matrix[10] * a.matrix[11] + b.matrix[11] * a.matrix[15];
	out.matrix[12] = b.matrix[12] * a.matrix[0] + b.matrix[13] * a.matrix[4] + b.matrix[14] * a.matrix[8] + b.matrix[15] * a.matrix[12];
	out.matrix[13] = b.matrix[12] * a.matrix[1] + b.matrix[13] * a.matrix[5] + b.matrix[14] * a.matrix[9] + b.matrix[15] * a.matrix[13];
	out.matrix[14] = b.matrix[12] * a.matrix[2] + b.matrix[13] * a.matrix[6] + b.matrix[14] * a.matrix[10] + b.matrix[15] * a.matrix[14];
	out.matrix[15] = b.matrix[12] * a.matrix[3] + b.matrix[13] * a.matrix[7] + b.matrix[14] * a.matrix[11] + b.matrix[15] * a.matrix[15];
}
class: ${"ja":"光源クラス", "natja":"光源クラス", "en":"LightClass", "naten":"LightClass"}${
public: 	Vector3D: ${"ja":"座標", "natja":"座標", "en":"pos", "naten":"pos"}$;
	double: 半径;
	Vector3D: ambient;
	Vector3D: diffuse;
	Vector3D: specular;
	short: posLoc;
	short: radiusLoc;
	short: ambientLoc;
	short: diffuseLoc;
	short: specularLoc;
	function: LightClass(Vector3D: p, double: r, Vector3D: a, Vector3D: d, Vector3D: s, int: id) => (){
		pos = p;
		半径 = r;
		ambient = a;
		diffuse = d;
		specular = s;
		string: temp = "pointLights[";
		temp = temp + id;
		temp = temp + "]";
		string: posStr = temp + ".position";
		posLoc = glGetUniformLocation(0, posStr);
		string: radiusStr = temp + ".radius";
		radiusLoc = glGetUniformLocation(0, radiusStr);
		string: ambientStr = temp + ".ambient";
		ambientLoc = glGetUniformLocation(0, ambientStr);
		string: diffuseStr = temp + ".diffuse";
		diffuseLoc = glGetUniformLocation(0, diffuseStr);
		string: specularStr = temp + ".specular";
		specularLoc = glGetUniformLocation(0, specularStr);
	}
	function: ${"ja":"座標設定", "natja":"座標設定", "en":"setPos", "naten":"setPos"}$(Vector3D: coord) => (){
		pos = coord;
	}
}
class: ${"ja":"モデル", "natja":"モデル", "en":"Model", "naten":"Model"}${
public: 	Vector3D: ${"ja":"色", "natja":"色", "en":"color", "naten":"color"}$;
	Vector3D: ${"ja":"座標", "natja":"座標", "en":"pos", "naten":"pos"}$;
	int: lightID;
	Vector3D: scale;
	function: Model(*double: data, int: num, Vector3D: c, Vector3D: p, int: s) => (){
		scale.Vector3D(1.0, 1.0, 1.0);
		vertices = data;
		pointNum = num;
		color = c;
		pos = p;
		shaderID = s;
		lightID = (0 - (1));
		modelMat.identity();
		transMat.identity();
		scaleMat.identity();
		rotateMat.identity();
		defaultRotateMat.identity();
		if(shaderID == 0){
			viewPosUniLoc = glGetUniformLocation(0, "viewPos");
			objectColorUniLoc = glGetUniformLocation(0, "objectColor");
			dirLightDirUniLoc = glGetUniformLocation(0, "dirLight.direction");
			dirLightAmbientUniLoc = glGetUniformLocation(0, "dirLight.ambient");
			dirLightDiffuseUniLoc = glGetUniformLocation(0, "dirLight.diffuse");
			dirLightSpecularUniLoc = glGetUniformLocation(0, "dirLight.specular");
		}
		if(shaderID == 1){
			lightColorUniLoc = glGetUniformLocation(1, "lightColor");
		}
		projMatUniformLoc = glGetUniformLocation(shaderID, "uProjMat");
		viewMatUniformLoc = glGetUniformLocation(shaderID, "uViewMat");
		modelMatUniformLoc = glGetUniformLocation(shaderID, "uModelMat");
		buffer = glCreateBuffer();
		glBindBuffer(34962, buffer);
		glBufferData(34962, vertices, num * 6, 35044);
	}
	function: Model(*double: data, int: num, Vector3D: c, Vector3D: p, int: s, int: l) => (){
		scale.Vector3D(1.0, 1.0, 1.0);
		lightID = l;
		vertices = data;
		pointNum = num;
		color = c;
		pos = p;
		shaderID = s;
		modelMat.identity();
		transMat.identity();
		scaleMat.identity();
		rotateMat.identity();
		defaultRotateMat.identity();
		if(shaderID == 0){
			viewPosUniLoc = glGetUniformLocation(0, "viewPos");
			objectColorUniLoc = glGetUniformLocation(0, "objectColor");
			dirLightDirUniLoc = glGetUniformLocation(0, "dirLight.direction");
			dirLightAmbientUniLoc = glGetUniformLocation(0, "dirLight.ambient");
			dirLightDiffuseUniLoc = glGetUniformLocation(0, "dirLight.diffuse");
			dirLightSpecularUniLoc = glGetUniformLocation(0, "dirLight.specular");
		}
		if(shaderID == 1){
			lightColorUniLoc = glGetUniformLocation(1, "lightColor");
		}
		projMatUniformLoc = glGetUniformLocation(shaderID, "uProjMat");
		viewMatUniformLoc = glGetUniformLocation(shaderID, "uViewMat");
		modelMatUniformLoc = glGetUniformLocation(shaderID, "uModelMat");
		buffer = glCreateBuffer();
		glBindBuffer(34962, buffer);
		glBufferData(34962, vertices, num * 6, 35044);
	}
	function: ${"ja":"座標設定", "natja":"座標設定", "en":"setPos", "naten":"setPos"}$(Vector3D: coord) => (){
		pos = coord;
	}
	function: ${"ja":"移動", "natja":"移動", "en":"translate", "naten":"translate"}$(Vector3D: offset) => (){
		pos = addVector3D(pos, offset);
	}
	function: ${"ja":"拡大縮小設定", "natja":"拡大縮小設定", "en":"setScale", "naten":"setScale"}$(double: x, double: y, double: z) => (){
		scale.x = x;
		scale.y = y;
		scale.z = z;
	}
	function: ${"ja":"拡大縮小", "natja":"拡大縮小", "en":"scale", "naten":"scale"}$(double: x, double: y, double: z) => (){
		scale.x = scale.x * (x);
		scale.y = scale.y * (y);
		scale.z = scale.z * (z);
	}
	function: ${"ja":"回転設定", "natja":"回転設定", "en":"setRotate", "naten":"setRotate"}$(Vector3D: axis, double: t) => (){
		defaultRotateMat.identity();
		defaultRotateMat.rotate(axis, t);
	}
	function: ${"ja":"回転", "natja":"回転", "en":"rotate", "naten":"rotate"}$(Vector3D: axis, double: t) => (){
		Matrix4x4: temp;
		temp.identity();
		temp.rotate(axis, t);
		rotateMat = mulMatrix4x4(temp, rotateMat);
	}
	function: ${"ja":"回転", "natja":"回転", "en":"rotate", "naten":"rotate"}$(Vector3D: axis, double: t, Vector3D: offcenter) => (){
		Matrix4x4: temp;
		temp.identity();
		temp.translate(offcenter);
		rotateMat = mulMatrix4x4(temp, rotateMat);
		temp.identity();
		temp.rotate(axis, t);
		rotateMat = mulMatrix4x4(temp, rotateMat);
	}
	function: ${"ja":"描画", "natja":"描画", "en":"draw", "naten":"draw"}$(Matrix4x4: projMat, Matrix4x4: viewMat, Vector3D: camera, Array<*LightClass>: lights, LightClass: dirLight) => (){
		double: PI = 3.14159265358979312;
		scaleMat.identity();
		scaleMat.scale(scale.x, scale.y, scale.z);
		transMat.translate(pos);
		modelMat.identity();
		modelMat = mulMatrix4x4(scaleMat, modelMat);
		modelMat = mulMatrix4x4(defaultRotateMat, modelMat);
		modelMat = mulMatrix4x4(rotateMat, modelMat);
		modelMat = mulMatrix4x4(transMat, modelMat);
		glBindBuffer(34962, buffer);
		glEnableVertexAttribArray(0);
		glVertexAttribPointer(0, 3, 5126, 0, 6 * 4, 0);
		glEnableVertexAttribArray(1);
		glVertexAttribPointer(1, 3, 5126, 0, 6 * 4, 3 * 4);
		glUseProgram(shaderID);
		if(shaderID == 0){
			glUniform3f(objectColorUniLoc, color.x, color.y, color.z);
			glUniform3f(viewPosUniLoc, camera.x, camera.y, camera.z);
			glUniform3f(dirLightDirUniLoc, dirLight.pos.x, dirLight.pos.y, dirLight.pos.z);
			glUniform3f(dirLightAmbientUniLoc, dirLight.ambient.x, dirLight.ambient.y, dirLight.ambient.z);
			glUniform3f(dirLightDiffuseUniLoc, dirLight.diffuse.x, dirLight.diffuse.y, dirLight.diffuse.z);
			glUniform3f(dirLightSpecularUniLoc, dirLight.specular.x, dirLight.specular.y, dirLight.specular.z);
			repeat(lights.length()){
				*LightClass: lightPtr = lights.get(counter);
				glUniform3f(lightPtr->posLoc, lightPtr->pos.x, lightPtr->pos.y, lightPtr->pos.z);
				glUniform3f(lightPtr->ambientLoc, lightPtr->ambient.x, lightPtr->ambient.y, lightPtr->ambient.z);
				glUniform3f(lightPtr->diffuseLoc, lightPtr->diffuse.x, lightPtr->diffuse.y, lightPtr->diffuse.z);
				glUniform3f(lightPtr->specularLoc, lightPtr->specular.x, lightPtr->specular.y, lightPtr->specular.z);
				glUniform1f(lightPtr->radiusLoc, lightPtr->半径);
			}
		}
		if(shaderID == 1){
			glUniform3f(lightColorUniLoc, color.x, color.y, color.z);
		}
		glUniformMatrix4fv(projMatUniformLoc, 0, projMat.matrix);
		glUniformMatrix4fv(viewMatUniformLoc, 0, viewMat.matrix);
		glUniformMatrix4fv(modelMatUniformLoc, 0, modelMat.matrix);
		glBindBuffer(34962, buffer);
		glDrawArrays(4, 0, pointNum);
		rotateMat.identity();
		transMat.identity();
		scaleMat.identity();
	}
private: 	*double: vertices;
	int: pointNum;
	short: buffer;
	Matrix4x4: modelMat;
	Matrix4x4: transMat;
	Matrix4x4: scaleMat;
	Matrix4x4: rotateMat;
	Matrix4x4: defaultRotateMat;
	int: shaderID;
	short: viewPosUniLoc;
	short: lightPosUniLoc;
	short: lightColorUniLoc;
	short: objectColorUniLoc;
	short: dirLightDirUniLoc;
	short: dirLightAmbientUniLoc;
	short: dirLightDiffuseUniLoc;
	short: dirLightSpecularUniLoc;
	short: projMatUniformLoc;
	short: viewMatUniformLoc;
	short: modelMatUniformLoc;
}
class: ${"ja":"カメラ", "natja":"カメラ", "en":"Camera", "naten":"Camera"}${
public: 	Vector3D: ${"ja":"座標", "natja":"座標", "en":"pos", "naten":"pos"}$;
	double: ${"ja":"感度", "natja":"感度", "en":"sensitivity", "naten":"sensitivity"}$;
	function: Camera(Vector3D: p) => (){
		pos = p;
		view.Vector3D(0.0, 0.0, 1.0);
		lookDir.Vector3D(0.0, 0.0, 1.0);
		up.Vector3D(0.0, 1.0, 0.0);
		yaw = 90.0;
		pitch = 0.0;
		sensitivity = 1.0;
	}
	function: ${"ja":"座標設定", "natja":"座標設定", "en":"setPos", "naten":"setPos"}$(Vector3D: p) => (){
		pos = p;
	}
	function: ${"ja":"視点角度設定", "natja":"視点角度設定", "en":"setAngle", "naten":"setAngle"}$(double: y, double: p) => (){
		yaw = y;
		pitch = p;
	}
	function: ${"ja":"感度設定", "natja":"感度設定", "en":"setSensitivity", "naten":"setSensitivity"}$(double: s) => (){
		sensitivity = s;
	}
	function: ${"ja":"アップデート", "natja":"アップデート", "en":"update", "naten":"update"}$(double: xOffset, double: yOffset, double: elapsedTime) => (Matrix4x4: result){
		if(checkKeyPress(32) == 1){
			pos.y = pos.y + elapsedTime * 5.0;
		}
		if(checkKeyPress(16) == 1){
			pos.y = pos.y - elapsedTime * 5.0;
		}
		if(checkKeyPress(65) == 1){
			pos.z = pos.z - elapsedTime * sin(toRad(yaw - 90)) * 5.0;
			pos.x = pos.x - elapsedTime * cos(toRad(yaw - 90)) * 5.0;
		}
		if(checkKeyPress(68) == 1){
			pos.z = pos.z + elapsedTime * sin(toRad(yaw - 90)) * 5.0;
			pos.x = pos.x + elapsedTime * cos(toRad(yaw - 90)) * 5.0;
		}
		if(checkKeyPress(87) == 1){
			pos.z = pos.z + elapsedTime * sin(toRad(yaw)) * 5.0;
			pos.x = pos.x + elapsedTime * cos(toRad(yaw)) * 5.0;
		}
		if(checkKeyPress(83) == 1){
			pos.z = pos.z - elapsedTime * sin(toRad(yaw)) * 5.0;
			pos.x = pos.x - elapsedTime * cos(toRad(yaw)) * 5.0;
		}
		yaw = yaw - xOffset * sensitivity * elapsedTime;
		pitch = pitch - yOffset * sensitivity * elapsedTime;
		if(pitch < 0 - 89.0){
			pitch = 0 - 89.0;
		}
		if(pitch > 89.0){
			pitch = 89.0;
		}
		lookDir.x = cos(toRad(yaw)) * cos(toRad(pitch));
		lookDir.y = sin(toRad(pitch));
		lookDir.z = sin(toRad(yaw)) * cos(toRad(pitch));
		lookDir.normalize();
		result.identity();
		view = addVector3D(lookDir, pos);
		result = setCameraMat(result, pos, view, up);
	}
private: 	Vector3D: view;
	Vector3D: lookDir;
	Vector3D: up;
	double: yaw;
	double: pitch;
}
class: ${"ja":"シーン", "natja":"シーン", "en":"Scene", "naten":"Scene"}${
public: 	Array<*Model>: ${"ja":"スプライト配列", "natja":"スプライト配列", "en":"sprites", "naten":"sprites"}$;
	Array<*LightClass>: ${"ja":"光源配列", "natja":"光源配列", "en":"lights", "naten":"lights"}$;
	Camera: ${"ja":"目", "natja":"目", "en":"camera", "naten":"camera"}$;
	LightClass: 平行光源;
	function: Scene() => (){
		last = getTime() / 1000.0;
		now = 0.0;
		elapsedTime = 0.0;
		lastX = checkAbsoluteMouseX();
		lastY = checkAbsoluteMouseY();
		projMat.identity();
		viewMat.identity();
		projMat = perspectiveMat3D(projMat, 90.0, 720.0, 1280.0, 0.100000000000000006, 100.0);
		Vector3D: temp(0.0, 0.0, 0 - 4.0);
		camera.Camera(temp);
		sprites.Array();
		lights.Array();
		Vector3D: 方向((0 - (1.0)), (0 - (1.0)), (0 - (1.0)));
		Vector3D: 白(1.0, 1.0, 1.0);
		平行光源.pos = 方向;
		平行光源.ambient = 白 * 0.5;
		平行光源.diffuse = 白 * 0.5;
		平行光源.specular = 白 * 0.0;
	}
	function: ${"ja":"感度設定", "natja":"感度設定", "en":"setSensitivity", "naten":"setSensitivity"}$(double: sensitivity) => (){
		camera.setSensitivity(sensitivity);
	}
	function: ${"ja":"描画", "natja":"描画", "en":"draw", "naten":"draw"}$() => (){
		now = getTime() / 1000.0;
		elapsedTime = now - last;
		last = now;
		glClearColor(0.0, 0.0, 0.0, 1.0);
		glClearDepth(1.0);
		glEnable(2929);
		glDepthFunc(515);
		glClear(16640);
		double: xOffset = checkAbsoluteMouseX() - lastX;
		double: yOffset = checkAbsoluteMouseY() - lastY;
		lastX = checkAbsoluteMouseX();
		lastY = checkAbsoluteMouseY();
		viewMat.identity();
		viewMat = camera.update(xOffset, yOffset, elapsedTime);
		repeat(sprites.length()){
			if(sprites.get(counter)->lightID >= 0){
				lights.get(sprites.get(counter)->lightID)->setPos(sprites.get(counter)->pos);
			}
		}
		(int: i = 0;)from(i == sprites.size)to(i = i + 1;){
			sprites.get(i)->draw(projMat, viewMat, camera.pos, lights, 平行光源);
		}
	}
	function: ${"ja":"キューブ追加", "natja":"キューブ追加", "en":"addCube", "naten":"addCube"}$(double: size, Vector3D: color, Vector3D: pos) => (int: id){
		double: vertices[12][3][6] = [[[0 - size / 2, 0 - size / 2, 0 - size / 2, 0.0, 0.0, 0 - 1.0], [0 - size / 2, size / 2, 0 - size / 2, 0.0, 0.0, 0 - 1.0], [size / 2, size / 2, 0 - size / 2, 0.0, 0.0, 0 - 1.0]], [[0 - size / 2, 0 - size / 2, 0 - size / 2, 0.0, 0.0, 0 - 1.0], [size / 2, size / 2, 0 - size / 2, 0.0, 0.0, 0 - 1.0], [size / 2, 0 - size / 2, 0 - size / 2, 0.0, 0.0, 0 - 1.0]], [[size / 2, 0 - size / 2, 0 - size / 2, 1.0, 0.0, 0.0], [size / 2, size / 2, 0 - size / 2, 1.0, 0.0, 0.0], [size / 2, size / 2, size / 2, 1.0, 0.0, 0.0]], [[size / 2, 0 - size / 2, 0 - size / 2, 1.0, 0.0, 0.0], [size / 2, size / 2, size / 2, 1.0, 0.0, 0.0], [size / 2, 0 - size / 2, size / 2, 1.0, 0.0, 0.0]], [[size / 2, 0 - size / 2, size / 2, 0.0, 0.0, 1.0], [size / 2, size / 2, size / 2, 0.0, 0.0, 1.0], [0 - size / 2, size / 2, size / 2, 0.0, 0.0, 1.0]], [[size / 2, 0 - size / 2, size / 2, 0.0, 0.0, 1.0], [0 - size / 2, size / 2, size / 2, 0.0, 0.0, 1.0], [0 - size / 2, 0 - size / 2, size / 2, 0.0, 0.0, 1.0]], [[0 - size / 2, 0 - size / 2, size / 2, 0 - 1.0, 0.0, 0.0], [0 - size / 2, size / 2, size / 2, 0 - 1.0, 0.0, 0.0], [0 - size / 2, size / 2, 0 - size / 2, 0 - 1.0, 0.0, 0.0]], [[0 - size / 2, 0 - size / 2, size / 2, 0 - 1.0, 0.0, 0.0], [0 - size / 2, size / 2, 0 - size / 2, 0 - 1.0, 0.0, 0.0], [0 - size / 2, 0 - size / 2, 0 - size / 2, 0 - 1.0, 0.0, 0.0]], [[0 - size / 2, size / 2, 0 - size / 2, 0.0, 1.0, 0.0], [0 - size / 2, size / 2, size / 2, 0.0, 1.0, 0.0], [size / 2, size / 2, size / 2, 0.0, 1.0, 0.0]], [[0 - size / 2, size / 2, 0 - size / 2, 0.0, 1.0, 0.0], [size / 2, size / 2, size / 2, 0.0, 1.0, 0.0], [size / 2, size / 2, 0 - size / 2, 0.0, 1.0, 0.0]], [[size / 2, 0 - size / 2, size / 2, 0.0, 0 - 1.0, 0.0], [0 - size / 2, 0 - size / 2, size / 2, 0.0, 0 - 1.0, 0.0], [0 - size / 2, 0 - size / 2, 0 - size / 2, 0.0, 0 - 1.0, 0.0]], [[size / 2, 0 - size / 2, size / 2, 0.0, 0 - 1.0, 0.0], [0 - size / 2, 0 - size / 2, 0 - size / 2, 0.0, 0 - 1.0, 0.0], [size / 2, 0 - size / 2, 0 - size / 2, 0.0, 0 - 1.0, 0.0]]];
		*Model: cube = allocMemory(sizeof(*cube));
		cube->Model(&vertices, 36, color, pos, 0);
		sprites.push(cube);
		id = sprites.length() - 1;
	}
	function: ${"ja":"直方体追加", "natja":"直方体追加", "en":"addCuboid", "naten":"addCuboid"}$(double: width, double: height, double: depth, Vector3D: color, Vector3D: pos) => (int: id){
		id = addCube(1.0, color, pos);
		sprites.get(id)->scale(width, height, depth);
	}
	function: ${"ja":"ライト追加", "natja":"ライト追加", "en":"addLight", "naten":"addLight"}$(double: size, Vector3D: color, Vector3D: pos, double: 強さ) => (int: id){
		double: vertices[12][3][6] = [[[0 - size / 2, 0 - size / 2, 0 - size / 2, 0.0, 0.0, 0 - 1.0], [0 - size / 2, size / 2, 0 - size / 2, 0.0, 0.0, 0 - 1.0], [size / 2, size / 2, 0 - size / 2, 0.0, 0.0, 0 - 1.0]], [[0 - size / 2, 0 - size / 2, 0 - size / 2, 0.0, 0.0, 0 - 1.0], [size / 2, size / 2, 0 - size / 2, 0.0, 0.0, 0 - 1.0], [size / 2, 0 - size / 2, 0 - size / 2, 0.0, 0.0, 0 - 1.0]], [[size / 2, 0 - size / 2, 0 - size / 2, 1.0, 0.0, 0.0], [size / 2, size / 2, 0 - size / 2, 1.0, 0.0, 0.0], [size / 2, size / 2, size / 2, 1.0, 0.0, 0.0]], [[size / 2, 0 - size / 2, 0 - size / 2, 1.0, 0.0, 0.0], [size / 2, size / 2, size / 2, 1.0, 0.0, 0.0], [size / 2, 0 - size / 2, size / 2, 1.0, 0.0, 0.0]], [[size / 2, 0 - size / 2, size / 2, 0.0, 0.0, 1.0], [size / 2, size / 2, size / 2, 0.0, 0.0, 1.0], [0 - size / 2, size / 2, size / 2, 0.0, 0.0, 1.0]], [[size / 2, 0 - size / 2, size / 2, 0.0, 0.0, 1.0], [0 - size / 2, size / 2, size / 2, 0.0, 0.0, 1.0], [0 - size / 2, 0 - size / 2, size / 2, 0.0, 0.0, 1.0]], [[0 - size / 2, 0 - size / 2, size / 2, 0 - 1.0, 0.0, 0.0], [0 - size / 2, size / 2, size / 2, 0 - 1.0, 0.0, 0.0], [0 - size / 2, size / 2, 0 - size / 2, 0 - 1.0, 0.0, 0.0]], [[0 - size / 2, 0 - size / 2, size / 2, 0 - 1.0, 0.0, 0.0], [0 - size / 2, size / 2, 0 - size / 2, 0 - 1.0, 0.0, 0.0], [0 - size / 2, 0 - size / 2, 0 - size / 2, 0 - 1.0, 0.0, 0.0]], [[0 - size / 2, size / 2, 0 - size / 2, 0.0, 1.0, 0.0], [0 - size / 2, size / 2, size / 2, 0.0, 1.0, 0.0], [size / 2, size / 2, size / 2, 0.0, 1.0, 0.0]], [[0 - size / 2, size / 2, 0 - size / 2, 0.0, 1.0, 0.0], [size / 2, size / 2, size / 2, 0.0, 1.0, 0.0], [size / 2, size / 2, 0 - size / 2, 0.0, 1.0, 0.0]], [[size / 2, 0 - size / 2, size / 2, 0.0, 0 - 1.0, 0.0], [0 - size / 2, 0 - size / 2, size / 2, 0.0, 0 - 1.0, 0.0], [0 - size / 2, 0 - size / 2, 0 - size / 2, 0.0, 0 - 1.0, 0.0]], [[size / 2, 0 - size / 2, size / 2, 0.0, 0 - 1.0, 0.0], [0 - size / 2, 0 - size / 2, 0 - size / 2, 0.0, 0 - 1.0, 0.0], [size / 2, 0 - size / 2, 0 - size / 2, 0.0, 0 - 1.0, 0.0]]];
		*Model: light = allocMemory(sizeof(*light));
		light->Model(&vertices, 36, color, pos, 1, lights.length());
		*LightClass: lightObject = allocMemory(sizeof(*lightObject));
		lightObject->LightClass(pos, 強さ, color * 0.5, color * 0.5, color * 0.200000000000000011, lights.length());
		sprites.push(light);
		lights.push(lightObject);
		id = sprites.length() - 1;
	}
	function: ${"ja":"平行光源設定", "natja":"平行光源設定", "en":"setDirectionalLight", "naten":"setDirectionalLight"}$(Vector3D: 方向, Vector3D: color, double: ambient, double: diffuse, double: specular) => (){
		平行光源.pos = 方向;
		平行光源.ambient = color * ambient;
		平行光源.diffuse = color * diffuse;
		平行光源.specular = color * specular;
	}
	function: ${"ja":"_モデル追加", "natja":"_モデル追加", "en":"_addModel", "naten":"_addModel"}$(Array<Vector3D>: data, Array<Vector3D>: normals, Array<short>: vertexIndices, Array<short>: normalIndices, Vector3D: color, Vector3D: pos) => (int: id){
		Array<double>: vertices;
		if(normals.length() > 0){
			repeat(vertexIndices.length()){
				vertices.push(data.get(vertexIndices.get(counter) - 1).x);
				vertices.push(data.get(vertexIndices.get(counter) - 1).y);
				vertices.push(data.get(vertexIndices.get(counter) - 1).z);
				vertices.push(normals.get(normalIndices.get(counter) - 1).x);
				vertices.push(normals.get(normalIndices.get(counter) - 1).y);
				vertices.push(normals.get(normalIndices.get(counter) - 1).z);
			}
		}else{
			Array<Vector3D>: 三角形;
			repeat(vertexIndices.length()){
				三角形.push(data.get(vertexIndices.get(counter) - 1));
				if((counter % 3) == 2){
					Vector3D: 辺1 = 三角形.get(1) - 三角形.get(0);
					Vector3D: 辺2 = 三角形.get(2) - 三角形.get(0);
					Vector3D: normal = crossVector3D(辺1, 辺2);
					normal.normalize();
					repeat(三角形.length()){
						vertices.push(三角形.get(counter).x);
						vertices.push(三角形.get(counter).y);
						vertices.push(三角形.get(counter).z);
						vertices.push(normal.x);
						vertices.push(normal.y);
						vertices.push(normal.z);
					}
					三角形 = 三角形.removeRange(0, 3);
				}
			}
		}
		*Model: model = allocMemory(sizeof(*model));
		model->Model(vertices.content, vertexIndices.length(), color, pos, 0);
		sprites.push(model);
		id = sprites.length() - 1;
	}
	function: ${"ja":"モデル追加", "natja":"モデル追加", "en":"addModel", "naten":"addModel"}$(string: data, Vector3D: color, Vector3D: pos) => (int: id){
		Array<Vector3D>: vertices;
		Array<string>: lines = data.separate('\n');
		Array<short>: vertexIndices;
		Array<short>: normalIndices;
		Array<short>: uvIndices;
		Array<Vector3D>: normals;
		repeat(lines.length()){
			string: line = lines.get(counter);
			Array<string>: words = line.separate(' ');
			if(words.get(0) == "v"){
				Vector3D: temp(words.get(1).toDouble(), words.get(2).toDouble(), words.get(3).toDouble());
				vertices.push(temp);
			}
			if(words.get(0) == "f"){
				repeat(words.length()){
					if(counter != 0){
						Array<string>: faceData = words.get(counter).separate('/');
						vertexIndices.push(faceData.get(0).toInteger());
						if(faceData.length() == 3){
							uvIndices.push(faceData.get(1).toInteger());
							normalIndices.push(faceData.get(2).toInteger());
						}
					}
				}
			}
			if(words.get(0) == "vn"){
				Vector3D: temp(words.get(1).toDouble(), words.get(2).toDouble(), words.get(3).toDouble());
				normals.push(temp);
			}
		}
		id = _addModel(vertices, normals, vertexIndices, normalIndices, color, pos);
	}
private: 	Matrix4x4: projMat;
	Matrix4x4: viewMat;
	double: last;
	double: now;
	double: elapsedTime;
	double: lastX;
	double: lastY;
}
class: ${"ja":"ベクトル2D", "natja":"ベクトル2D", "en":"Vector2D", "naten":"Vector2D"}${
public: 	double: x;
	double: y;
	function: Vector2D(double: a, double: b) => (){
		x = a;
		y = b;
	}
	function: ${"ja":"長さ", "natja":"長さ", "en":"length", "naten":"length"}$() => (double: l){
		l = root(x * x + y * y);
	}
	function: ${"ja":"正規化", "natja":"正規化", "en":"normalize", "naten":"normalize"}$() => (){
		double: l = root(x * x + y * y);
		x = x / l;
		y = y / l;
	}
	function: operator + (Vector2D: a) => (Vector2D: b){
		b.x = a.x + x;
		b.y = a.y + y;
	}
	function: operator - (Vector2D: a) => (Vector2D: b){
		b.x = x - a.x;
		b.y = y - a.y;
	}
	function: operator * (double: k) => (Vector2D: b){
		b.x = x * k;
		b.y = y * k;
	}
	function: operator / (double: k) => (Vector2D: b){
		b.x = x / k;
		b.y = y / k;
	}
	function: operator == (Vector2D: a) => (bool: b){
		b = ((a.x == x) && (a.y == y));
	}
	function: operator != (Vector2D: a) => (bool: b){
		b = ((a.x != x) || (a.y != y));
	}
}
function: ${"ja":"ベクトル2Dの和", "natja":"ベクトル2Dの和", "en":"addVector2D", "naten":"addVector2D"}$(Vector2D: a, Vector2D: b) => (Vector2D: result){
	result.x = a.x + b.x;
	result.y = a.y + b.y;
}
function: ${"ja":"ベクトル2Dの差", "natja":"ベクトル2Dの差", "en":"subVector2D", "naten":"subVector2D"}$(Vector2D: a, Vector2D: b) => (Vector2D: result){
	result.x = a.x - b.x;
	result.y = a.y - b.y;
}
function: ${"ja":"ベクトル2Dの内積", "natja":"ベクトル2Dの内積", "en":"dotVector2D", "naten":"dotVector2D"}$(Vector2D: a, Vector2D: b) => (double: x){
	x = a.x * b.x + a.y * b.y;
}
function: ${"ja":"ベクトル2D拡大", "natja":"ベクトル2D拡大", "en":"extendVector2D", "naten":"extendVector2D"}$(Vector2D: a, double: x) => (Vector2D: result){
	result.x = a.x * x;
	result.y = a.y * x;
}
function: ${"ja":"ベクトル2D縮小", "natja":"ベクトル2D縮小", "en":"divVector2D", "naten":"divVector2D"}$(Vector2D: a, double: x) => (Vector2D: result){
	if(x == 0.0){
		print(10000000);
	}
	result.x = a.x / x;
	result.y = a.y / x;
}
class: ${"ja":"アニメーション情報", "natja":"アニメーション情報", "en":"AnimationInfo", "naten":"AnimationInfo"}${
public: 	int: id;
	double: startTime;
	double: duration;
	Vector2D: info;
	function: AnimationInfo(int: a, double: start, double: d, double: x, double: y) => (){
		id = a;
		startTime = start;
		duration = d;
		info.x = x;
		info.y = y;
	}
	function: AnimationInfo() => (){
		id = 0;
		startTime = 0;
		duration = 0;
		info.x = 0;
		info.y = 0;
	}
	function: operator == (AnimationInfo: a) => (bool: b){
		b = ((a.id == id) && (a.startTime == startTime) && (a.duration == duration) && (a.info == info) && (a.info == info));
	}
	function: operator != (AnimationInfo: a) => (bool: b){
		b = ((a.id != id) || (a.startTime != startTime) || (a.duration != duration) || (a.info != info) || (a.info != info));
	}
}
class: ${"ja":"スプライト", "natja":"スプライト", "en":"Sprite", "naten":"Sprite"}${
public: 	Vector3D: color;
	Vector2D: pos;
	function: Sprite(*double: data, int: pnum, *short: indicesData, int: vnum, Vector3D: c, Vector2D: p, int: s, int: st, double: zI) => (){
		vertices = data;
		pointNum = pnum;
		indices = indicesData;
		vertexNum = vnum;
		zIndex = zI;
		透明度 = 1.0;
		spriteType = st;
		color = c;
		pos = p;
		scaleX = 1.0;
		scaleY = 1.0;
		theta = 0.0;
		shaderID = s;
		animations.Array();
		modelMat.identity();
		transMat.identity();
		scaleMat.identity();
		rotateMat.identity();
		projMatUniformLoc = glGetUniformLocation(shaderID, "projection");
		modelMatUniformLoc = glGetUniformLocation(shaderID, "model");
		if(shaderID == 4){
			transparencyUniLoc = glGetUniformLocation(shaderID, "transparency");
			objectColorUniLoc = glGetUniformLocation(shaderID, "objectColor");
		}
		if(shaderID == 3){
			samplerUniformLoc = glGetUniformLocation(shaderID, "uSampler");
		}
		buffer = glCreateBuffer();
		glBindBuffer(34962, buffer);
		glBufferData(34962, vertices, pnum * 3, 35044);
		if(vnum > 0){
			elementBuffer = glCreateBuffer();
			glBindBuffer(34963, elementBuffer);
			glElementBufferData(34963, indices, vnum, 35044);
		}
	}
	function: ${"ja":"テクスチャ設定", "natja":"テクスチャ設定", "en":"setTexture", "naten":"setTexture"}$(*double: tex, string: url) => (){
		shaderID = 0;
		texCoords = tex;
		texture = _loadTexture(url.content, url.length);
		_printString(url.content, url.length);
		texCoordBuffer = glCreateBuffer();
		glBindBuffer(34962, texCoordBuffer);
		glBufferData(34962, tex, vertexNum * 2, 35044);
	}
	function: ${"ja":"リピートテクスチャ設定", "natja":"リピートテクスチャ設定", "en":"setRepeatTexture", "naten":"setRepeatTexture"}$(*double: tex, short: テクスチャ) => (){
		shaderID = 0;
		texCoords = tex;
		texture = テクスチャ;
		texCoordBuffer = glCreateBuffer();
		glBindBuffer(34962, texCoordBuffer);
		glBufferData(34962, tex, vertexNum * 2, 35044);
	}
	function: ${"ja":"座標設定", "natja":"座標設定", "en":"setPos", "naten":"setPos"}$(Vector2D: coord) => (){
		pos = coord;
	}
	function: ${"ja":"移動", "natja":"移動", "en":"translate", "naten":"translate"}$(Vector2D: offset) => (){
		pos = addVector2D(pos, offset);
	}
	function: ${"ja":"拡大縮小", "natja":"拡大縮小", "en":"scale", "naten":"scale"}$(double: x, double: y) => (){
		scaleX = scaleX * x;
		scaleY = scaleY * y;
	}
	function: ${"ja":"拡大縮小設定", "natja":"拡大縮小設定", "en":"setScale", "naten":"setScale"}$(double: x, double: y) => (){
		scaleX = x;
		scaleY = y;
	}
	function: ${"ja":"回転", "natja":"回転", "en":"rotate", "naten":"rotate"}$(double: t) => (){
		theta = theta + t;
	}
	function: ${"ja":"角度設定", "natja":"角度設定", "en":"setRotation", "naten":"setRotation"}$(double: t) => (){
		theta = t;
	}
	function: ${"ja":"重なり順設定", "natja":"重なり順設定", "en":"setZIndex", "naten":"setZIndex"}$(double: x) => (){
		zIndex = x;
	}
	function: ${"ja":"透明度設定", "natja":"透明度設定", "en":"setTransparency", "naten":"setTransparency"}$(double: x) => (){
		透明度 = x;
	}
	function: ${"ja":"色設定", "natja":"色設定", "en":"setColor", "naten":"setColor"}$(Vector3D: color) => (){
		color = color;
	}
	function: ${"ja":"描画", "natja":"描画", "en":"draw", "naten":"draw"}$(Matrix4x4: projMat) => (){
		double: PI = 3.14159265358979312;
		(int: counter = 0;)from(counter == animations.size)to(counter = counter + 1;){
			AnimationInfo: info = animations.get(counter);
			if((info.startTime <= getTime()) && ((info.startTime + info.duration) >= getTime())){
				if(info.id == 0){
					double: elapsedTime = getTime() - info.startTime;
					rotate(info.info.x * elapsedTime);
				}
				if(info.id == 1){
					scale(info.info.x, info.info.y);
				}
				if(info.id == 2){
					double: elapsedTime = getTime() - info.startTime;
					Vector2D: offset(info.info.x * elapsedTime, info.info.y * elapsedTime);
					translate(offset);
				}
			}
		}
		Vector3D: pos3d(pos.x, pos.y, 0 - zIndex * 0.00100000000000000002);
		transMat.identity();
		transMat.translate(pos3d);
		scaleMat.identity();
		scaleMat.scale(scaleX, scaleY, 1.0);
		Vector3D: 回転軸(0.0, 0.0, 1.0);
		rotateMat.identity();
		rotateMat.rotate(回転軸, theta);
		modelMat.identity();
		modelMat = mulMatrix4x4(scaleMat, modelMat);
		modelMat = mulMatrix4x4(rotateMat, modelMat);
		modelMat = mulMatrix4x4(transMat, modelMat);
		glUseProgram(shaderID);
		glBindBuffer(34962, buffer);
		glEnableVertexAttribArray(0);
		glVertexAttribPointer(0, 3, 5126, 0, 0, 0);
		if(shaderID == 4){
			glUniform1f(transparencyUniLoc, 透明度);
			glUniform3f(objectColorUniLoc, color.x, color.y, color.z);
		}
		if(shaderID == 3){
			glBindBuffer(34962, texCoordBuffer);
			glEnableVertexAttribArray(1);
			glVertexAttribPointer(1, 2, 5126, 0, 0, 0);
			glActiveTexture(texture + 33984);
			glBindTexture(3553, texture);
			glUniform1i(samplerUniformLoc, texture);
		}
		glUniformMatrix4fv(projMatUniformLoc, 0, projMat.matrix);
		glUniformMatrix4fv(modelMatUniformLoc, 0, modelMat.matrix);
		if(spriteType == 1){
			glBindBuffer(34962, buffer);
			glDrawArrays(3, 0, pointNum);
		}else{
			if(vertexNum > 0){
				glBindBuffer(34963, elementBuffer);
				glDrawElements(4, vertexNum, 5123, 0);
			}
			if((vertexNum == 0) && (shaderID == 4)){
				glBindBuffer(34962, buffer);
				glDrawArrays(5, 0, pointNum);
			}
		}
		rotateMat.identity();
		transMat.identity();
		scaleMat.identity();
	}
	function: ${"ja":"回転アニメーション", "natja":"回転アニメーション", "en":"rotateAnimation", "naten":"rotateAnimation"}$(double: theta, double: start, double: duration) => (){
		AnimationInfo: temp(0, start, duration, theta, 0.0);
		animations.push(temp);
	}
	function: ${"ja":"拡大縮小アニメーション", "natja":"拡大縮小アニメーション", "en":"scaleAnimation", "naten":"scaleAnimation"}$(double: x, double: y, double: start, double: duration) => (){
		AnimationInfo: temp(1, start, duration, x, y);
		animations.push(temp);
	}
	function: ${"ja":"移動アニメーション", "natja":"移動アニメーション", "en":"translateAnimation", "naten":"translateAnimation"}$(Vector2D: offset, double: start, double: duration) => (){
		AnimationInfo: temp(0, start, duration, offset.x, offset.y);
		animations.push(temp);
	}
private: 	*double: vertices;
	*short: indices;
	*double: texCoords;
	int: vertexNum;
	int: pointNum;
	short: buffer;
	short: texCoordBuffer;
	short: elementBuffer;
	short: texture;
	Matrix4x4: modelMat;
	Matrix4x4: transMat;
	Matrix4x4: scaleMat;
	Matrix4x4: rotateMat;
	double: zIndex;
	int: shaderID;
	short: objectColorUniLoc;
	short: transparencyUniLoc;
	short: projMatUniformLoc;
	short: modelMatUniformLoc;
	short: samplerUniformLoc;
	Array<AnimationInfo>: animations;
	double: 透明度;
	double: scaleX;
	double: scaleY;
	double: theta;
	int: spriteType;
}
class: ${"ja":"シーン2D", "natja":"シーン2D", "en":"Scene2D", "naten":"Scene2D"}${
public: 	Array<*Sprite>: ${"ja":"スプライト配列", "natja":"スプライト配列", "en":"sprites", "naten":"sprites"}$;
	Vector3D: ${"ja":"背景色", "natja":"背景色", "en":"backgroundColor", "naten":"backgroundColor"}$;
	double: ${"ja":"背景透明度", "natja":"背景透明度", "en":"backgroundTransparency", "naten":"backgroundTransparency"}$;
	double: zoom;
	function: Scene2D(double: 高さ, Vector3D: color) => (){
		zoom = 100.0;
		last = getTime() / 1000.0;
		now = 0.0;
		elapsedTime = 0.0;
		projMat.identity();
		projMat = perspectiveMat2D(projMat, ((0 - (高さ))) * (16.0 / 9.0), (高さ) * (16.0 / 9.0), (0 - (高さ)), 高さ, 0.0 - 5.0, 5.0);
		sprites.Array();
		backgroundColor = color;
		backgroundTransparency = 1.0;
	}
	function: ${"ja":"背景透明度設定", "natja":"背景透明度設定", "en":"setBackgroundTransparency", "naten":"setBackgroundTransparency"}$(double: a) => (){
		backgroundTransparency = a;
	}
	function: ${"ja":"描画", "natja":"描画", "en":"draw", "naten":"draw"}$() => (){
		zoom = zoom + checkScroll();
		if(zoom > 400.0){
			zoom = 400.0;
		}
		if(zoom < 8.0){
			zoom = 8.0;
		}
		now = getTime() / 1000.0;
		elapsedTime = now - last;
		last = now;
		glClearColor(backgroundColor.x, backgroundColor.y, backgroundColor.z, backgroundTransparency);
		glClearDepth(1.0);
		glEnable(2929);
		glDepthFunc(515);
		glEnable(3042);
		glBlendFunc(770, 771);
		glClear(16640);
		(int: i = 0;)from(i == sprites.size)to(i = i + 1;){
			sprites.get(i)->setScale(1.0 / (zoom * 0.0100000000000000002), 1.0 / (zoom * 0.0100000000000000002));
			sprites.get(i)->draw(projMat);
		}
	}
	function: ${"ja":"正方形追加", "natja":"正方形追加", "en":"addSquare", "naten":"addSquare"}$(double: size, Vector2D: pos, Vector3D: color, double: zIndex) => (int: id){
		double: vertices[4][3] = [[size / 2, size / 2, 0 - zIndex * 0.00100000000000000002], [size / 2, 0 - size / 2, 0 - zIndex * 0.00100000000000000002], [0 - size / 2, 0 - size / 2, 0 - zIndex * 0.00100000000000000002], [0 - size / 2, size / 2, 0 - zIndex * 0.00100000000000000002]];
		double: texCoords[4][2] = [[1.0, 0.0], [1.0, 1.0], [0.0, 1.0], [0.0, 0.0]];
		short: indices[6] = [0, 1, 3, 1, 2, 3];
		*Sprite: sprite = allocMemory(sizeof(*sprite));
		sprite->Sprite(&vertices, 4, &indices, 6, color, pos, 4, 0, zIndex);
		sprites.push(sprite);
		id = sprites.length() - 1;
	}
	function: ${"ja":"スプライト追加", "natja":"スプライト追加", "en":"addSprite", "naten":"addSprite"}$(double: width, double: height, Vector2D: pos, string: url, double: zIndex) => (int: id){
		double: vertices[4][3] = [[width / 2, height / 2, 0 - zIndex * 0.00100000000000000002], [width / 2, 0 - height / 2, 0 - zIndex * 0.00100000000000000002], [0 - width / 2, 0 - height / 2, 0 - zIndex * 0.00100000000000000002], [0 - width / 2, height / 2, 0 - zIndex * 0.00100000000000000002]];
		double: texCoords[4][2] = [[1.0, 0.0], [1.0, 1.0], [0.0, 1.0], [0.0, 0.0]];
		short: indices[6] = [0, 1, 3, 1, 2, 3];
		Vector3D: color(0.0, 0.0, 0.0);
		*Sprite: sprite = allocMemory(sizeof(*sprite));
		sprite->Sprite(&vertices, 4, &indices, 6, color, pos, 3, 0, zIndex);
		sprite->setTexture(&texCoords, url);
		sprites.push(sprite);
		id = sprites.length() - 1;
	}
	function: ${"ja":"リピートスプライト追加", "natja":"リピートスプライト追加", "en":"addRepeatSprite", "naten":"addRepeatSprite"}$(double: width, double: height, Vector2D: pos, short: texture, double: zIndex) => (int: id){
		double: vertices[4][3] = [[width / 2, height / 2, 0 - zIndex * 0.00100000000000000002], [width / 2, 0 - height / 2, 0 - zIndex * 0.00100000000000000002], [0 - width / 2, 0 - height / 2, 0 - zIndex * 0.00100000000000000002], [0 - width / 2, height / 2, 0 - zIndex * 0.00100000000000000002]];
		double: texCoords[4][2] = [[1.0, 0.0], [1.0, 1.0], [0.0, 1.0], [0.0, 0.0]];
		short: indices[6] = [0, 1, 3, 1, 2, 3];
		Vector3D: color(0.0, 0.0, 0.0);
		*Sprite: sprite = allocMemory(sizeof(*sprite));
		sprite->Sprite(&vertices, 4, &indices, 6, color, pos, 3, 0, zIndex);
		sprite->setRepeatTexture(&texCoords, texture);
		sprites.push(sprite);
		id = sprites.length() - 1;
	}
	function: ${"ja":"四角形追加", "natja":"四角形追加", "en":"addRectangle", "naten":"addRectangle"}$(double: width, double: height, Vector2D: pos, Vector3D: color, double: zIndex) => (int: id){
		double: vertices[4][3] = [[width / 2, height / 2, 0 - zIndex * 0.00100000000000000002], [0 - width / 2, height / 2, 0 - zIndex * 0.00100000000000000002], [width / 2, 0 - height / 2, 0 - zIndex * 0.00100000000000000002], [0 - width / 2, 0 - height / 2, 0 - zIndex * 0.00100000000000000002]];
		*Sprite: sprite = allocMemory(sizeof(*sprite));
		sprite->Sprite(&vertices, 4, allocMemory(0), 0, color, pos, 4, 0, zIndex);
		sprites.push(sprite);
		id = sprites.length() - 1;
	}
	function: ${"ja":"多角形追加", "natja":"多角形追加", "en":"addPolygon", "naten":"addPolygon"}$(Array<Vector2D>: points, Vector2D: pos, Vector3D: color, double: zIndex) => (int: id){
		Array<double>: temp;
		repeat(points.length()){
			temp.push(points.content[counter].x);
			temp.push(points.content[counter].y);
			temp.push((0 - (zIndex * 0.00100000000000000002)));
		}
		*Sprite: sprite = allocMemory(sizeof(*sprite));
		sprite->Sprite(temp.content, temp.length() / 3, allocMemory(0), 0, color, pos, 4, 0, zIndex);
		sprites.push(sprite);
		id = sprites.length() - 1;
	}
	function: ${"ja":"円追加", "natja":"円追加", "en":"addCircle", "naten":"addCircle"}$(double: r, Vector2D: pos, Vector3D: color, double: zIndex) => (int: id){
		double: PI = 3.14159265358979312;
		Array<Vector2D>: points;
		int: 頂点数 = 60;
		(int: i = 0;)from(i == 頂点数)to(i = i + 1;){
			double: theta = 0;
			if((i % 2) == 0){
				theta = 0.5 * PI + ((PI * i) / 頂点数);
			}
			if((i % 2) == 1){
				theta = 0.5 * PI - ((PI * (1.0 + i)) / 頂点数);
			}
			Vector2D: temp(r * cos(theta), r * sin(theta));
			points.push(temp);
		}
		id = addPolygon(points, pos, color, zIndex);
	}
	function: ${"ja":"線追加", "natja":"線追加", "en":"addLine", "naten":"addLine"}$(Vector2D: start, Vector2D: end, Vector3D: color, double: zIndex) => (int: id){
		Array<double>: points;
		points.push(start.x);
		points.push(start.y);
		points.push((0 - (zIndex * 0.00100000000000000002)));
		points.push(end.x);
		points.push(end.y);
		points.push((0 - (zIndex * 0.00100000000000000002)));
		*Sprite: sprite = allocMemory(sizeof(*sprite));
		sprite->Sprite(points.content, points.length() / 3, allocMemory(0), 0, color, Vector2D(0.0, 0.0), 4, 1, zIndex);
		sprites.push(sprite);
		id = sprites.length() - 1;
	}
	function: ${"ja":"線追加", "natja":"線追加", "en":"addLine", "naten":"addLine"}$(function: (double: a) => (double: b): c, double: dx, double: start, double: end, Vector2D: pos, Vector3D: color, double: zIndex) => (int: id){
		Array<double>: points;
		(double: x = start;)from(x >= end)to(x = x + dx;){
			points.push(x);
			points.push(c(x));
			points.push((0 - (zIndex * 0.00100000000000000002)));
		}
		*Sprite: sprite = allocMemory(sizeof(*sprite));
		sprite->Sprite(points.content, points.length() / 3, allocMemory(0), 0, color, pos, 4, 1, zIndex);
		sprites.push(sprite);
		id = sprites.length() - 1;
	}
	function: ${"ja":"媒介変数表示線追加", "natja":"媒介変数表示線追加", "en":"addLine", "naten":"addLine"}$(function: (double: theta) => (Vector2D: pos): c, double: dx, double: start, double: end, Vector2D: pos, Vector3D: color, double: zIndex) => (int: id){
		Array<double>: points;
		(double: x = start;)from(x >= end)to(x = x + dx;){
			Vector2D: temp = c(x);
			points.push(temp.x);
			points.push(temp.y);
			points.push((0 - (zIndex * 0.00100000000000000002)));
		}
		*Sprite: sprite = allocMemory(sizeof(*sprite));
		sprite->Sprite(points.content, points.length() / 3, allocMemory(0), 0, color, pos, 4, 1, zIndex);
		sprites.push(sprite);
		id = sprites.length() - 1;
	}
private: 	Matrix4x4: projMat;
	double: last;
	double: now;
	double: elapsedTime;
}
function: 引数なしjsリスナー呼び出し(function: () => (): callback) => (){
	callback();
}
jsexport(引数なしjsリスナー呼び出し, "jsCallListenerNoParam");
function: __setUpVariableNamesForSamples() => (){
	double: ${"ja":"前の数", "natja":"前の数", "en":"numberBefore", "naten":"numberBefore"}$;
	double: ${"ja":"数", "natja":"数", "en":"number", "naten":"number"}$;
	double: ${"ja":"入力", "natja":"入力", "en":"input", "naten":"input"}$;
	double: ${"ja":"出力", "natja":"出力", "en":"output", "naten":"output"}$;
	double: ${"ja":"返り値", "natja":"返り値", "en":"returnValue", "naten":"returnValue"}$;
	double: ${"ja":"初期数", "natja":"初期数", "en":"initialNumber", "naten":"initialNumber"}$;
	double: ${"ja":"コラッツ", "natja":"コラッツ", "en":"collatz", "naten":"collatz"}$;
	double: ${"ja":"結果", "natja":"結果", "en":"result", "naten":"result"}$;
	double: ${"ja":"かける数", "natja":"かける数", "en":"numberToMultiply", "naten":"numberToMultiply"}$;
	double: ${"ja":"ワールド", "natja":"ワールド", "en":"world", "naten":"world"}$;
	double: ${"ja":"光源座標", "natja":"光源座標", "en":"lightPosition", "naten":"lightPosition"}$;
	double: ${"ja":"回転軸", "natja":"回転軸", "en":"axis", "naten":"axis"}$;
	double: ${"ja":"位置", "natja":"位置", "en":"position", "naten":"position"}$;
	double: ${"ja":"キューブID", "natja":"キューブID", "en":"cubeID", "naten":"cubeID"}$;
	double: ${"ja":"光源ID", "natja":"光源ID", "en":"lightID", "naten":"lightID"}$;
	double: ${"ja":"キューブIDリスト", "natja":"キューブIDリスト", "en":"cubeIDlist", "naten":"cubeIDlist"}$;
	double: ${"ja":"回数", "natja":"回数", "en":"numberOfTimes", "naten":"numberOfTimes"}$;
	double: ${"ja":"初期位置", "natja":"初期位置", "en":"initialPosition", "naten":"initialPosition"}$;
	double: ${"ja":"幅", "natja":"幅", "en":"width", "naten":"width"}$;
	double: ${"ja":"高さ", "natja":"高さ", "en":"height", "naten":"height"}$;
	double: ${"ja":"質量", "natja":"質量", "en":"mass", "naten":"mass"}$;
	double: ${"ja":"慣性モーメント", "natja":"慣性モーメント", "en":"momentOfInertia", "naten":"momentOfInertia"}$;
	double: ${"ja":"速度", "natja":"速度", "en":"velocity", "naten":"velocity"}$;
	double: ${"ja":"角度", "natja":"角度", "en":"angle", "naten":"angle"}$;
	double: ${"ja":"角速度", "natja":"角速度", "en":"angularVelocity", "naten":"angularVelocity"}$;
	double: ${"ja":"力", "natja":"力", "en":"force", "naten":"force"}$;
	double: ${"ja":"トルク", "natja":"トルク", "en":"torque", "naten":"torque"}$;
	double: ${"ja":"形", "natja":"形", "en":"shape", "naten":"shape"}$;
	double: ${"ja":"物理ワールド2D", "natja":"物理ワールド2D", "en":"physicsWorld2D", "naten":"physicsWorld2D"}$;
	double: ${"ja":"物体配列", "natja":"物体配列", "en":"bodyArray", "naten":"bodyArray"}$;
	double: ${"ja":"重力加速度", "natja":"重力加速度", "en":"gravitationalAccelaration", "naten":"gravitationalAccelaration"}$;
	double: ${"ja":"前回の時間", "natja":"前回の時間", "en":"timeBefore", "naten":"timeBefore"}$;
	double: ${"ja":"物体追加", "natja":"物体追加", "en":"addBody", "naten":"addBody"}$;
	double: ${"ja":"重力", "natja":"重力", "en":"gravity", "naten":"gravity"}$;
	double: ${"ja":"アップデート", "natja":"アップデート", "en":"update", "naten":"update"}$;
	double: ${"ja":"経過時間", "natja":"経過時間", "en":"timePassed", "naten":"timePassed"}$;
	double: ${"ja":"角加速度", "natja":"角加速度", "en":"angularAccelaration", "naten":"angularAccelaration"}$;
	double: ${"ja":"物理ワールド", "natja":"物理ワールド", "en":"physicsWorld", "naten":"physicsWorld"}$;
	double: ${"ja":"初速度", "natja":"初速度", "en":"initialVelocity", "naten":"initialVelocity"}$;
	double: ${"ja":"初速度", "natja":"初速度", "en":"initialVelocity", "naten":"initialVelocity"}$;
	double: ${"ja":"素数", "natja":"素数", "en":"primeNumbers", "naten":"primeNumbers"}$;
	double: ${"ja":"フラグ", "natja":"フラグ", "en":"flag", "naten":"flag"}$;
	double: ${"ja":"漸化式", "natja":"漸化式", "en":"recursion", "naten":"recursion"}$;
	double: ${"ja":"変数1", "natja":"変数1", "en":"variable1", "naten":"variable1"}$;
	double: ${"ja":"変数2", "natja":"変数2", "en":"variable2", "naten":"variable2"}$;
	double: ${"ja":"変数3", "natja":"変数3", "en":"variable3", "naten":"variable3"}$;
	double: ${"ja":"変数4", "natja":"変数4", "en":"variable4", "naten":"variable4"}$;
	double: ${"ja":"変数5", "natja":"変数5", "en":"variable5", "naten":"variable5"}$;
	double: ${"ja":"変数6", "natja":"変数6", "en":"variable6", "naten":"variable6"}$;
	double: ${"ja":"変数7", "natja":"変数7", "en":"variable7", "naten":"variable7"}$;
	double: ${"ja":"変数8", "natja":"変数8", "en":"variable8", "naten":"variable8"}$;
	double: ${"ja":"変数9", "natja":"変数9", "en":"variable9", "naten":"variable9"}$;
	double: ${"ja":"ロボット", "natja":"ロボット", "en":"robot", "naten":"robot"}$;
	double: ${"ja":"コース", "natja":"コース", "en":"course", "naten":"course"}$;
}
class: ArduinoClass{
public: 	char: ${"ja":"出力ピン", "natja":"出力ピン", "en":"OUTPUT", "naten":"OUTPUT"}$;
	char: ${"ja":"入力ピン", "natja":"入力ピン", "en":"INPUT", "naten":"INPUT"}$;
	function: ArduinoClass() => (){
		OUTPUT = '出';
		INPUT = '入';
	}
}
function: ${"ja":"Arduino5V送る", "natja":"Arduino5V送る", "en":"ArduinoOutput5V", "naten":"ArduinoOutput5V"}$(int: ピン番号) => (){
	ArduinoSendCommand('H', ピン番号);
}
function: ${"ja":"Arduino0V送る", "natja":"Arduino0V送る", "en":"ArduinoOutput0V", "naten":"ArduinoOutput0V"}$(int: ピン番号) => (){
	ArduinoSendCommand('L', ピン番号);
}
function: ${"ja":"Arduinoピン入出力設定", "natja":"Arduinoピン入出力設定", "en":"ArduinoSetPinmode", "naten":"ArduinoSetPinmode"}$(int: ピン番号, char: 入出力) => (){
	if(入出力 == '入'){
		ArduinoSendCommand('I', ピン番号);
	}
	if(入出力 == '出'){
		ArduinoSendCommand('O', ピン番号);
	}
}
function: ${"ja":"Arduinoアナログ入力ピン設定", "natja":"Arduinoアナログ入力ピン設定", "en":"ArduinoSetAnalogInputPin", "naten":"ArduinoSetAnalogInputPin"}$(int: ピン番号) => (){
	ArduinoSendCommand('A', ピン番号);
}
function: ${"ja":"ArduinoHCSR04設定", "natja":"ArduinoHCSR04設定", "en":"ArduinoHCSR04Trigger", "naten":"ArduinoHCSR04Trigger"}$(int: ピン番号) => (){
	ArduinoSendCommand('T', ピン番号);
}
class: ${"ja":"ライントレースシミュレーション", "natja":"ライントレースシミュレーション", "en":"linetraceSimulation", "naten":"linetraceSimulation"}${
public: 	Scene: world;
	Array<Vector2D>: 直線データ;
	double: ${"ja":"センサー値", "natja":"センサー値", "en":"sensorValue", "naten":"sensorValue"}$[2];
	double: ${"ja":"左センサー値", "natja":"左センサー値", "en":"leftSensorValue", "naten":"leftSensorValue"}$;
	double: ${"ja":"右センサー値", "natja":"右センサー値", "en":"rightSensorValue", "naten":"rightSensorValue"}$;
	int: ${"ja":"左モーターON", "natja":"左モーターON", "en":"leftMotorON", "naten":"leftMotorON"}$;
	int: ${"ja":"右モーターON", "natja":"右モーターON", "en":"rightMotorON", "naten":"rightMotorON"}$;
	int: ${"ja":"左モーター向き", "natja":"左モーター向き", "en":"leftMotorSequence", "naten":"leftMotorSequence"}$;
	int: ${"ja":"右モーター向き", "natja":"右モーター向き", "en":"rightMotorSequence", "naten":"rightMotorSequence"}$;
	double: ${"ja":"左モーター速度", "natja":"左モーター速度", "en":"leftMotorSpeed", "naten":"leftMotorSpeed"}$;
	double: ${"ja":"右モーター速度", "natja":"右モーター速度", "en":"rightMotorSpeed", "naten":"rightMotorSpeed"}$;
	double: スタートタイム;
	double: エンドタイム;
	function: linetraceSimulation(Array<double>: points, Vector2D: firstPos, double: ax, double: ay, double: bx, double: byp) => (){
		直線データ.Array();
		world.Scene();
		ロボット移動方向.Vector2D(0.0, 1.0);
		スタートマーク[0] = ax;
		スタートマーク[1] = ay;
		スタートマーク[2] = bx;
		スタートマーク[3] = byp;
		leftMotorSpeed = 3;
		rightMotorSpeed = 3;
		leftMotorSequence = 1;
		rightMotorSequence = 1;
		leftMotorON = 0;
		rightMotorON = 0;
		スタートタイム = getTime();
		ロボット速度 = 1.0;
		ロボット座標 = firstPos;
		Vector3D: 灰色(0.800000000000000044, 0.800000000000000044, 0.800000000000000044);
		Vector3D: 白(1.0, 1.0, 1.0);
		Vector3D: 黒(0.0, 0.0, 0.0);
		Vector3D: 初期位置1(firstPos.x, 0.0, firstPos.y);
		Vector3D: 初期位置2(5.0, 5.0, 5.0);
		Vector3D: 初期位置3(0.0, (0 - (0.5)), 0.0);
		Vector3D: 初期位置4(firstPos.x, 10.0, firstPos.y);
		Vector3D: axis(0.0, 1.0, 0.0);
		points.push(points.get(0));
		points.push(points.get(1));
		world.setDirectionalLight(初期位置3, 白, 0.0500000000000000028, 0.0500000000000000028, 0.0);
		world.camera.setSensitivity(5.0);
		world.camera.setPos(初期位置4);
		world.camera.setAngle(90.0, (0 - (90.0)));
		ロボットID = world.addModel(loadSampleModel("robot"), 灰色, 初期位置1);
		world.sprites.get(ロボットID)->setRotate(Vector3D(0.0, 1.0, 0.0), toRad(180));
		ライトID = world.addLight(1.0, 白, 初期位置2, 1000.0);
		センサー1ID = world.addCube(0.200000000000000011, Vector3D(0.0, 0.0, 0.0), Vector3D(0.0, 0.0, 0.0));
		センサー2ID = world.addCube(0.200000000000000011, Vector3D(0.0, 0.0, 0.0), Vector3D(0.0, 0.0, 0.0));
		world.addCuboid(100.0, 1.0, 100.0, 白, 初期位置3);
		(int: counter = 0;)from(counter == (points.length() - 2))to(counter = counter + 2;){
			Vector2D: A(points.get(counter), points.get(counter + 1));
			Vector2D: B(points.get(counter + 2), points.get(counter + 3));
			if(A != B){
				Vector2D: 差 = B - A;
				Vector2D: 和 = A + B;
				double: 傾き = (A.y - B.y) / (A.x - B.x);
				直線データ.push(A);
				double: length = 差.length();
				Vector2D: temp座標 = 和 * 0.5;
				Vector3D: temp3D座標(temp座標.x, 0.0, temp座標.y);
				int: tempID = world.addCuboid(length, 0.25, 0.25, 黒, temp3D座標);
				world.sprites.get(tempID)->setRotate(axis, (0 - (jsArcTan(傾き))));
			}
		}
		直線データ.push(Vector2D(points.get(0), points.get(1)));
	}
	function: translate() => (){
		double: PI = 3.14159265358979312;
		double: 左モーター距離 = leftMotorSpeed * leftMotorON * leftMotorSequence * 0.0160000000000000003;
		double: 右モーター距離 = rightMotorSpeed * rightMotorON * rightMotorSequence * 0.0160000000000000003;
		double: 基本距離 = 右モーター距離;
		double: a = 1.0;
		if(右モーター距離 >= 左モーター距離){
			基本距離 = 左モーター距離;
			a = (0 - (1.0));
		}
		double: b = (0 - (1.0));
		double: theta = 180.0 * jsArcTan(右モーター距離 - 左モーター距離) / PI;
		if(右モーター距離 == 左モーター距離){
			theta = 0;
			a = 0.0;
			b = 0.0;
		}
		a = a * ((0 - (1.0)));
		b = b * ((0 - (1.0)));
		ロボット角度 = ロボット角度 + theta;
		ロボット移動方向.x = cos(toRad(ロボット角度 + 90.0));
		ロボット移動方向.y = sin(toRad(ロボット角度 + 90.0));
		ロボット座標.x = ロボット座標.x + a * cos(toRad(ロボット角度)) - b * sin(toRad(ロボット角度)) - a;
		ロボット座標.x = ロボット座標.x - (a * cos(toRad(ロボット角度 - theta)) - b * sin(toRad(ロボット角度 - theta)) - a);
		ロボット座標.y = ロボット座標.y + a * sin(toRad(ロボット角度)) + b * cos(toRad(ロボット角度)) - b;
		ロボット座標.y = ロボット座標.y - (a * sin(toRad(ロボット角度 - theta)) + b * cos(toRad(ロボット角度 - theta)) - b);
		world.sprites.get(ロボットID)->setRotate(Vector3D(0.0, 1.0, 0.0), toRad((0 - (ロボット角度 + 180))));
		ロボット座標 = ロボット座標 + (ロボット移動方向 * 基本距離);
	}
	function: update() => (){
		Vector2D: センサー座標[2] = ロボット座標;
		if((!おわり) && checkLineCross(センサー座標[0].x, センサー座標[0].y, センサー座標[1].x, センサー座標[1].y, スタートマーク[0], スタートマーク[1], スタートマーク[2], スタートマーク[3])){
			おわり = true;
			エンドタイム = getTime();
			updateLinetraceTime((エンドタイム - スタートタイム) / 1000);
		}
		if(!おわり){
			translate();
			センサー座標[0].x = 1.75 * cos(toRad(ロボット角度 + 79.0)) + ロボット座標.x;
			センサー座標[0].y = 1.75 * sin(toRad(ロボット角度 + 79.0)) + ロボット座標.y;
			センサー座標[1].x = 1.75 * cos(toRad(ロボット角度 + 101.0)) + ロボット座標.x;
			センサー座標[1].y = 1.75 * sin(toRad(ロボット角度 + 101.0)) + ロボット座標.y;
			world.sprites.get(センサー1ID)->setPos(Vector3D(センサー座標[0].x, 0.400000000000000022, センサー座標[0].y));
			world.sprites.get(センサー2ID)->setPos(Vector3D(センサー座標[1].x, 0.400000000000000022, センサー座標[1].y));
			world.sprites.get(センサー1ID)->setRotate(Vector3D(0.0, 1.0, 0.0), toRad((0 - (ロボット角度 + 180))));
			world.sprites.get(センサー2ID)->setRotate(Vector3D(0.0, 1.0, 0.0), toRad((0 - (ロボット角度 + 180))));
			double: センサー距離[2] = [10000.0, 10000.0];
			int: センサー数 = 2;
			repeat(センサー数){
				(int: i = 0;)from(i == (直線データ.length() - 1))to(i = i + 1;){
					Vector2D: A = 直線データ.get(i);
					Vector2D: B = 直線データ.get(i + 1);
					Vector2D: AB = B - A;
					Vector2D: Aセンサー座標 = センサー座標[counter] - A;
					Vector2D: Bセンサー座標 = センサー座標[counter] - B;
					if((dotVector2D(AB, Aセンサー座標) >= 0) && (dotVector2D(AB * (0 - (1.0)), Bセンサー座標) >= 0)){
						double: 傾き = (A.y - B.y) / (A.x - B.x);
						double: y切片 = A.y - (傾き * A.x);
						double: 距離 = abs(傾き * センサー座標[counter].x - センサー座標[counter].y + y切片) / root(1.0 + 傾き * 傾き);
						if(abs(傾き) > 10000.0){
							距離 = abs(A.x - センサー座標[counter].x);
						}
						if(センサー距離[counter] > 距離){
							センサー距離[counter] = 距離;
						}
					}else{
						if(センサー距離[counter] > Aセンサー座標.length()){
							センサー距離[counter] = Aセンサー座標.length();
						}
						if(センサー距離[counter] > Bセンサー座標.length()){
							センサー距離[counter] = Bセンサー座標.length();
						}
					}
				}
			}
			sensorValue[0] = センサー距離[0] * 768.0;
			sensorValue[1] = センサー距離[1] * 768.0;
			if(sensorValue[0] > 255){
				sensorValue[0] = 255.0;
			}
			if(sensorValue[1] > 255){
				sensorValue[1] = 255.0;
			}
			rightSensorValue = sensorValue[0];
			leftSensorValue = sensorValue[1];
			Vector3D: ロボット座標3D(ロボット座標.x, 0.0, ロボット座標.y);
			Vector3D: ライト座標3D(ロボット座標.x + 5.0, 5.0, ロボット座標.y + 5.0);
			world.sprites.get(ロボットID)->setPos(ロボット座標3D);
			world.sprites.get(ライトID)->setPos(ライト座標3D);
		}
		world.draw();
	}
private: 	int: ロボットID;
	int: ライトID;
	double: ロボット角度;
	Vector2D: ロボット移動方向;
	double: ロボット速度;
	Vector2D: ロボット座標;
	Vector2D: ロボット初期位置;
	int: センサー1ID;
	int: センサー2ID;
	Vector2D: ロボットoffset;
	bool: おわり;
	double: スタートマーク[4];
}
