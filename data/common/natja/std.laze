( x という 実数 ) を  とり ${"ja":"実数表示", "natja":"実数表示", "en":"printDouble", "naten":"printDouble"}$ という  関数  を ( "console", "log") から  読み込む  。 
( x という 実数 ) を  とり ${"ja":"デバッグ表示", "natja":"デバッグ表示", "en":"debug", "naten":"debug"}$ という  関数  を ( "console", "debug") から  読み込む  。 
( offset [ 4 ] [ 4 ] という 実数 ) を  とり ${"ja":"行列表示", "natja":"行列表示", "en":"printMatrix", "naten":"printMatrix"}$ という  関数  を ( "console", "logMatrix") から  読み込む  。 
( x という * 無 ) を  とり ${"ja":"アドレス表示", "natja":"アドレス表示", "en":"printAddress", "naten":"printAddress"}$ という  関数  を ( "console", "log") から  読み込む  。 
( x という * 文字 , 長さ という 整数 ) を  とり ${"ja":"_文字列表示", "natja":"_文字列表示", "en":"_printString", "naten":"_printString"}$ という  関数  を ( "console", "logstring") から  読み込む  。 
( 時間 という 実数 ) を  返す ${"ja":"時間計測", "natja":"時間計測", "en":"getTime", "naten":"getTime"}$ という  関数  を ( "std", "performanceNow") から  読み込む  。 
( i という 整数32 ) を  とり ${"ja":"glClearDepth", "natja":"glClearDepth", "en":"glClearDepth", "naten":"glClearDepth"}$ という  関数  を ( "graphics", "clearDepth") から  読み込む  。 
( i という 整数32 ) を  とり ${"ja":"glDepthFunc", "natja":"glDepthFunc", "en":"glDepthFunc", "naten":"glDepthFunc"}$ という  関数  を ( "graphics", "depthFunc") から  読み込む  。 
( i という 整数32 ) を  とり ${"ja":"glEnable", "natja":"glEnable", "en":"glEnable", "naten":"glEnable"}$ という  関数  を ( "graphics", "enable") から  読み込む  。 
( i という 整数32 ) を  とり ${"ja":"glDisable", "natja":"glDisable", "en":"glDisable", "naten":"glDisable"}$ という  関数  を ( "graphics", "disable") から  読み込む  。 
( prog という 整数32 ) を  返す ${"ja":"glCreateProgram", "natja":"glCreateProgram", "en":"glCreateProgram", "naten":"glCreateProgram"}$ という  関数  を ( "graphics", "createProgram") から  読み込む  。 
( buffer という 整数32 ) を  返す ${"ja":"glCreateBuffer", "natja":"glCreateBuffer", "en":"glCreateBuffer", "naten":"glCreateBuffer"}$ という  関数  を ( "graphics", "createBuffer") から  読み込む  。 
( i という 整数32 , j という 整数32 ) を  とり ${"ja":"glBindBuffer", "natja":"glBindBuffer", "en":"glBindBuffer", "naten":"glBindBuffer"}$ という  関数  を ( "graphics", "bindBuffer") から  読み込む  。 
( i という 整数32 , offset という * 実数 , size という 整数32 , j という 整数32 ) を  とり ${"ja":"glBufferData", "natja":"glBufferData", "en":"glBufferData", "naten":"glBufferData"}$ という  関数  を ( "graphics", "bufferData") から  読み込む  。 
( i という 整数32 , offset という * 整数32 , size という 整数32 , j という 整数32 ) を  とり ${"ja":"glElementBufferData", "natja":"glElementBufferData", "en":"glElementBufferData", "naten":"glElementBufferData"}$ という  関数  を ( "graphics", "elementBufferData") から  読み込む  。 
( i という 整数32 ) を  とり ${"ja":"glUseProgram", "natja":"glUseProgram", "en":"glUseProgram", "naten":"glUseProgram"}$ という  関数  を ( "graphics", "useProgram") から  読み込む  。 
( i という 整数32 , offset という * 文字 , size という 整数32 ) を  とり ( loc という 整数32 ) を  返す ${"ja":"glGetAttribLocation", "natja":"glGetAttribLocation", "en":"glGetAttribLocation", "naten":"glGetAttribLocation"}$ という  関数  を ( "graphics", "getAttribLocation") から  読み込む  。 
( index という 整数32 , size という 整数32 , ty という 整数32 , normalized という 整数32 , stride という 整数32 , offset という 整数32 ) を  とり ${"ja":"glVertexAttribPointer", "natja":"glVertexAttribPointer", "en":"glVertexAttribPointer", "naten":"glVertexAttribPointer"}$ という  関数  を ( "graphics", "vertexAttribPointer") から  読み込む  。 
( index という 整数32 ) を  とり ${"ja":"glEnableVertexAttribArray", "natja":"glEnableVertexAttribArray", "en":"glEnableVertexAttribArray", "naten":"glEnableVertexAttribArray"}$ という  関数  を ( "graphics", "enableVertexAttribArray") から  読み込む  。 
( i という 整数32 , first という 整数32 , count という 整数32 ) を  とり ${"ja":"glDrawArrays", "natja":"glDrawArrays", "en":"glDrawArrays", "naten":"glDrawArrays"}$ という  関数  を ( "graphics", "drawArrays") から  読み込む  。 
( i という 整数32 , offset という * 文字 , size という 整数32 ) を  とり ( loc という 整数32 ) を  返す ${"ja":"_glGetUniformLocation", "natja":"_glGetUniformLocation", "en":"_glGetUniformLocation", "naten":"_glGetUniformLocation"}$ という  関数  を ( "graphics", "getUniformLocation") から  読み込む  。 
( loc という 整数32 , trans という 整数32 , offset という * 実数 ) を  とり ${"ja":"glUniformMatrix2fv", "natja":"glUniformMatrix2fv", "en":"glUniformMatrix2fv", "naten":"glUniformMatrix2fv"}$ という  関数  を ( "graphics", "uniformMatrix2fv") から  読み込む  。 
( loc という 整数32 , trans という 整数32 , offset という * 実数 ) を  とり ${"ja":"glUniformMatrix3fv", "natja":"glUniformMatrix3fv", "en":"glUniformMatrix3fv", "naten":"glUniformMatrix3fv"}$ という  関数  を ( "graphics", "uniformMatrix3fv") から  読み込む  。 
( loc という 整数32 , trans という 整数32 , offset [ 16 ] という 実数 ) を  とり ${"ja":"glUniformMatrix4fv", "natja":"glUniformMatrix4fv", "en":"glUniformMatrix4fv", "naten":"glUniformMatrix4fv"}$ という  関数  を ( "graphics", "uniformMatrix4fv") から  読み込む  。 
( loc という 整数32 , v0 という 実数 ) を  とり ${"ja":"glUniform1f", "natja":"glUniform1f", "en":"glUniform1f", "naten":"glUniform1f"}$ という  関数  を ( "graphics", "uniform1f") から  読み込む  。 
( loc という 整数32 , v0 という 実数 ) を  とり ${"ja":"glUniform1fv", "natja":"glUniform1fv", "en":"glUniform1fv", "naten":"glUniform1fv"}$ という  関数  を ( "graphics", "uniform1fv") から  読み込む  。 
( loc という 整数32 , v0 という 整数32 ) を  とり ${"ja":"glUniform1i", "natja":"glUniform1i", "en":"glUniform1i", "naten":"glUniform1i"}$ という  関数  を ( "graphics", "uniform1i") から  読み込む  。 
( loc という 整数32 , v0 という 整数32 ) を  とり ${"ja":"glUniform1iv", "natja":"glUniform1iv", "en":"glUniform1iv", "naten":"glUniform1iv"}$ という  関数  を ( "graphics", "uniform1iv") から  読み込む  。 
( loc という 整数32 , v0 という 実数 , v1 という 実数 ) を  とり ${"ja":"glUniform2f", "natja":"glUniform2f", "en":"glUniform2f", "naten":"glUniform2f"}$ という  関数  を ( "graphics", "uniform2f") から  読み込む  。 
( loc という 整数32 , v0 という 実数 , v1 という 実数 ) を  とり ${"ja":"glUniform2fv", "natja":"glUniform2fv", "en":"glUniform2fv", "naten":"glUniform2fv"}$ という  関数  を ( "graphics", "uniform2fv") から  読み込む  。 
( loc という 整数32 , v0 という 整数32 , v1 という 整数32 ) を  とり ${"ja":"glUniform2i", "natja":"glUniform2i", "en":"glUniform2i", "naten":"glUniform2i"}$ という  関数  を ( "graphics", "uniform2i") から  読み込む  。 
( loc という 整数32 , v0 という 整数32 , v1 という 整数32 ) を  とり ${"ja":"glUniform2iv", "natja":"glUniform2iv", "en":"glUniform2iv", "naten":"glUniform2iv"}$ という  関数  を ( "graphics", "uniform2iv") から  読み込む  。 
( loc という 整数32 , v0 という 実数 , v1 という 実数 , v2 という 実数 ) を  とり ${"ja":"glUniform3f", "natja":"glUniform3f", "en":"glUniform3f", "naten":"glUniform3f"}$ という  関数  を ( "graphics", "uniform3f") から  読み込む  。 
( loc という 整数32 , v0 という 実数 , v1 という 実数 , v2 という 実数 ) を  とり ${"ja":"glUniform3fv", "natja":"glUniform3fv", "en":"glUniform3fv", "naten":"glUniform3fv"}$ という  関数  を ( "graphics", "uniform3fv") から  読み込む  。 
( loc という 整数32 , v0 という 整数32 , v1 という 整数32 , v2 という 整数32 ) を  とり ${"ja":"glUniform3i", "natja":"glUniform3i", "en":"glUniform3i", "naten":"glUniform3i"}$ という  関数  を ( "graphics", "uniform3i") から  読み込む  。 
( loc という 整数32 , v0 という 整数32 , v1 という 整数32 , v2 という 整数32 ) を  とり ${"ja":"glUniform3iv", "natja":"glUniform3iv", "en":"glUniform3iv", "naten":"glUniform3iv"}$ という  関数  を ( "graphics", "uniform3iv") から  読み込む  。 
( loc という 整数32 , v0 という 実数 , v1 という 実数 , v2 という 実数 , v3 という 実数 ) を  とり ${"ja":"glUniform4f", "natja":"glUniform4f", "en":"glUniform4f", "naten":"glUniform4f"}$ という  関数  を ( "graphics", "uniform4f") から  読み込む  。 
( loc という 整数32 , v0 という 実数 , v1 という 実数 , v2 という 実数 , v3 という 実数 ) を  とり ${"ja":"glUniform4fv", "natja":"glUniform4fv", "en":"glUniform4fv", "naten":"glUniform4fv"}$ という  関数  を ( "graphics", "uniform4fv") から  読み込む  。 
( loc という 整数32 , v0 という 整数32 , v1 という 整数32 , v2 という 整数32 , v3 という 整数32 ) を  とり ${"ja":"glUniform4i", "natja":"glUniform4i", "en":"glUniform4i", "naten":"glUniform4i"}$ という  関数  を ( "graphics", "uniform4i") から  読み込む  。 
( loc という 整数32 , v0 という 整数32 , v1 という 整数32 , v2 という 整数32 , v3 という 整数32 ) を  とり ${"ja":"glUniform4iv", "natja":"glUniform4iv", "en":"glUniform4iv", "naten":"glUniform4iv"}$ という  関数  を ( "graphics", "uniform4iv") から  読み込む  。 
( r という 実数 , g という 実数 , b という 実数 , a という 実数 ) を  とり ${"ja":"glClearColor", "natja":"glClearColor", "en":"glClearColor", "naten":"glClearColor"}$ という  関数  を ( "graphics", "clearColor") から  読み込む  。 
( color という 整数32 ) を  とり ${"ja":"glClear", "natja":"glClear", "en":"glClear", "naten":"glClear"}$ という  関数  を ( "graphics", "clear") から  読み込む  。 
( i という 整数32 , count という 整数32 , ty という 整数32 , offset という 整数32 ) を  とり ${"ja":"glDrawElements", "natja":"glDrawElements", "en":"glDrawElements", "naten":"glDrawElements"}$ という  関数  を ( "graphics", "drawElements") から  読み込む  。 
( i という 整数32 , j という 整数32 ) を  とり ${"ja":"glBlendFunc", "natja":"glBlendFunc", "en":"glBlendFunc", "naten":"glBlendFunc"}$ という  関数  を ( "graphics", "blendFunc") から  読み込む  。 
( keyCode という 整数32 ) を  とり ( pressed という 整数 ) を  返す ${"ja":"キーチェック", "natja":"キーチェック", "en":"checkKeyPress", "naten":"checkKeyPress"}$ という  関数  を ( "std", "checkKeyPress") から  読み込む  。 
( pressed という 整数 ) を  返す ${"ja":"マウスチェック", "natja":"マウスチェック", "en":"checkMousePress", "naten":"checkMousePress"}$ という  関数  を ( "std", "checkMousePress") から  読み込む  。 
( x という 実数 ) を  返す ${"ja":"マウス相対座標X", "natja":"マウス相対座標X", "en":"checkRelativeMouseX", "naten":"checkRelativeMouseX"}$ という  関数  を ( "std", "checkRelativeMouseX") から  読み込む  。 
( x という 実数 ) を  返す ${"ja":"マウス相対座標Y", "natja":"マウス相対座標Y", "en":"checkRelativeMouseY", "naten":"checkRelativeMouseY"}$ という  関数  を ( "std", "checkRelativeMouseY") から  読み込む  。 
( x という 実数 ) を  返す ${"ja":"マウス絶対座標X", "natja":"マウス絶対座標X", "en":"checkAbsoluteMouseX", "naten":"checkAbsoluteMouseX"}$ という  関数  を ( "std", "checkAbsoluteMouseX") から  読み込む  。 
( x という 実数 ) を  返す ${"ja":"マウス絶対座標Y", "natja":"マウス絶対座標Y", "en":"checkAbsoluteMouseY", "naten":"checkAbsoluteMouseY"}$ という  関数  を ( "std", "checkAbsoluteMouseY") から  読み込む  。 
( x という 実数 ) を  返す ${"ja":"スクロール座標", "natja":"スクロール座標", "en":"checkScroll", "naten":"checkScroll"}$ という  関数  を ( "std", "checkScrollY") から  読み込む  。 
( x という 実数 ) を  返す ${"ja":"ランダム数生成", "natja":"ランダム数生成", "en":"rand", "naten":"rand"}$ という  関数  を ( "std", "rand") から  読み込む  。 
( size という 整数32 ) を  とり ( p という * 無 ) を  返す ${"ja":"メモリ確保", "natja":"メモリ確保", "en":"allocMemory", "naten":"allocMemory"}$ という  関数  を ( "std", "alloc") から  読み込む  。 
( offset という * 文字 , length という 整数32 ) を  とり ( a という 整数32 ) を  返す ${"ja":"テクスチャロード", "natja":"テクスチャロード", "en":"_loadTexture", "naten":"_loadTexture"}$ という  関数  を ( "graphics", "loadTexture") から  読み込む  。 
( i という 整数32 ) を  とり ${"ja":"glActiveTexture", "natja":"glActiveTexture", "en":"glActiveTexture", "naten":"glActiveTexture"}$ という  関数  を ( "graphics", "activeTexture") から  読み込む  。 
( i という 整数32 , j という 整数32 ) を  とり ${"ja":"glBindTexture", "natja":"glBindTexture", "en":"glBindTexture", "naten":"glBindTexture"}$ という  関数  を ( "graphics", "bindTexture") から  読み込む  。 
関数 ${"ja":"マウスキャプチャ", "natja":"マウスキャプチャ", "en":"captureMouse", "naten":"captureMouse"}$ を ( "graphics", "lockPointer") から  読み込む  。 
( vendorId という 整数 , c という 関数 : ( ) => ( ) ) を  とり ${"ja":"Arduino設定", "natja":"Arduino設定", "en":"ArduinoSetup", "naten":"ArduinoSetup"}$ という  関数  を ( "arduino", "setUp") から  読み込む  。 
( コマンド という 文字 , data という 整数32 ) を  とり ${"ja":"Arduinoコマンド送信", "natja":"Arduinoコマンド送信", "en":"ArduinoSendCommand", "naten":"ArduinoSendCommand"}$ という  関数  を ( "arduino", "sendCommand") から  読み込む  。 
関数 ${"ja":"Arduinoデータ受信", "natja":"Arduinoデータ受信", "en":"ArduinoReceiveData", "naten":"ArduinoReceiveData"}$ を ( "arduino", "checkInput") から  読み込む  。 
( ピン番号 という 整数 ) を  とり ( データ という 整数32 ) を  返す ${"ja":"Arduinoアナログ入力", "natja":"Arduinoアナログ入力", "en":"ArduinoAnalogInput", "naten":"ArduinoAnalogInput"}$ という  関数  を ( "arduino", "analogRead") から  読み込む  。 
( ピン番号 という 整数 ) を  とり ( データ という 整数32 ) を  返す ${"ja":"Arduinoデジタル入力", "natja":"Arduinoデジタル入力", "en":"ArduinoDigitalInput", "naten":"ArduinoDigitalInput"}$ という  関数  を ( "arduino", "digitalRead") から  読み込む  。 
( ピン番号 という 整数 ) を  とり ( データ という 整数32 ) を  返す ${"ja":"ArduinoHCSR04距離入力", "natja":"ArduinoHCSR04距離入力", "en":"ArduinoHCSR04DistanceInput", "naten":"ArduinoHCSR04DistanceInput"}$ という  関数  を ( "arduino", "distanceRead") から  読み込む  。 
( s という * 無 ) を  返す getTeapot という  関数  を ( "graphics", "getTeapot") から  読み込む  。 
( s という * 無 ) を  返す getMountains という  関数  を ( "graphics", "getMountains") から  読み込む  。 
( s という * 無 ) を  返す getTeddybear という  関数  を ( "graphics", "getTeddybear") から  読み込む  。 
( s という * 無 ) を  返す getCow という  関数  を ( "graphics", "getCow") から  読み込む  。 
( s という * 無 ) を  返す getFox という  関数  を ( "graphics", "getFox") から  読み込む  。 
( s という * 無 ) を  返す getRobot という  関数  を ( "graphics", "getRobot") から  読み込む  。 
( x という 実数 ) を  とり ( r という 実数 ) を  返す jsArcSin という  関数  を ( "std", "asin") から  読み込む  。 
( x という 実数 ) を  とり ( r という 実数 ) を  返す jsArcCos という  関数  を ( "std", "acos") から  読み込む  。 
( x という 実数 ) を  とり ( r という 実数 ) を  返す jsArcTan という  関数  を ( "std", "atan") から  読み込む  。 
( x という 実数 ) を  とり ( r という 実数 ) を  返す jsLog という  関数  を ( "std", "log") から  読み込む  。 
( x という 実数 ) を  とり ( r という 実数 ) を  返す jsEPow という  関数  を ( "std", "ePow") から  読み込む  。 
( x という 実数 , y という 実数 ) を  とり ( r という 実数 ) を  返す jsPow という  関数  を ( "std", "exp") から  読み込む  。 
( x という 実数 ) を  とり updateLinetraceTime という  関数  を ( "linetrace", "updateLinetraceTime") から  読み込む  。 
( input という 実数 ) を  とり ( 結果 という 実数 ) を  返す ${"ja":"sin", "natja":"sin", "en":"sin", "naten":"sin"}$ という  関数  を  おく  。 ここから
	PI という 実数 を 3.14159265358979312 で  初期化  。 
	temp という 整数 を input  / ( 2.0  * PI ) で  初期化  。 
	rad という 実数 を input  - ( 2.0  * PI  * temp ) で  初期化  。 
	plusminus という 実数 を 1.0 で  初期化  。 
	もし rad  < 0.0 ならば ここから
		rad に rad  + ( 2.0  * PI ) を  代入する  。 
	ここまで実行 
	もし rad  > PI ならば ここから
		plusminus に 0  - 1.0 を  代入する  。 
		もし rad  > 1.5  * PI ならば ここから
			rad に ( 2.0  * PI )  - rad を  代入する  。 
		ここまで実行 でなければ ここから
			rad に rad  - PI を  代入する  。 
		ここまで実行 
	ここまで実行 でなければ ここから
		もし rad  > 0.5  * PI ならば ここから
			rad に PI  - rad を  代入する  。 
		ここまで実行 
	ここまで実行 
	もし rad  > 0.25  * PI ならば ここから
		rad に ( 0.5  * PI )  - rad を  代入する  。 
		doubleRad という 実数 を rad  * rad で  初期化  。 
		結果 に 1.0  - ( doubleRad )  / 2.0  + ( doubleRad  * doubleRad )  / 24.0  - ( doubleRad  * doubleRad  * doubleRad )  / 720.0  + ( doubleRad  * doubleRad  * doubleRad  * doubleRad )  / 40320.0  - ( doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad )  / 3628800.0  + ( doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad )  / 479001600.0 を  代入する  。 
		結果 に 結果  * plusminus を  代入する  。 
	ここまで実行 でなければ ここから
		doubleRad という 実数 を rad  * rad で  初期化  。 
		結果 に rad  - ( rad  * doubleRad )  / 6.0  + ( rad  * doubleRad  * doubleRad )  / 120.0  - ( rad  * doubleRad  * doubleRad  * doubleRad )  / 5040.0  + ( rad  * doubleRad  * doubleRad  * doubleRad  * doubleRad )  / 362880.0  - ( rad  * doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad )  / 39916800.0  + ( rad  * doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad )  / 6227020800.0  - ( rad  * doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad )  / 1307674368000.0 を  代入する  。 
		結果 に 結果  * plusminus を  代入する  。 
	ここまで実行 
ここまで実行 
( input という 実数 ) を  とり ( 結果 という 実数 ) を  返す ${"ja":"cos", "natja":"cos", "en":"cos", "naten":"cos"}$ という  関数  を  おく  。 ここから
	PI という 実数 を 3.14159265358979312 で  初期化  。 
	temp という 整数 を input  / ( 2  * PI ) で  初期化  。 
	rad という 実数 を input  - ( 2  * PI  * temp ) で  初期化  。 
	plusminus という 実数 を 1.0 で  初期化  。 
	もし rad  < 0.0 ならば ここから
		rad に rad  + ( 2.0  * PI ) を  代入する  。 
	ここまで実行 
	もし rad  > PI ならば ここから
		もし rad  > 1.5  * PI ならば ここから
			rad に ( 2.0  * PI )  - rad を  代入する  。 
		ここまで実行 でなければ ここから
			plusminus に 0  - 1.0 を  代入する  。 
			rad に rad  - PI を  代入する  。 
		ここまで実行 
	ここまで実行 でなければ ここから
		もし rad  > 0.5  * PI ならば ここから
			plusminus に 0  - 1.0 を  代入する  。 
			rad に PI  - rad を  代入する  。 
		ここまで実行 
	ここまで実行 
	もし rad  < 0.25  * PI ならば ここから
		doubleRad という 実数 を rad  * rad で  初期化  。 
		結果 に 1.0  - ( doubleRad )  / 2.0  + ( doubleRad  * doubleRad )  / 24.0  - ( doubleRad  * doubleRad  * doubleRad )  / 720.0  + ( doubleRad  * doubleRad  * doubleRad  * doubleRad )  / 40320.0  - ( doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad )  / 3628800.0  + ( doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad )  / 479001600.0 を  代入する  。 
		結果 に 結果  * plusminus を  代入する  。 
	ここまで実行 でなければ ここから
		rad に ( 0.5  * PI )  - rad を  代入する  。 
		doubleRad という 実数 を rad  * rad で  初期化  。 
		結果 に rad  - ( rad  * doubleRad )  / 6.0  + ( rad  * doubleRad  * doubleRad )  / 120.0  - ( rad  * doubleRad  * doubleRad  * doubleRad )  / 5040.0  + ( rad  * doubleRad  * doubleRad  * doubleRad  * doubleRad )  / 362880.0  - ( rad  * doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad )  / 39916800.0  + ( rad  * doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad )  / 6227020800.0  - ( rad  * doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad )  / 1307674368000.0 を  代入する  。 
		結果 に 結果  * plusminus を  代入する  。 
	ここまで実行 
ここまで実行 
( rad という 実数 ) を  とり ( 結果 という 実数 ) を  返す ${"ja":"tan", "natja":"tan", "en":"tan", "naten":"tan"}$ という  関数  を  おく  。 ここから
	PI という 実数 を 3.14159265358979312 で  初期化  。 
	sqRad という 実数 を rad  * rad で  初期化  。 
	結果 に sin ( rad )  / cos ( rad ) を  代入する  。 
ここまで実行 
( a という 実数 ) を  とり ( b という 実数 ) を  返す ${"ja":"絶対値", "natja":"絶対値", "en":"abs", "naten":"abs"}$ という  関数  を  おく  。 ここから
	もし a  >= 0 ならば ここから
		b に a を  代入する  。 
	ここまで実行 でなければ ここから
		b に ( 0  - ( a ) ) を  代入する  。 
	ここまで実行 
ここまで実行 
( deg という 実数 ) を  とり ( rad という 実数 ) を  返す ${"ja":"ラジアンへ", "natja":"ラジアンへ", "en":"toRad", "naten":"toRad"}$ という  関数  を  おく  。 ここから
	PI という 実数 を 3.14159265358979312 で  初期化  。 
	rad に ( deg  / 180 )  * PI を  代入する  。 
ここまで実行 
( x という 実数 ) を  とり ( y という 実数 ) を  返す ${"ja":"平方根", "natja":"平方根", "en":"root", "naten":"root"}$ という  関数  を  おく  。 ここから
	y に 5 を  代入する  。 
	( i という 整数 を 0 で  初期化  。 ) から ( i  は 20 ) まで ( i に i  + 1 を  代入する  。 ) 繰り返し ここから
		y に 0.5  * ( y  + ( x  / y ) ) を  代入する  。 
	ここまで実行 
ここまで実行 
( ax という 実数 , ay という 実数 , bx という 実数 , byp という 実数 , cx という 実数 , cy という 実数 , dx という 実数 , dy という 実数 ) を  とり ( b という 真偽 ) を  返す ${"ja":"線分当たり判定", "natja":"線分当たり判定", "en":"checkLineCross", "naten":"checkLineCross"}$ という  関数  を  おく  。 ここから
	ta という 実数 を ( cx  - dx )  * ( ay  - cy )  + ( cy  - dy )  * ( cx  - ax ) で  初期化  。 
	tb という 実数 を ( cx  - dx )  * ( byp  - cy )  + ( cy  - dy )  * ( cx  - bx ) で  初期化  。 
	tc という 実数 を ( ax  - bx )  * ( cy  - ay )  + ( ay  - byp )  * ( ax  - cx ) で  初期化  。 
	td という 実数 を ( ax  - bx )  * ( dy  - ay )  + ( ay  - byp )  * ( ax  - dx ) で  初期化  。 
	b に ( ( tc  * td )  < 0 )  && ( ( ta  * tb )  < 0 ) を  代入する  。 
ここまで実行 
型 < T > : クラス : ${"ja":"配列", "natja":"配列", "en":"Array", "naten":"Array"}$ {
公開 : 	content という * T を  おく  。 
	size という 整数 を  おく  。 
	allocated という 整数 を  おく  。 
	関数 配列 を  おく  。 ここから
		size に 0 を  代入する  。 
		allocated に 4 を  代入する  。 
		content に メモリ確保 ( バイト数 ( content に  ある  オブジェクト )  * allocated ) を  代入する  。 
	ここまで実行 
	( index という 整数 ) を  とり ( result という T ) を  返す ${"ja":"取得", "natja":"取得", "en":"get", "naten":"get"}$ という  関数  を  おく  。 ここから
		content [ index ] を  終了  。 
	ここまで実行 
	( new という T ) を  とり ${"ja":"追加", "natja":"追加", "en":"push", "naten":"push"}$ という  関数  を  おく  。 ここから
		もし size  は allocated ならば ここから
			allocated に allocated  * 2 を  代入する  。 
			temp という * T を content で  初期化  。 
			content に メモリ確保 ( バイト数 ( content に  ある  オブジェクト )  * allocated ) を  代入する  。 
			( i という 整数 を 0 で  初期化  。 ) から ( i  は ( allocated  / 2 ) ) まで ( i に i  + 1 を  代入する  。 ) 繰り返し ここから
				content [ i ] に temp [ i ] を  代入する  。 
			ここまで実行 
		ここまで実行 
		content [ size ] に new を  代入する  。 
		size に size  + 1 を  代入する  。 
	ここまで実行 
	( a という 整数 ) を  返す ${"ja":"長さ", "natja":"長さ", "en":"length", "naten":"length"}$ という  関数  を  おく  。 ここから
		a に size を  代入する  。 
	ここまで実行 
	関数 ${"ja":"ポップ", "natja":"ポップ", "en":"pop", "naten":"pop"}$ を  おく  。 ここから
		size に size  - 1 を  代入する  。 
	ここまで実行 
	関数 : 演算子 = ( offset という * T , l という 整数 ) => ( ) ここから
		content に offset を  代入する  。 
		size に l を  代入する  。 
	ここまで実行 
	関数 : 演算子 = ( a という 配列 < T > ) => ( ) ここから
		content に メモリ確保 ( バイト数 ( content に  ある  オブジェクト )  * ( a の allocated ) ) を  代入する  。 
		size に a の size を  代入する  。 
		allocated に a の allocated を  代入する  。 
		size 回繰り返す ここから
			content [ カウンタ ] に a の content [ カウンタ ] を  代入する  。 
		ここまで実行 
	ここまで実行 
	関数 : 演算子  は ( a という 配列 < T > ) => ( b という 真偽 ) ここから
		b に 真 を  代入する  。 
		もし size  != a の size ならば ここから
			偽 を  終了  。 
		ここまで実行 
		size 回繰り返す ここから
			もし content [ カウンタ ]  != a の content [ カウンタ ] ならば ここから
				偽 を  終了  。 
			ここまで実行 
		ここまで実行 
	ここまで実行 
	関数 : 演算子  は ( offset という * T , l という 整数 ) => ( b という 真偽 ) ここから
		b に 真 を  代入する  。 
		もし size  != l ならば ここから
			偽 を  終了  。 
		ここまで実行 
		size 回繰り返す ここから
			もし content [ カウンタ ]  != offset [ カウンタ ] ならば ここから
				偽 を  終了  。 
			ここまで実行 
		ここまで実行 
	ここまで実行 
	関数 : 演算子  != ( a という 配列 < T > ) => ( b という 真偽 ) ここから
		b に 偽 を  代入する  。 
		もし size  != a の size ならば ここから
			真 を  終了  。 
		ここまで実行 
		size 回繰り返す ここから
			もし content [ カウンタ ]  != a の content [ カウンタ ] ならば ここから
				真 を  終了  。 
			ここまで実行 
		ここまで実行 
	ここまで実行 
	関数 : 演算子  != ( offset という * T , l という 整数 ) => ( b という 真偽 ) ここから
		b に 偽 を  代入する  。 
		もし size  != l ならば ここから
			真 を  終了  。 
		ここまで実行 
		size 回繰り返す ここから
			もし content [ カウンタ ]  != offset [ カウンタ ] ならば ここから
				真 を  終了  。 
			ここまで実行 
		ここまで実行 
	ここまで実行 
	関数 : 演算子  + ( a という 配列 < T > ) => ( b という 配列 < T > ) ここから
		結果 という 配列 < T > を  おく  。 
		size 回繰り返す ここから
			content [ カウンタ ] 結果 の 追加 する  。 
		ここまで実行 
		a の size 回繰り返す ここから
			a の 取得 ( カウンタ ) 結果 の 追加 する  。 
		ここまで実行 
		結果 を  終了  。 
	ここまで実行 
	関数 : 演算子  + ( offset という * T , l という 整数 ) => ( b という 配列 < T > ) ここから
		結果 という 配列 < T > を  おく  。 
		size 回繰り返す ここから
			content [ カウンタ ] 結果 の 追加 する  。 
		ここまで実行 
		l 回繰り返す ここから
			offset [ カウンタ ] 結果 の 追加 する  。 
		ここまで実行 
		結果 を  終了  。 
	ここまで実行 
	( c という 関数 : ( a という T ) => ( ) ) を  とり ${"ja":"全要素操作", "natja":"全要素操作", "en":"forEach", "naten":"forEach"}$ という  関数  を  おく  。 ここから
		size 回繰り返す ここから
			content [ カウンタ ] c する  。 
		ここまで実行 
	ここまで実行 
	( c という 関数 : ( a という T ) => ( b という T ) ) を  とり ${"ja":"全要素変更", "natja":"全要素変更", "en":"map", "naten":"map"}$ という  関数  を  おく  。 ここから
		結果 という 配列 < T > を  おく  。 
		結果 の content に メモリ確保 ( バイト数 ( content に  ある  オブジェクト )  * ( allocated ) ) を  代入する  。 
		結果 の size に size を  代入する  。 
		結果 の allocated に allocated を  代入する  。 
		size 回繰り返す ここから
			結果 の content [ カウンタ ] に c ( content [ カウンタ ] ) を  代入する  。 
		ここまで実行 
		結果 を  終了  。 
	ここまで実行 
	( s という 整数 , e という 整数 , c という 関数 : ( a という T , b という T ) => ( r という 整数 ) ) を  とり __ソート という  関数  を  おく  。 ここから
		もし s  < e ならば ここから
			loc という 整数 を e で  初期化  。 
			pivot という T を content [ loc ] で  初期化  。 
			i という 整数 を s  - 1 で  初期化  。 
			l という 整数 を e  - s で  初期化  。 
			l 回繰り返す ここから
				もし c ( content [ カウンタ  + s ] , pivot )  < 0 ならば ここから
					i に i  + 1 を  代入する  。 
					temp という T を content [ カウンタ  + s ] で  初期化  。 
					content [ カウンタ  + s ] に content [ i ] を  代入する  。 
					content [ i ] に temp を  代入する  。 
				ここまで実行 
			ここまで実行 
			temp という T を content [ loc ] で  初期化  。 
			content [ loc ] に content [ i  + 1 ] を  代入する  。 
			content [ i  + 1 ] に temp を  代入する  。 
			s , i , c __ソート する  。 
			i  + 2 , e , c __ソート する  。 
		ここまで実行 
	ここまで実行 
	( c という 関数 : ( a という T , b という T ) => ( r という 整数 ) ) を  とり ${"ja":"ソート", "natja":"ソート", "en":"sort", "naten":"sort"}$ という  関数  を  おく  。 ここから
		0 , size  - 1 , c __ソート する  。 
	ここまで実行 
	( c という 関数 : ( a という T ) => ( r という 真偽 ) ) を  とり ( b という 配列 < T > ) を  返す ${"ja":"フィルター", "natja":"フィルター", "en":"filter", "naten":"filter"}$ という  関数  を  おく  。 ここから
		結果 という 配列 < T > を  おく  。 
		size 回繰り返す ここから
			もし c ( content [ カウンタ ] ) ならば ここから
				content [ カウンタ ] 結果 の 追加 する  。 
			ここまで実行 
		ここまで実行 
		結果 を  終了  。 
	ここまで実行 
	( i という 整数 ) を  とり ( b という 配列 < T > ) を  返す ${"ja":"削除", "natja":"削除", "en":"remove", "naten":"remove"}$ という  関数  を  おく  。 ここから
		結果 という 配列 < T > を  おく  。 
		size 回繰り返す ここから
			もし カウンタ  != i ならば ここから
				content [ カウンタ ] 結果 の 追加 する  。 
			ここまで実行 
		ここまで実行 
		結果 を  終了  。 
	ここまで実行 
	( i という 整数 , r という 整数 ) を  とり ( b という 配列 < T > ) を  返す ${"ja":"範囲削除", "natja":"範囲削除", "en":"removeRange", "naten":"removeRange"}$ という  関数  を  おく  。 ここから
		結果 という 配列 < T > を  おく  。 
		size 回繰り返す ここから
			もし ( カウンタ  < i )  || ( カウンタ  >= ( i  + r ) ) ならば ここから
				content [ カウンタ ] 結果 の 追加 する  。 
			ここまで実行 
		ここまで実行 
		結果 を  終了  。 
	ここまで実行 
	( s という 整数 , e という 整数 ) を  とり ( b という 配列 < T > ) を  返す ${"ja":"部分列", "natja":"部分列", "en":"subseq", "naten":"subseq"}$ という  関数  を  おく  。 ここから
		結果 という 配列 < T > を  おく  。 
		もし s  >= e ならば ここから
			結果 を  終了  。 
		ここまで実行 
		size 回繰り返す ここから
			もし ( s  <= カウンタ )  && ( カウンタ  < e ) ならば ここから
				content [ カウンタ ] 結果 の 追加 する  。 
			ここまで実行 
		ここまで実行 
		結果 を  終了  。 
	ここまで実行 
	( s という 整数 , l という 整数 ) を  とり ( b という 配列 < T > ) を  返す ${"ja":"範囲部分列", "natja":"範囲部分列", "en":"subseqRange", "naten":"subseqRange"}$ という  関数  を  おく  。 ここから
		結果 という 配列 < T > を  おく  。 
		もし s  >= size ならば ここから
			結果 を  終了  。 
		ここまで実行 
		size 回繰り返す ここから
			もし ( s  <= カウンタ )  && ( カウンタ  < ( s  + l ) ) ならば ここから
				content [ カウンタ ] 結果 の 追加 する  。 
			ここまで実行 
		ここまで実行 
		結果 を  終了  。 
	ここまで実行 
	( a という T , b という T ) を  とり ${"ja":"置換", "natja":"置換", "en":"replace", "naten":"replace"}$ という  関数  を  おく  。 ここから
		size 回繰り返す ここから
			もし content [ カウンタ ]  は a ならば ここから
				content [ カウンタ ] に b を  代入する  。 
			ここまで実行 
		ここまで実行 
	ここまで実行 
	( s という 整数 , l という 整数 , a という T ) を  とり ${"ja":"範囲置換", "natja":"範囲置換", "en":"replaceRange", "naten":"replaceRange"}$ という  関数  を  おく  。 ここから
		size 回繰り返す ここから
			もし ( s  <= カウンタ )  && ( カウンタ  < ( s  + l ) ) ならば ここから
				content [ カウンタ ] に a を  代入する  。 
			ここまで実行 
		ここまで実行 
	ここまで実行 
	( s という 整数 , l という 整数 , a という 配列 < T > ) を  とり ${"ja":"範囲置換", "natja":"範囲置換", "en":"replaceRange", "naten":"replaceRange"}$ という  関数  を  おく  。 ここから
		size 回繰り返す ここから
			もし ( s  <= カウンタ )  && ( カウンタ  < ( s  + l ) ) ならば ここから
				content [ カウンタ ] に a の content [ カウンタ  - s ] を  代入する  。 
			ここまで実行 
		ここまで実行 
	ここまで実行 
	( b という T ) を  とり ( i という 整数 ) を  返す ${"ja":"探索", "natja":"探索", "en":"find", "naten":"find"}$ という  関数  を  おく  。 ここから
		size 回繰り返す ここから
			もし content [ カウンタ ]  は b ならば ここから
				カウンタ を  終了  。 
			ここまで実行 
		ここまで実行 
		size を  終了  。 
	ここまで実行 
} 
( a という 整数 ) を  とり ( b という 文字 ) を  返す ${"ja":"整数文字変換", "natja":"整数文字変換", "en":"intToChar", "naten":"intToChar"}$ という  関数  を  おく  。 ここから
	a に a  % ( 10 ) を  代入する  。 
	もし a  は 0 ならば ここから
		b に '0'を  代入する  。 
	ここまで実行 でなければ  もし a  は 1 ならば ここから
		b に '1'を  代入する  。 
	ここまで実行 
	でなければ  もし a  は 2 ならば ここから
		b に '2'を  代入する  。 
	ここまで実行 でなければ  もし a  は 3 ならば ここから
		b に '3'を  代入する  。 
	ここまで実行 でなければ  もし a  は 4 ならば ここから
		b に '4'を  代入する  。 
	ここまで実行 でなければ  もし a  は 5 ならば ここから
		b に '5'を  代入する  。 
	ここまで実行 でなければ  もし a  は 6 ならば ここから
		b に '6'を  代入する  。 
	ここまで実行 でなければ  もし a  は 7 ならば ここから
		b に '7'を  代入する  。 
	ここまで実行 でなければ  もし a  は 8 ならば ここから
		b に '8'を  代入する  。 
	ここまで実行 でなければ  もし a  は 9 ならば ここから
		b に '9'を  代入する  。 
	ここまで実行 
ここまで実行 
クラス : ${"ja":"文字列", "natja":"文字列", "en":"string", "naten":"string"}$ {
公開 : 	content という * 文字 を  おく  。 
	長さ という 整数 を  おく  。 
	( offset という * 文字 , l という 整数 ) を  とり 文字列 という  関数  を  おく  。 ここから
		content に offset を  代入する  。 
		長さ に l を  代入する  。 
	ここまで実行 
	関数 文字列 を  おく  。 ここから
		content に メモリ確保 ( 0 ) を  代入する  。 
		長さ に 0 を  代入する  。 
	ここまで実行 
	関数 : 演算子 = ( offset という * 文字 , l という 整数 ) => ( ) ここから
		content に offset を  代入する  。 
		長さ に l を  代入する  。 
	ここまで実行 
	関数 : 演算子 = ( a という 文字列 ) => ( ) ここから
		content に メモリ確保 ( バイト数 ( content に  ある  オブジェクト )  * ( a の 長さ ) ) を  代入する  。 
		長さ に a の 長さ を  代入する  。 
		長さ 回繰り返す ここから
			content [ カウンタ ] に a の content [ カウンタ ] を  代入する  。 
		ここまで実行 
	ここまで実行 
	関数 : 演算子 = ( a という 文字 ) => ( ) ここから
		content に メモリ確保 ( バイト数 ( content に  ある  オブジェクト ) ) を  代入する  。 
		長さ に 1 を  代入する  。 
		content [ 0 ] に a を  代入する  。 
	ここまで実行 
	関数 : 演算子  + ( a という 文字 ) => ( b という 文字列 ) ここから
		b の content に メモリ確保 ( バイト数 ( content に  ある  オブジェクト )  * ( 長さ  + 1 ) ) を  代入する  。 
		長さ 回繰り返す ここから
			b の content [ カウンタ ] に content [ カウンタ ] を  代入する  。 
		ここまで実行 
		b の content [ 長さ ] に a を  代入する  。 
		b の 長さ に 長さ  + 1 を  代入する  。 
	ここまで実行 
	関数 : 演算子  + ( offset という * 文字 , l という 整数 ) => ( b という 文字列 ) ここから
		b の content に メモリ確保 ( バイト数 ( content に  ある  オブジェクト )  * ( 長さ  + l ) ) を  代入する  。 
		長さ 回繰り返す ここから
			b の content [ カウンタ ] に content [ カウンタ ] を  代入する  。 
		ここまで実行 
		l 回繰り返す ここから
			b の content [ 長さ  + カウンタ ] に offset [ カウンタ ] を  代入する  。 
		ここまで実行 
		b の 長さ に 長さ  + l を  代入する  。 
	ここまで実行 
	関数 : 演算子  + ( a という 文字列 ) => ( b という 文字列 ) ここから
		b の content に メモリ確保 ( バイト数 ( content に  ある  オブジェクト )  * ( 長さ  + a の 長さ ) ) を  代入する  。 
		長さ 回繰り返す ここから
			b の content [ カウンタ ] に content [ カウンタ ] を  代入する  。 
		ここまで実行 
		a の 長さ 回繰り返す ここから
			b の content [ 長さ  + カウンタ ] に a の content [ カウンタ ] を  代入する  。 
		ここまで実行 
		b の 長さ に 長さ  + a の 長さ を  代入する  。 
	ここまで実行 
	関数 : 演算子  + ( a という 整数 ) => ( b という 文字列 ) ここから
		str という 文字列 を 整数文字変換 ( a ) で  初期化  。 
		もし 絶対値 ( a )  >= 10 ならば ここから
			a  <= 10 まで ここから
				a に a  / ( 10 ) を  代入する  。 
				temp という 文字列 を 整数文字変換 ( a ) で  初期化  。 
				str に temp  + str を  代入する  。 
			ここまで実行 
		ここまで実行 
		b の content に メモリ確保 ( バイト数 ( content に  ある  オブジェクト )  * 長さ ) を  代入する  。 
		長さ 回繰り返す ここから
			b の content [ カウンタ ] に content [ カウンタ ] を  代入する  。 
		ここまで実行 
		b の 長さ に 長さ を  代入する  。 
		b に b  + str を  代入する  。 
	ここまで実行 
	関数 : 演算子  + ( a という 整数32 ) => ( b という 文字列 ) ここから
		str という 文字列 を 整数文字変換 ( a ) で  初期化  。 
		a  <= 10 まで ここから
			a に a  / ( 10 ) を  代入する  。 
			temp という 文字列 を 整数文字変換 ( a ) で  初期化  。 
			str に temp  + str を  代入する  。 
		ここまで実行 
		b の content に メモリ確保 ( バイト数 ( content に  ある  オブジェクト )  * 長さ ) を  代入する  。 
		長さ 回繰り返す ここから
			b の content [ カウンタ ] に content [ カウンタ ] を  代入する  。 
		ここまで実行 
		b の 長さ に 長さ を  代入する  。 
		b に b  + str を  代入する  。 
	ここまで実行 
	関数 : 演算子  + ( a という 実数 ) => ( b という 文字列 ) ここから
		inta という 整数 を a で  初期化  。 
		reala という 実数 を a  - inta で  初期化  。 
		str という 文字列 を ""で  初期化  。 
		str に str  + inta を  代入する  。 
		str に str  + "."を  代入する  。 
		6 回繰り返す ここから
			reala に reala  * ( 10.0 ) を  代入する  。 
			str に str  + 整数文字変換 ( reala ) を  代入する  。 
		ここまで実行 
		b の content に メモリ確保 ( バイト数 ( content に  ある  オブジェクト )  * 長さ ) を  代入する  。 
		長さ 回繰り返す ここから
			b の content [ カウンタ ] に content [ カウンタ ] を  代入する  。 
		ここまで実行 
		b の 長さ に 長さ を  代入する  。 
		b に b  + str を  代入する  。 
	ここまで実行 
	関数 : 演算子  は ( a という 文字列 ) => ( b という 真偽 ) ここから
		b に 真 を  代入する  。 
		もし 長さ  != a の 長さ ならば ここから
			偽 を  終了  。 
		ここまで実行 
		長さ 回繰り返す ここから
			もし content [ カウンタ ]  != a の content [ カウンタ ] ならば ここから
				偽 を  終了  。 
			ここまで実行 
		ここまで実行 
	ここまで実行 
	関数 : 演算子  は ( offset という * 文字 , l という 整数 ) => ( b という 真偽 ) ここから
		b に 真 を  代入する  。 
		もし 長さ  != l ならば ここから
			偽 を  終了  。 
		ここまで実行 
		長さ 回繰り返す ここから
			もし content [ カウンタ ]  != offset [ カウンタ ] ならば ここから
				偽 を  終了  。 
			ここまで実行 
		ここまで実行 
	ここまで実行 
	関数 : 演算子  != ( a という 文字列 ) => ( b という 真偽 ) ここから
		b に 偽 を  代入する  。 
		もし 長さ  != a の 長さ ならば ここから
			真 を  終了  。 
		ここまで実行 
		長さ 回繰り返す ここから
			もし content [ カウンタ ]  != a の content [ カウンタ ] ならば ここから
				真 を  終了  。 
			ここまで実行 
		ここまで実行 
	ここまで実行 
	関数 : 演算子  != ( offset という * 文字 , l という 整数 ) => ( b という 真偽 ) ここから
		b に 偽 を  代入する  。 
		もし 長さ  != l ならば ここから
			真 を  終了  。 
		ここまで実行 
		長さ 回繰り返す ここから
			もし content [ カウンタ ]  != offset [ カウンタ ] ならば ここから
				真 を  終了  。 
			ここまで実行 
		ここまで実行 
	ここまで実行 
	( s という 整数 , e という 整数 ) を  とり ( b という 文字列 ) を  返す ${"ja":"切り取り", "natja":"切り取り", "en":"substr", "naten":"substr"}$ という  関数  を  おく  。 ここから
		もし s  > 長さ ならば ここから
			s に 長さ を  代入する  。 
		ここまで実行 
		もし e  > 長さ ならば ここから
			e に 長さ を  代入する  。 
		ここまで実行 
		b の content に メモリ確保 ( バイト数 ( content に  ある  オブジェクト )  * ( e  - s ) ) を  代入する  。 
		b の 長さ に e  - s を  代入する  。 
		( i という 整数 を s で  初期化  。 ) から ( i  は e ) まで ( i に i  + 1 を  代入する  。 ) 繰り返し ここから
			b の content [ i  - s ] に content [ i ] を  代入する  。 
		ここまで実行 
	ここまで実行 
	( s という 整数 , l という 整数 ) を  とり ( b という 文字列 ) を  返す ${"ja":"範囲切り取り", "natja":"範囲切り取り", "en":"substrRange", "naten":"substrRange"}$ という  関数  を  おく  。 ここから
		もし s  > 長さ ならば ここから
			s に 長さ を  代入する  。 
		ここまで実行 
		もし s  + l  > 長さ ならば ここから
			l に 長さ  - s を  代入する  。 
		ここまで実行 
		b の content に メモリ確保 ( バイト数 ( content に  ある  オブジェクト )  * l ) を  代入する  。 
		b の 長さ に l を  代入する  。 
		( i という 整数 を s で  初期化  。 ) から ( i  は ( s  + l ) ) まで ( i に i  + 1 を  代入する  。 ) 繰り返し ここから
			b の content [ i  - s ] に content [ i ] を  代入する  。 
		ここまで実行 
	ここまで実行 
	( a という 文字 ) を  とり ( b という 配列 < 文字列 > ) を  返す ${"ja":"分割", "natja":"分割", "en":"separate", "naten":"separate"}$ という  関数  を  おく  。 ここから
		結果 という 配列 < 文字列 > を  おく  。 
		開始 という 整数 を 0 で  初期化  。 
		長さ 回繰り返す ここから
			もし content [ カウンタ ]  は a ならば ここから
				temp という 文字列 を 切り取り ( 開始 , カウンタ ) で  初期化  。 
				temp 結果 の 追加 する  。 
				開始 に カウンタ  + 1 を  代入する  。 
			ここまで実行 
		ここまで実行 
		切り取り ( 開始 , 長さ ) 結果 の 追加 する  。 
		結果 を  終了  。 
	ここまで実行 
	( a という 整数 ) を  返す ${"ja":"整数変換", "natja":"整数変換", "en":"toInteger", "naten":"toInteger"}$ という  関数  を  おく  。 ここから
		a に 0 を  代入する  。 
		長さ 回繰り返す ここから
			c という 文字 を content [ カウンタ ] で  初期化  。 
			もし c  != '-'ならば ここから
				a に a  * ( 10 ) を  代入する  。 
			ここまで実行 
			もし c  は '1'ならば ここから
				a に a  + 1 を  代入する  。 
			ここまで実行 
			もし c  は '2'ならば ここから
				a に a  + 2 を  代入する  。 
			ここまで実行 
			もし c  は '3'ならば ここから
				a に a  + 3 を  代入する  。 
			ここまで実行 
			もし c  は '4'ならば ここから
				a に a  + 4 を  代入する  。 
			ここまで実行 
			もし c  は '5'ならば ここから
				a に a  + 5 を  代入する  。 
			ここまで実行 
			もし c  は '6'ならば ここから
				a に a  + 6 を  代入する  。 
			ここまで実行 
			もし c  は '7'ならば ここから
				a に a  + 7 を  代入する  。 
			ここまで実行 
			もし c  は '8'ならば ここから
				a に a  + 8 を  代入する  。 
			ここまで実行 
			もし c  は '9'ならば ここから
				a に a  + 9 を  代入する  。 
			ここまで実行 
		ここまで実行 
		もし content [ 0 ]  は '-'ならば ここから
			a に a  * ( ( 0  - ( 1.0 ) ) ) を  代入する  。 
		ここまで実行 
	ここまで実行 
	( a という 実数 ) を  返す ${"ja":"実数変換", "natja":"実数変換", "en":"toDouble", "naten":"toDouble"}$ という  関数  を  おく  。 ここから
		a に 0 を  代入する  。 
		もし content [ 0 ]  は '-'ならば ここから
			str という 文字列 を 範囲切り取り ( 1 , 長さ ) で  初期化  。 
			a に str の 実数変換 ( )  * ( 0  - ( 1.0 ) ) を  代入する  。 
		ここまで実行 でなければ ここから
			b という 配列 < 文字列 > を 分割 ( '.') で  初期化  。 
			もし b の 長さ ( )  != 2 ならば ここから
				0.0 を  終了  。 
			ここまで実行 
			a に a  + b の content [ 0 ] の 整数変換 ( ) を  代入する  。 
			temp という 実数 を b の content [ 1 ] の 整数変換 ( ) で  初期化  。 
			b の content [ 1 ] の 長さ 回繰り返す ここから
				temp に temp  * ( 0.100000000000000006 ) を  代入する  。 
			ここまで実行 
			a に a  + temp を  代入する  。 
		ここまで実行 
	ここまで実行 
	( a という 文字列 , b という 文字列 ) を  とり ( c という 文字列 ) を  返す ${"ja":"置換", "natja":"置換", "en":"replace", "naten":"replace"}$ という  関数  を  おく  。 ここから
		結果 という 文字列 を  おく  。 
		開始 という 整数 を 0 で  初期化  。 
		長さ 回繰り返す ここから
			もし content [ カウンタ ]  は a の content [ 0 ] ならば ここから
				もし 範囲切り取り ( カウンタ , a の 長さ )  は a ならば ここから
					結果 に 結果  + 切り取り ( 開始 , カウンタ ) を  代入する  。 
					結果 に 結果  + b を  代入する  。 
					カウンタ に カウンタ  + a の 長さ を  代入する  。 
					開始 に カウンタ を  代入する  。 
				ここまで実行 
			ここまで実行 
		ここまで実行 
		結果 に 結果  + 切り取り ( 開始 , 長さ ) を  代入する  。 
		結果 を  終了  。 
	ここまで実行 
} 
( a という 文字列 ) を  とり ${"ja":"文字列表示", "natja":"文字列表示", "en":"printString", "naten":"printString"}$ という  関数  を  おく  。 ここから
	a の content , a の 長さ _文字列表示 する  。 
ここまで実行 
( x という 実数 ) を  とり ${"ja":"表示", "natja":"表示", "en":"print", "naten":"print"}$ という  関数  を  おく  。 ここから
	x 実数表示 する  。 
ここまで実行 
( n という 整数 ) を  とり ${"ja":"表示", "natja":"表示", "en":"print", "naten":"print"}$ という  関数  を  おく  。 ここから
	n 実数表示 する  。 
ここまで実行 
( n という 整数32 ) を  とり ${"ja":"表示", "natja":"表示", "en":"print", "naten":"print"}$ という  関数  を  おく  。 ここから
	n 実数表示 する  。 
ここまで実行 
( a という 文字列 ) を  とり ${"ja":"表示", "natja":"表示", "en":"print", "naten":"print"}$ という  関数  を  おく  。 ここから
	a 文字列表示 する  。 
ここまで実行 
( i という 整数32 , a という 文字列 ) を  とり ( loc という 整数32 ) を  返す ${"ja":"glGetUniformLocation", "natja":"glGetUniformLocation", "en":"glGetUniformLocation", "naten":"glGetUniformLocation"}$ という  関数  を  おく  。 ここから
	loc に _glGetUniformLocation ( i , a の content , a の 長さ ) を  代入する  。 
ここまで実行 
( a という 文字列 ) を  とり ( b という 文字列 ) を  返す ${"ja":"サンプルモデルロード", "natja":"サンプルモデルロード", "en":"loadSampleModel", "naten":"loadSampleModel"}$ という  関数  を  おく  。 ここから
	data という * 文字列 を ""で  初期化  。 
	もし a  は "teapot"ならば ここから
		data に getTeapot ( ) を  代入する  。 
	ここまで実行 
	もし a  は "mountains"ならば ここから
		data に getMountains ( ) を  代入する  。 
	ここまで実行 
	もし a  は "teddybear"ならば ここから
		data に getTeddybear ( ) を  代入する  。 
	ここまで実行 
	もし a  は "cow"ならば ここから
		data に getCow ( ) を  代入する  。 
	ここまで実行 
	もし a  は "fox"ならば ここから
		data に getFox ( ) を  代入する  。 
	ここまで実行 
	もし a  は "robot"ならば ここから
		data に getRobot ( ) を  代入する  。 
	ここまで実行 
	b に data に  ある  オブジェクト を  代入する  。 
ここまで実行 
クラス : ${"ja":"ベクトル3D", "natja":"ベクトル3D", "en":"Vector3D", "naten":"Vector3D"}$ {
公開 : 	x という 実数 を  おく  。 
	y という 実数 を  おく  。 
	z という 実数 を  おく  。 
	( a という 実数 , b という 実数 , c という 実数 ) を  とり ベクトル3D という  関数  を  おく  。 ここから
		x に a を  代入する  。 
		y に b を  代入する  。 
		z に c を  代入する  。 
	ここまで実行 
	( l という 実数 ) を  返す ${"ja":"長さ", "natja":"長さ", "en":"length", "naten":"length"}$ という  関数  を  おく  。 ここから
		l に 平方根 ( x  * x  + y  * y  + z  * z ) を  代入する  。 
	ここまで実行 
	関数 ${"ja":"正規化", "natja":"正規化", "en":"normalize", "naten":"normalize"}$ を  おく  。 ここから
		l という 実数 を 平方根 ( ( x  * x )  + ( y  * y )  + ( z  * z ) ) で  初期化  。 
		x に x  / l を  代入する  。 
		y に y  / l を  代入する  。 
		z に z  / l を  代入する  。 
	ここまで実行 
	関数 : 演算子  + ( a という ベクトル3D ) => ( b という ベクトル3D ) ここから
		b の x に a の x  + x を  代入する  。 
		b の y に a の y  + y を  代入する  。 
		b の z に a の z  + z を  代入する  。 
	ここまで実行 
	関数 : 演算子  - ( a という ベクトル3D ) => ( b という ベクトル3D ) ここから
		b の x に x  - a の x を  代入する  。 
		b の y に y  - a の y を  代入する  。 
		b の z に z  - a の z を  代入する  。 
	ここまで実行 
	関数 : 演算子  * ( k という 実数 ) => ( b という ベクトル3D ) ここから
		b の x に x  * k を  代入する  。 
		b の y に y  * k を  代入する  。 
		b の z に z  * k を  代入する  。 
	ここまで実行 
	関数 : 演算子  * ( a という ベクトル3D ) => ( b という ベクトル3D ) ここから
		b の x に y  * a の z  - z  * a の y を  代入する  。 
		b の y に z  * a の x  - x  * a の z を  代入する  。 
		b の z に x  * a の y  - y  * a の x を  代入する  。 
	ここまで実行 
	関数 : 演算子  / ( k という 実数 ) => ( b という ベクトル3D ) ここから
		b の x に x  / k を  代入する  。 
		b の y に y  / k を  代入する  。 
		b の z に z  / k を  代入する  。 
	ここまで実行 
	関数 : 演算子  は ( a という ベクトル3D ) => ( b という 真偽 ) ここから
		b に ( ( a の x  は x )  && ( a の y  は y )  && ( a の z  は z ) ) を  代入する  。 
	ここまで実行 
	関数 : 演算子  != ( a という ベクトル3D ) => ( b という 真偽 ) ここから
		b に ( ( a の x  != x )  || ( a の y  != y )  || ( a の z  != z ) ) を  代入する  。 
	ここまで実行 
} 
( a という ベクトル3D , b という ベクトル3D ) を  とり ( result という ベクトル3D ) を  返す ${"ja":"ベクトル3Dの和", "natja":"ベクトル3Dの和", "en":"addVector3D", "naten":"addVector3D"}$ という  関数  を  おく  。 ここから
	result の x に a の x  + b の x を  代入する  。 
	result の y に a の y  + b の y を  代入する  。 
	result の z に a の z  + b の z を  代入する  。 
ここまで実行 
( a という ベクトル3D , b という ベクトル3D ) を  とり ( result という ベクトル3D ) を  返す ${"ja":"ベクトル3Dの差", "natja":"ベクトル3Dの差", "en":"subVector3D", "naten":"subVector3D"}$ という  関数  を  おく  。 ここから
	result の x に a の x  - b の x を  代入する  。 
	result の y に a の y  - b の y を  代入する  。 
	result の z に a の z  - b の z を  代入する  。 
ここまで実行 
( a という ベクトル3D , b という ベクトル3D ) を  とり ( x という 実数 ) を  返す ${"ja":"ベクトル3Dの内積", "natja":"ベクトル3Dの内積", "en":"dotVector3D", "naten":"dotVector3D"}$ という  関数  を  おく  。 ここから
	x に ( a の x  * b の x )  + ( a の y  * b の y )  + ( a の z  * b の z ) を  代入する  。 
ここまで実行 
( a という ベクトル3D , b という ベクトル3D ) を  とり ( result という ベクトル3D ) を  返す ${"ja":"ベクトル3Dの外積", "natja":"ベクトル3Dの外積", "en":"crossVector3D", "naten":"crossVector3D"}$ という  関数  を  おく  。 ここから
	result の x に ( a の y  * b の z )  - ( a の z  * b の y ) を  代入する  。 
	result の y に ( a の z  * b の x )  - ( a の x  * b の z ) を  代入する  。 
	result の z に ( a の x  * b の y )  - ( a の y  * b の x ) を  代入する  。 
ここまで実行 
( a という ベクトル3D , x という 実数 ) を  とり ( result という ベクトル3D ) を  返す ${"ja":"ベクトル3D拡大", "natja":"ベクトル3D拡大", "en":"extendVector3D", "naten":"extendVector3D"}$ という  関数  を  おく  。 ここから
	result の x に a の x  * x を  代入する  。 
	result の y に a の y  * x を  代入する  。 
	result の z に a の z  * x を  代入する  。 
ここまで実行 
( a という ベクトル3D , x という 実数 ) を  とり ( result という ベクトル3D ) を  返す ${"ja":"ベクトル3D縮小", "natja":"ベクトル3D縮小", "en":"divVector3D", "naten":"divVector3D"}$ という  関数  を  おく  。 ここから
	もし x  は 0.0 ならば ここから
		10000000 表示 する  。 
	ここまで実行 
	result の x に a の x  / x を  代入する  。 
	result の y に a の y  / x を  代入する  。 
	result の z に a の z  / x を  代入する  。 
ここまで実行 
クラス : ${"ja":"行列4x4", "natja":"行列4x4", "en":"Matrix4x4", "naten":"Matrix4x4"}$ {
公開 : 	matrix [ 16 ] という 実数 を  おく  。 
	関数 行列4x4 を  おく  。 ここから
		matrix に [ 1.0 , 0.0 , 0.0 , 0.0 , 0.0 , 1.0 , 0.0 , 0.0 , 0.0 , 0.0 , 1.0 , 0.0 , 0.0 , 0.0 , 0.0 , 1.0 ] を  代入する  。 
	ここまで実行 
	関数 ${"ja":"単位化", "natja":"単位化", "en":"identity", "naten":"identity"}$ を  おく  。 ここから
		matrix に [ 1.0 , 0.0 , 0.0 , 0.0 , 0.0 , 1.0 , 0.0 , 0.0 , 0.0 , 0.0 , 1.0 , 0.0 , 0.0 , 0.0 , 0.0 , 1.0 ] を  代入する  。 
	ここまで実行 
	( offset という ベクトル3D ) を  とり ${"ja":"移動", "natja":"移動", "en":"translate", "naten":"translate"}$ という  関数  を  おく  。 ここから
		mat12 という 実数 を matrix [ 12 ] で  初期化  。 
		mat13 という 実数 を matrix [ 13 ] で  初期化  。 
		mat14 という 実数 を matrix [ 14 ] で  初期化  。 
		mat15 という 実数 を matrix [ 15 ] で  初期化  。 
		matrix [ 12 ] に matrix [ 0 ]  * offset の x  + matrix [ 4 ]  * offset の y  + matrix [ 8 ]  * offset の z  + mat12 を  代入する  。 
		matrix [ 13 ] に matrix [ 1 ]  * offset の x  + matrix [ 5 ]  * offset の y  + matrix [ 9 ]  * offset の z  + mat13 を  代入する  。 
		matrix [ 14 ] に matrix [ 2 ]  * offset の x  + matrix [ 6 ]  * offset の y  + matrix [ 10 ]  * offset の z  + mat13 を  代入する  。 
		matrix [ 15 ] に matrix [ 3 ]  * offset の x  + matrix [ 7 ]  * offset の y  + matrix [ 11 ]  * offset の z  + mat15 を  代入する  。 
	ここまで実行 
	( axis という ベクトル3D , theta という 実数 ) を  とり ${"ja":"回転", "natja":"回転", "en":"rotate", "naten":"rotate"}$ という  関数  を  おく  。 ここから
		axis の 正規化 する  。 
		s という 実数 を sin ( theta ) で  初期化  。 
		c という 実数 を cos ( theta ) で  初期化  。 
		t という 実数 を 1.0  - c で  初期化  。 
		a00 という 実数 を matrix [ 0 ] で  初期化  。 
		a01 という 実数 を matrix [ 1 ] で  初期化  。 
		a02 という 実数 を matrix [ 2 ] で  初期化  。 
		a03 という 実数 を matrix [ 3 ] で  初期化  。 
		a10 という 実数 を matrix [ 4 ] で  初期化  。 
		a11 という 実数 を matrix [ 5 ] で  初期化  。 
		a12 という 実数 を matrix [ 6 ] で  初期化  。 
		a13 という 実数 を matrix [ 7 ] で  初期化  。 
		a20 という 実数 を matrix [ 8 ] で  初期化  。 
		a21 という 実数 を matrix [ 9 ] で  初期化  。 
		a22 という 実数 を matrix [ 10 ] で  初期化  。 
		a23 という 実数 を matrix [ 11 ] で  初期化  。 
		b00 という 実数 を axis の x  * axis の x  * t  + c で  初期化  。 
		b01 という 実数 を axis の y  * axis の x  * t  + axis の z  * s で  初期化  。 
		b02 という 実数 を axis の z  * axis の x  * t  - axis の y  * s で  初期化  。 
		b10 という 実数 を axis の x  * axis の y  * t  - axis の z  * s で  初期化  。 
		b11 という 実数 を axis の y  * axis の y  * t  + c で  初期化  。 
		b12 という 実数 を axis の z  * axis の y  * t  + axis の x  * s で  初期化  。 
		b20 という 実数 を axis の x  * axis の z  * t  + axis の y  * s で  初期化  。 
		b21 という 実数 を axis の y  * axis の z  * t  - axis の x  * s で  初期化  。 
		b22 という 実数 を axis の z  * axis の z  * t  + c で  初期化  。 
		matrix [ 0 ] に a00  * b00  + a10  * b01  + a20  * b02 を  代入する  。 
		matrix [ 1 ] に a01  * b00  + a11  * b01  + a21  * b02 を  代入する  。 
		matrix [ 2 ] に a02  * b00  + a12  * b01  + a22  * b02 を  代入する  。 
		matrix [ 3 ] に a03  * b00  + a13  * b01  + a23  * b02 を  代入する  。 
		matrix [ 4 ] に a00  * b10  + a10  * b11  + a20  * b12 を  代入する  。 
		matrix [ 5 ] に a01  * b10  + a11  * b11  + a21  * b12 を  代入する  。 
		matrix [ 6 ] に a02  * b10  + a12  * b11  + a22  * b12 を  代入する  。 
		matrix [ 7 ] に a03  * b10  + a13  * b11  + a23  * b12 を  代入する  。 
		matrix [ 8 ] に a00  * b20  + a10  * b21  + a20  * b22 を  代入する  。 
		matrix [ 9 ] に a01  * b20  + a11  * b21  + a21  * b22 を  代入する  。 
		matrix [ 10 ] に a02  * b20  + a12  * b21  + a22  * b22 を  代入する  。 
		matrix [ 11 ] に a03  * b20  + a13  * b21  + a23  * b22 を  代入する  。 
	ここまで実行 
	( x という 実数 , y という 実数 , z という 実数 ) を  とり ${"ja":"拡大縮小", "natja":"拡大縮小", "en":"scale", "naten":"scale"}$ という  関数  を  おく  。 ここから
		matrix [ 0 ] に matrix [ 0 ]  * x を  代入する  。 
		matrix [ 1 ] に matrix [ 1 ]  * x を  代入する  。 
		matrix [ 2 ] に matrix [ 2 ]  * x を  代入する  。 
		matrix [ 3 ] に matrix [ 3 ]  * x を  代入する  。 
		matrix [ 4 ] に matrix [ 4 ]  * y を  代入する  。 
		matrix [ 5 ] に matrix [ 5 ]  * y を  代入する  。 
		matrix [ 6 ] に matrix [ 6 ]  * y を  代入する  。 
		matrix [ 7 ] に matrix [ 7 ]  * y を  代入する  。 
		matrix [ 8 ] に matrix [ 8 ]  * z を  代入する  。 
		matrix [ 9 ] に matrix [ 9 ]  * z を  代入する  。 
		matrix [ 10 ] に matrix [ 10 ]  * z を  代入する  。 
		matrix [ 11 ] に matrix [ 11 ]  * z を  代入する  。 
	ここまで実行 
	関数 : 演算子  * ( a という 行列4x4 ) => ( b という 行列4x4 ) ここから
		b の matrix [ 0 ] に a の matrix [ 0 ]  * matrix [ 0 ]  + a の matrix [ 1 ]  * matrix [ 4 ]  + a の matrix [ 2 ]  * matrix [ 8 ]  + a の matrix [ 3 ]  * matrix [ 12 ] を  代入する  。 
		b の matrix [ 1 ] に a の matrix [ 0 ]  * matrix [ 1 ]  + a の matrix [ 1 ]  * matrix [ 5 ]  + a の matrix [ 2 ]  * matrix [ 9 ]  + a の matrix [ 3 ]  * matrix [ 13 ] を  代入する  。 
		b の matrix [ 2 ] に a の matrix [ 0 ]  * matrix [ 2 ]  + a の matrix [ 1 ]  * matrix [ 6 ]  + a の matrix [ 2 ]  * matrix [ 10 ]  + a の matrix [ 3 ]  * matrix [ 14 ] を  代入する  。 
		b の matrix [ 3 ] に a の matrix [ 0 ]  * matrix [ 3 ]  + a の matrix [ 1 ]  * matrix [ 7 ]  + a の matrix [ 2 ]  * matrix [ 11 ]  + a の matrix [ 3 ]  * matrix [ 15 ] を  代入する  。 
		b の matrix [ 4 ] に a の matrix [ 4 ]  * matrix [ 0 ]  + a の matrix [ 5 ]  * matrix [ 4 ]  + a の matrix [ 6 ]  * matrix [ 8 ]  + a の matrix [ 7 ]  * matrix [ 12 ] を  代入する  。 
		b の matrix [ 5 ] に a の matrix [ 4 ]  * matrix [ 1 ]  + a の matrix [ 5 ]  * matrix [ 5 ]  + a の matrix [ 6 ]  * matrix [ 9 ]  + a の matrix [ 7 ]  * matrix [ 13 ] を  代入する  。 
		b の matrix [ 6 ] に a の matrix [ 4 ]  * matrix [ 2 ]  + a の matrix [ 5 ]  * matrix [ 6 ]  + a の matrix [ 6 ]  * matrix [ 10 ]  + a の matrix [ 7 ]  * matrix [ 14 ] を  代入する  。 
		b の matrix [ 7 ] に a の matrix [ 4 ]  * matrix [ 3 ]  + a の matrix [ 5 ]  * matrix [ 7 ]  + a の matrix [ 6 ]  * matrix [ 11 ]  + a の matrix [ 7 ]  * matrix [ 15 ] を  代入する  。 
		b の matrix [ 8 ] に a の matrix [ 8 ]  * matrix [ 0 ]  + a の matrix [ 9 ]  * matrix [ 4 ]  + a の matrix [ 10 ]  * matrix [ 8 ]  + a の matrix [ 11 ]  * matrix [ 12 ] を  代入する  。 
		b の matrix [ 9 ] に a の matrix [ 8 ]  * matrix [ 1 ]  + a の matrix [ 9 ]  * matrix [ 5 ]  + a の matrix [ 10 ]  * matrix [ 9 ]  + a の matrix [ 11 ]  * matrix [ 13 ] を  代入する  。 
		b の matrix [ 10 ] に a の matrix [ 8 ]  * matrix [ 2 ]  + a の matrix [ 9 ]  * matrix [ 6 ]  + a の matrix [ 10 ]  * matrix [ 10 ]  + a の matrix [ 11 ]  * matrix [ 14 ] を  代入する  。 
		b の matrix [ 11 ] に a の matrix [ 8 ]  * matrix [ 3 ]  + a の matrix [ 9 ]  * matrix [ 7 ]  + a の matrix [ 10 ]  * matrix [ 11 ]  + a の matrix [ 11 ]  * matrix [ 15 ] を  代入する  。 
		b の matrix [ 12 ] に a の matrix [ 12 ]  * matrix [ 0 ]  + a の matrix [ 13 ]  * matrix [ 4 ]  + a の matrix [ 14 ]  * matrix [ 8 ]  + a の matrix [ 15 ]  * matrix [ 12 ] を  代入する  。 
		b の matrix [ 13 ] に a の matrix [ 12 ]  * matrix [ 1 ]  + a の matrix [ 13 ]  * matrix [ 5 ]  + a の matrix [ 14 ]  * matrix [ 9 ]  + a の matrix [ 15 ]  * matrix [ 13 ] を  代入する  。 
		b の matrix [ 14 ] に a の matrix [ 12 ]  * matrix [ 2 ]  + a の matrix [ 13 ]  * matrix [ 6 ]  + a の matrix [ 14 ]  * matrix [ 10 ]  + a の matrix [ 15 ]  * matrix [ 14 ] を  代入する  。 
		b の matrix [ 15 ] に a の matrix [ 12 ]  * matrix [ 3 ]  + a の matrix [ 13 ]  * matrix [ 7 ]  + a の matrix [ 14 ]  * matrix [ 11 ]  + a の matrix [ 15 ]  * matrix [ 15 ] を  代入する  。 
	ここまで実行 
} 
( m という 行列4x4 , pos という ベクトル3D , lookAt という ベクトル3D , up という ベクトル3D ) を  とり ( res という 行列4x4 ) を  返す ${"ja":"カメラ行列", "natja":"カメラ行列", "en":"setCameraMat", "naten":"setCameraMat"}$ という  関数  を  おく  。 ここから
	newForward という ベクトル3D の  オブジェクト  を lookAt の x  - pos の x , lookAt の y  - pos の y , lookAt の z  - pos の z で  初期化  。 
	a という ベクトル3D の  オブジェクト  を 0.0 , 0.0 , 0.0 で  初期化  。 
	a に ベクトル3D拡大 ( newForward , ベクトル3Dの内積 ( up , newForward ) ) を  代入する  。 
	newUp という ベクトル3D の  オブジェクト  を up の x  - a の x , up の y  - a の y , up の z  - a の z で  初期化  。 
	newUp の 正規化 する  。 
	newRight という ベクトル3D の  オブジェクト  を 0 , 0 , 0 で  初期化  。 
	newRight に ベクトル3Dの外積 ( newUp , newForward ) を  代入する  。 
	m の matrix に [ newRight の x , newUp の x , newForward の x , 0.0 , newRight の y , newUp の y , newForward の y , 0.0 , newRight の z , newUp の z , newForward の z , 0.0 , 0  - ベクトル3Dの内積 ( newRight , pos ) , 0  - ベクトル3Dの内積 ( newUp , pos ) , 0  - ベクトル3Dの内積 ( newForward , pos ) , 1.0 ] を  代入する  。 
	m を  終了  。 
ここまで実行 
( m という 行列4x4 , fov という 実数 , width という 実数 , height という 実数 , zN という 実数 , zF という 実数 ) を  とり ( result という 行列4x4 ) を  返す ${"ja":"視点行列3D", "natja":"視点行列3D", "en":"perspectiveMat3D", "naten":"perspectiveMat3D"}$ という  関数  を  おく  。 ここから
	PI という 実数 を 3.14159265358979312 で  初期化  。 
	fov という 実数 を 1.0  / tan ( ( 90.0  / 360.0 )  * PI ) で  初期化  。 
	aspectRatio という 実数 を width  / height で  初期化  。 
	zNear という 実数 を zN で  初期化  。 
	zFar という 実数 を zF で  初期化  。 
	zQ という 実数 を zF  / ( zF  - zN ) で  初期化  。 
	m の matrix に [ aspectRatio  * fov , 0.0 , 0.0 , 0.0 , 0.0 , fov , 0.0 , 0.0 , 0.0 , 0.0 , zQ , 1.0 , 0.0 , 0.0 , ( 0  - zFar  * zNear )  / ( zFar  - zNear ) , 0.0 ] を  代入する  。 
	m を  終了  。 
ここまで実行 
( m という 行列4x4 , left という 実数 , right という 実数 , bottom という 実数 , top という 実数 , near という 実数 , far という 実数 ) を  とり ( result という 行列4x4 ) を  返す ${"ja":"視点行列2D", "natja":"視点行列2D", "en":"perspectiveMat2D", "naten":"perspectiveMat2D"}$ という  関数  を  おく  。 ここから
	m の matrix に [ 2.0  / ( right  - left ) , 0.0 , 0.0 , 0.0 , 0.0 , 2.0  / ( top  - bottom ) , 0.0 , 0.0 , 0.0 , 0.0 , 0  - 2.0  / ( near  - far ) , 0.0 , 0  - ( right  + left )  / ( right  - left ) , 0  - ( top  + bottom )  / ( top  - bottom ) , 0  - ( far  + near )  / ( far  - near ) , 1.0 ] を  代入する  。 
	m を  終了  。 
ここまで実行 
( a という 行列4x4 , b という 行列4x4 ) を  とり ( out という 行列4x4 ) を  返す ${"ja":"行列4x4の積", "natja":"行列4x4の積", "en":"mulMatrix4x4", "naten":"mulMatrix4x4"}$ という  関数  を  おく  。 ここから
	out の matrix [ 0 ] に b の matrix [ 0 ]  * a の matrix [ 0 ]  + b の matrix [ 1 ]  * a の matrix [ 4 ]  + b の matrix [ 2 ]  * a の matrix [ 8 ]  + b の matrix [ 3 ]  * a の matrix [ 12 ] を  代入する  。 
	out の matrix [ 1 ] に b の matrix [ 0 ]  * a の matrix [ 1 ]  + b の matrix [ 1 ]  * a の matrix [ 5 ]  + b の matrix [ 2 ]  * a の matrix [ 9 ]  + b の matrix [ 3 ]  * a の matrix [ 13 ] を  代入する  。 
	out の matrix [ 2 ] に b の matrix [ 0 ]  * a の matrix [ 2 ]  + b の matrix [ 1 ]  * a の matrix [ 6 ]  + b の matrix [ 2 ]  * a の matrix [ 10 ]  + b の matrix [ 3 ]  * a の matrix [ 14 ] を  代入する  。 
	out の matrix [ 3 ] に b の matrix [ 0 ]  * a の matrix [ 3 ]  + b の matrix [ 1 ]  * a の matrix [ 7 ]  + b の matrix [ 2 ]  * a の matrix [ 11 ]  + b の matrix [ 3 ]  * a の matrix [ 15 ] を  代入する  。 
	out の matrix [ 4 ] に b の matrix [ 4 ]  * a の matrix [ 0 ]  + b の matrix [ 5 ]  * a の matrix [ 4 ]  + b の matrix [ 6 ]  * a の matrix [ 8 ]  + b の matrix [ 7 ]  * a の matrix [ 12 ] を  代入する  。 
	out の matrix [ 5 ] に b の matrix [ 4 ]  * a の matrix [ 1 ]  + b の matrix [ 5 ]  * a の matrix [ 5 ]  + b の matrix [ 6 ]  * a の matrix [ 9 ]  + b の matrix [ 7 ]  * a の matrix [ 13 ] を  代入する  。 
	out の matrix [ 6 ] に b の matrix [ 4 ]  * a の matrix [ 2 ]  + b の matrix [ 5 ]  * a の matrix [ 6 ]  + b の matrix [ 6 ]  * a の matrix [ 10 ]  + b の matrix [ 7 ]  * a の matrix [ 14 ] を  代入する  。 
	out の matrix [ 7 ] に b の matrix [ 4 ]  * a の matrix [ 3 ]  + b の matrix [ 5 ]  * a の matrix [ 7 ]  + b の matrix [ 6 ]  * a の matrix [ 11 ]  + b の matrix [ 7 ]  * a の matrix [ 15 ] を  代入する  。 
	out の matrix [ 8 ] に b の matrix [ 8 ]  * a の matrix [ 0 ]  + b の matrix [ 9 ]  * a の matrix [ 4 ]  + b の matrix [ 10 ]  * a の matrix [ 8 ]  + b の matrix [ 11 ]  * a の matrix [ 12 ] を  代入する  。 
	out の matrix [ 9 ] に b の matrix [ 8 ]  * a の matrix [ 1 ]  + b の matrix [ 9 ]  * a の matrix [ 5 ]  + b の matrix [ 10 ]  * a の matrix [ 9 ]  + b の matrix [ 11 ]  * a の matrix [ 13 ] を  代入する  。 
	out の matrix [ 10 ] に b の matrix [ 8 ]  * a の matrix [ 2 ]  + b の matrix [ 9 ]  * a の matrix [ 6 ]  + b の matrix [ 10 ]  * a の matrix [ 10 ]  + b の matrix [ 11 ]  * a の matrix [ 14 ] を  代入する  。 
	out の matrix [ 11 ] に b の matrix [ 8 ]  * a の matrix [ 3 ]  + b の matrix [ 9 ]  * a の matrix [ 7 ]  + b の matrix [ 10 ]  * a の matrix [ 11 ]  + b の matrix [ 11 ]  * a の matrix [ 15 ] を  代入する  。 
	out の matrix [ 12 ] に b の matrix [ 12 ]  * a の matrix [ 0 ]  + b の matrix [ 13 ]  * a の matrix [ 4 ]  + b の matrix [ 14 ]  * a の matrix [ 8 ]  + b の matrix [ 15 ]  * a の matrix [ 12 ] を  代入する  。 
	out の matrix [ 13 ] に b の matrix [ 12 ]  * a の matrix [ 1 ]  + b の matrix [ 13 ]  * a の matrix [ 5 ]  + b の matrix [ 14 ]  * a の matrix [ 9 ]  + b の matrix [ 15 ]  * a の matrix [ 13 ] を  代入する  。 
	out の matrix [ 14 ] に b の matrix [ 12 ]  * a の matrix [ 2 ]  + b の matrix [ 13 ]  * a の matrix [ 6 ]  + b の matrix [ 14 ]  * a の matrix [ 10 ]  + b の matrix [ 15 ]  * a の matrix [ 14 ] を  代入する  。 
	out の matrix [ 15 ] に b の matrix [ 12 ]  * a の matrix [ 3 ]  + b の matrix [ 13 ]  * a の matrix [ 7 ]  + b の matrix [ 14 ]  * a の matrix [ 11 ]  + b の matrix [ 15 ]  * a の matrix [ 15 ] を  代入する  。 
ここまで実行 
クラス : ${"ja":"光源クラス", "natja":"光源クラス", "en":"LightClass", "naten":"LightClass"}$ {
公開 : 	${"ja":"座標", "natja":"座標", "en":"pos", "naten":"pos"}$ という ベクトル3D を  おく  。 
	半径 という 実数 を  おく  。 
	ambient という ベクトル3D を  おく  。 
	diffuse という ベクトル3D を  おく  。 
	specular という ベクトル3D を  おく  。 
	posLoc という 整数32 を  おく  。 
	radiusLoc という 整数32 を  おく  。 
	ambientLoc という 整数32 を  おく  。 
	diffuseLoc という 整数32 を  おく  。 
	specularLoc という 整数32 を  おく  。 
	( p という ベクトル3D , r という 実数 , a という ベクトル3D , d という ベクトル3D , s という ベクトル3D , id という 整数 ) を  とり 光源クラス という  関数  を  おく  。 ここから
		座標 に p を  代入する  。 
		半径 に r を  代入する  。 
		ambient に a を  代入する  。 
		diffuse に d を  代入する  。 
		specular に s を  代入する  。 
		temp という 文字列 を "pointLights["で  初期化  。 
		temp に temp  + id を  代入する  。 
		temp に temp  + "]"を  代入する  。 
		posStr という 文字列 を temp  + ".position"で  初期化  。 
		posLoc に glGetUniformLocation ( 0 , posStr ) を  代入する  。 
		radiusStr という 文字列 を temp  + ".radius"で  初期化  。 
		radiusLoc に glGetUniformLocation ( 0 , radiusStr ) を  代入する  。 
		ambientStr という 文字列 を temp  + ".ambient"で  初期化  。 
		ambientLoc に glGetUniformLocation ( 0 , ambientStr ) を  代入する  。 
		diffuseStr という 文字列 を temp  + ".diffuse"で  初期化  。 
		diffuseLoc に glGetUniformLocation ( 0 , diffuseStr ) を  代入する  。 
		specularStr という 文字列 を temp  + ".specular"で  初期化  。 
		specularLoc に glGetUniformLocation ( 0 , specularStr ) を  代入する  。 
	ここまで実行 
	( coord という ベクトル3D ) を  とり ${"ja":"座標設定", "natja":"座標設定", "en":"setPos", "naten":"setPos"}$ という  関数  を  おく  。 ここから
		座標 に coord を  代入する  。 
	ここまで実行 
} 
クラス : ${"ja":"モデル", "natja":"モデル", "en":"Model", "naten":"Model"}$ {
公開 : 	${"ja":"色", "natja":"色", "en":"color", "naten":"color"}$ という ベクトル3D を  おく  。 
	${"ja":"座標", "natja":"座標", "en":"pos", "naten":"pos"}$ という ベクトル3D を  おく  。 
	lightID という 整数 を  おく  。 
	scale という ベクトル3D を  おく  。 
	( data という * 実数 , num という 整数 , c という ベクトル3D , p という ベクトル3D , s という 整数 ) を  とり モデル という  関数  を  おく  。 ここから
		1.0 , 1.0 , 1.0 scale の ベクトル3D する  。 
		vertices に data を  代入する  。 
		pointNum に num を  代入する  。 
		色 に c を  代入する  。 
		座標 に p を  代入する  。 
		shaderID に s を  代入する  。 
		lightID に ( 0  - ( 1 ) ) を  代入する  。 
		modelMat の 単位化 する  。 
		transMat の 単位化 する  。 
		scaleMat の 単位化 する  。 
		rotateMat の 単位化 する  。 
		defaultRotateMat の 単位化 する  。 
		もし shaderID  は 0 ならば ここから
			viewPosUniLoc に glGetUniformLocation ( 0 , "viewPos") を  代入する  。 
			objectColorUniLoc に glGetUniformLocation ( 0 , "objectColor") を  代入する  。 
			dirLightDirUniLoc に glGetUniformLocation ( 0 , "dirLight.direction") を  代入する  。 
			dirLightAmbientUniLoc に glGetUniformLocation ( 0 , "dirLight.ambient") を  代入する  。 
			dirLightDiffuseUniLoc に glGetUniformLocation ( 0 , "dirLight.diffuse") を  代入する  。 
			dirLightSpecularUniLoc に glGetUniformLocation ( 0 , "dirLight.specular") を  代入する  。 
		ここまで実行 
		もし shaderID  は 1 ならば ここから
			lightColorUniLoc に glGetUniformLocation ( 1 , "lightColor") を  代入する  。 
		ここまで実行 
		projMatUniformLoc に glGetUniformLocation ( shaderID , "uProjMat") を  代入する  。 
		viewMatUniformLoc に glGetUniformLocation ( shaderID , "uViewMat") を  代入する  。 
		modelMatUniformLoc に glGetUniformLocation ( shaderID , "uModelMat") を  代入する  。 
		buffer に glCreateBuffer ( ) を  代入する  。 
		34962 , buffer glBindBuffer する  。 
		34962 , vertices , num  * 6 , 35044 glBufferData する  。 
	ここまで実行 
	( data という * 実数 , num という 整数 , c という ベクトル3D , p という ベクトル3D , s という 整数 , l という 整数 ) を  とり モデル という  関数  を  おく  。 ここから
		1.0 , 1.0 , 1.0 scale の ベクトル3D する  。 
		lightID に l を  代入する  。 
		vertices に data を  代入する  。 
		pointNum に num を  代入する  。 
		色 に c を  代入する  。 
		座標 に p を  代入する  。 
		shaderID に s を  代入する  。 
		modelMat の 単位化 する  。 
		transMat の 単位化 する  。 
		scaleMat の 単位化 する  。 
		rotateMat の 単位化 する  。 
		defaultRotateMat の 単位化 する  。 
		もし shaderID  は 0 ならば ここから
			viewPosUniLoc に glGetUniformLocation ( 0 , "viewPos") を  代入する  。 
			objectColorUniLoc に glGetUniformLocation ( 0 , "objectColor") を  代入する  。 
			dirLightDirUniLoc に glGetUniformLocation ( 0 , "dirLight.direction") を  代入する  。 
			dirLightAmbientUniLoc に glGetUniformLocation ( 0 , "dirLight.ambient") を  代入する  。 
			dirLightDiffuseUniLoc に glGetUniformLocation ( 0 , "dirLight.diffuse") を  代入する  。 
			dirLightSpecularUniLoc に glGetUniformLocation ( 0 , "dirLight.specular") を  代入する  。 
		ここまで実行 
		もし shaderID  は 1 ならば ここから
			lightColorUniLoc に glGetUniformLocation ( 1 , "lightColor") を  代入する  。 
		ここまで実行 
		projMatUniformLoc に glGetUniformLocation ( shaderID , "uProjMat") を  代入する  。 
		viewMatUniformLoc に glGetUniformLocation ( shaderID , "uViewMat") を  代入する  。 
		modelMatUniformLoc に glGetUniformLocation ( shaderID , "uModelMat") を  代入する  。 
		buffer に glCreateBuffer ( ) を  代入する  。 
		34962 , buffer glBindBuffer する  。 
		34962 , vertices , num  * 6 , 35044 glBufferData する  。 
	ここまで実行 
	( coord という ベクトル3D ) を  とり ${"ja":"座標設定", "natja":"座標設定", "en":"setPos", "naten":"setPos"}$ という  関数  を  おく  。 ここから
		座標 に coord を  代入する  。 
	ここまで実行 
	( offset という ベクトル3D ) を  とり ${"ja":"移動", "natja":"移動", "en":"translate", "naten":"translate"}$ という  関数  を  おく  。 ここから
		座標 に ベクトル3Dの和 ( 座標 , offset ) を  代入する  。 
	ここまで実行 
	( x という 実数 , y という 実数 , z という 実数 ) を  とり ${"ja":"拡大縮小設定", "natja":"拡大縮小設定", "en":"setScale", "naten":"setScale"}$ という  関数  を  おく  。 ここから
		scale の x に x を  代入する  。 
		scale の y に y を  代入する  。 
		scale の z に z を  代入する  。 
	ここまで実行 
	( x という 実数 , y という 実数 , z という 実数 ) を  とり ${"ja":"拡大縮小", "natja":"拡大縮小", "en":"scale", "naten":"scale"}$ という  関数  を  おく  。 ここから
		scale の x に scale の x  * ( x ) を  代入する  。 
		scale の y に scale の y  * ( y ) を  代入する  。 
		scale の z に scale の z  * ( z ) を  代入する  。 
	ここまで実行 
	( axis という ベクトル3D , t という 実数 ) を  とり ${"ja":"回転設定", "natja":"回転設定", "en":"setRotate", "naten":"setRotate"}$ という  関数  を  おく  。 ここから
		defaultRotateMat の 単位化 する  。 
		axis , t defaultRotateMat の 回転 する  。 
	ここまで実行 
	( axis という ベクトル3D , t という 実数 ) を  とり ${"ja":"回転", "natja":"回転", "en":"rotate", "naten":"rotate"}$ という  関数  を  おく  。 ここから
		temp という 行列4x4 を  おく  。 
		temp の 単位化 する  。 
		axis , t temp の 回転 する  。 
		rotateMat に 行列4x4の積 ( temp , rotateMat ) を  代入する  。 
	ここまで実行 
	( axis という ベクトル3D , t という 実数 , offcenter という ベクトル3D ) を  とり ${"ja":"回転", "natja":"回転", "en":"rotate", "naten":"rotate"}$ という  関数  を  おく  。 ここから
		temp という 行列4x4 を  おく  。 
		temp の 単位化 する  。 
		offcenter temp の 移動 する  。 
		rotateMat に 行列4x4の積 ( temp , rotateMat ) を  代入する  。 
		temp の 単位化 する  。 
		axis , t temp の 回転 する  。 
		rotateMat に 行列4x4の積 ( temp , rotateMat ) を  代入する  。 
	ここまで実行 
	( projMat という 行列4x4 , viewMat という 行列4x4 , camera という ベクトル3D , lights という 配列 < * 光源クラス > , dirLight という 光源クラス ) を  とり ${"ja":"描画", "natja":"描画", "en":"draw", "naten":"draw"}$ という  関数  を  おく  。 ここから
		PI という 実数 を 3.14159265358979312 で  初期化  。 
		scaleMat の 単位化 する  。 
		scale の x , scale の y , scale の z scaleMat の 拡大縮小 する  。 
		座標 transMat の 移動 する  。 
		modelMat の 単位化 する  。 
		modelMat に 行列4x4の積 ( scaleMat , modelMat ) を  代入する  。 
		modelMat に 行列4x4の積 ( defaultRotateMat , modelMat ) を  代入する  。 
		modelMat に 行列4x4の積 ( rotateMat , modelMat ) を  代入する  。 
		modelMat に 行列4x4の積 ( transMat , modelMat ) を  代入する  。 
		34962 , buffer glBindBuffer する  。 
		0 glEnableVertexAttribArray する  。 
		0 , 3 , 5126 , 0 , 6  * 4 , 0 glVertexAttribPointer する  。 
		1 glEnableVertexAttribArray する  。 
		1 , 3 , 5126 , 0 , 6  * 4 , 3  * 4 glVertexAttribPointer する  。 
		shaderID glUseProgram する  。 
		もし shaderID  は 0 ならば ここから
			objectColorUniLoc , 色 の x , 色 の y , 色 の z glUniform3f する  。 
			viewPosUniLoc , camera の x , camera の y , camera の z glUniform3f する  。 
			dirLightDirUniLoc , dirLight の 座標 の x , dirLight の 座標 の y , dirLight の 座標 の z glUniform3f する  。 
			dirLightAmbientUniLoc , dirLight の ambient の x , dirLight の ambient の y , dirLight の ambient の z glUniform3f する  。 
			dirLightDiffuseUniLoc , dirLight の diffuse の x , dirLight の diffuse の y , dirLight の diffuse の z glUniform3f する  。 
			dirLightSpecularUniLoc , dirLight の specular の x , dirLight の specular の y , dirLight の specular の z glUniform3f する  。 
			lights の 長さ ( ) 回繰り返す ここから
				lightPtr という * 光源クラス を lights の 取得 ( カウンタ ) で  初期化  。 
				lightPtr -> posLoc , lightPtr -> 座標 の x , lightPtr -> 座標 の y , lightPtr -> 座標 の z glUniform3f する  。 
				lightPtr -> ambientLoc , lightPtr -> ambient の x , lightPtr -> ambient の y , lightPtr -> ambient の z glUniform3f する  。 
				lightPtr -> diffuseLoc , lightPtr -> diffuse の x , lightPtr -> diffuse の y , lightPtr -> diffuse の z glUniform3f する  。 
				lightPtr -> specularLoc , lightPtr -> specular の x , lightPtr -> specular の y , lightPtr -> specular の z glUniform3f する  。 
				lightPtr -> radiusLoc , lightPtr -> 半径 glUniform1f する  。 
			ここまで実行 
		ここまで実行 
		もし shaderID  は 1 ならば ここから
			lightColorUniLoc , 色 の x , 色 の y , 色 の z glUniform3f する  。 
		ここまで実行 
		projMatUniformLoc , 0 , projMat の matrix glUniformMatrix4fv する  。 
		viewMatUniformLoc , 0 , viewMat の matrix glUniformMatrix4fv する  。 
		modelMatUniformLoc , 0 , modelMat の matrix glUniformMatrix4fv する  。 
		34962 , buffer glBindBuffer する  。 
		4 , 0 , pointNum glDrawArrays する  。 
		rotateMat の 単位化 する  。 
		transMat の 単位化 する  。 
		scaleMat の 単位化 する  。 
	ここまで実行 
非公開 : 	vertices という * 実数 を  おく  。 
	pointNum という 整数 を  おく  。 
	buffer という 整数32 を  おく  。 
	modelMat という 行列4x4 を  おく  。 
	transMat という 行列4x4 を  おく  。 
	scaleMat という 行列4x4 を  おく  。 
	rotateMat という 行列4x4 を  おく  。 
	defaultRotateMat という 行列4x4 を  おく  。 
	shaderID という 整数 を  おく  。 
	viewPosUniLoc という 整数32 を  おく  。 
	lightPosUniLoc という 整数32 を  おく  。 
	lightColorUniLoc という 整数32 を  おく  。 
	objectColorUniLoc という 整数32 を  おく  。 
	dirLightDirUniLoc という 整数32 を  おく  。 
	dirLightAmbientUniLoc という 整数32 を  おく  。 
	dirLightDiffuseUniLoc という 整数32 を  おく  。 
	dirLightSpecularUniLoc という 整数32 を  おく  。 
	projMatUniformLoc という 整数32 を  おく  。 
	viewMatUniformLoc という 整数32 を  おく  。 
	modelMatUniformLoc という 整数32 を  おく  。 
} 
クラス : ${"ja":"カメラ", "natja":"カメラ", "en":"Camera", "naten":"Camera"}$ {
公開 : 	${"ja":"座標", "natja":"座標", "en":"pos", "naten":"pos"}$ という ベクトル3D を  おく  。 
	${"ja":"感度", "natja":"感度", "en":"sensitivity", "naten":"sensitivity"}$ という 実数 を  おく  。 
	( p という ベクトル3D ) を  とり カメラ という  関数  を  おく  。 ここから
		座標 に p を  代入する  。 
		0.0 , 0.0 , 1.0 view の ベクトル3D する  。 
		0.0 , 0.0 , 1.0 lookDir の ベクトル3D する  。 
		0.0 , 1.0 , 0.0 up の ベクトル3D する  。 
		yaw に 90.0 を  代入する  。 
		pitch に 0.0 を  代入する  。 
		感度 に 1.0 を  代入する  。 
	ここまで実行 
	( p という ベクトル3D ) を  とり ${"ja":"座標設定", "natja":"座標設定", "en":"setPos", "naten":"setPos"}$ という  関数  を  おく  。 ここから
		座標 に p を  代入する  。 
	ここまで実行 
	( y という 実数 , p という 実数 ) を  とり ${"ja":"視点角度設定", "natja":"視点角度設定", "en":"setAngle", "naten":"setAngle"}$ という  関数  を  おく  。 ここから
		yaw に y を  代入する  。 
		pitch に p を  代入する  。 
	ここまで実行 
	( s という 実数 ) を  とり ${"ja":"感度設定", "natja":"感度設定", "en":"setSensitivity", "naten":"setSensitivity"}$ という  関数  を  おく  。 ここから
		感度 に s を  代入する  。 
	ここまで実行 
	( xOffset という 実数 , yOffset という 実数 , elapsedTime という 実数 ) を  とり ( result という 行列4x4 ) を  返す ${"ja":"アップデート", "natja":"アップデート", "en":"update", "naten":"update"}$ という  関数  を  おく  。 ここから
		もし キーチェック ( 32 )  は 1 ならば ここから
			座標 の y に 座標 の y  + elapsedTime  * 5.0 を  代入する  。 
		ここまで実行 
		もし キーチェック ( 16 )  は 1 ならば ここから
			座標 の y に 座標 の y  - elapsedTime  * 5.0 を  代入する  。 
		ここまで実行 
		もし キーチェック ( 65 )  は 1 ならば ここから
			座標 の z に 座標 の z  - elapsedTime  * sin ( ラジアンへ ( yaw  - 90 ) )  * 5.0 を  代入する  。 
			座標 の x に 座標 の x  - elapsedTime  * cos ( ラジアンへ ( yaw  - 90 ) )  * 5.0 を  代入する  。 
		ここまで実行 
		もし キーチェック ( 68 )  は 1 ならば ここから
			座標 の z に 座標 の z  + elapsedTime  * sin ( ラジアンへ ( yaw  - 90 ) )  * 5.0 を  代入する  。 
			座標 の x に 座標 の x  + elapsedTime  * cos ( ラジアンへ ( yaw  - 90 ) )  * 5.0 を  代入する  。 
		ここまで実行 
		もし キーチェック ( 87 )  は 1 ならば ここから
			座標 の z に 座標 の z  + elapsedTime  * sin ( ラジアンへ ( yaw ) )  * 5.0 を  代入する  。 
			座標 の x に 座標 の x  + elapsedTime  * cos ( ラジアンへ ( yaw ) )  * 5.0 を  代入する  。 
		ここまで実行 
		もし キーチェック ( 83 )  は 1 ならば ここから
			座標 の z に 座標 の z  - elapsedTime  * sin ( ラジアンへ ( yaw ) )  * 5.0 を  代入する  。 
			座標 の x に 座標 の x  - elapsedTime  * cos ( ラジアンへ ( yaw ) )  * 5.0 を  代入する  。 
		ここまで実行 
		yaw に yaw  - xOffset  * 感度  * elapsedTime を  代入する  。 
		pitch に pitch  - yOffset  * 感度  * elapsedTime を  代入する  。 
		もし pitch  < 0  - 89.0 ならば ここから
			pitch に 0  - 89.0 を  代入する  。 
		ここまで実行 
		もし pitch  > 89.0 ならば ここから
			pitch に 89.0 を  代入する  。 
		ここまで実行 
		lookDir の x に cos ( ラジアンへ ( yaw ) )  * cos ( ラジアンへ ( pitch ) ) を  代入する  。 
		lookDir の y に sin ( ラジアンへ ( pitch ) ) を  代入する  。 
		lookDir の z に sin ( ラジアンへ ( yaw ) )  * cos ( ラジアンへ ( pitch ) ) を  代入する  。 
		lookDir の 正規化 する  。 
		result の 単位化 する  。 
		view に ベクトル3Dの和 ( lookDir , 座標 ) を  代入する  。 
		result に カメラ行列 ( result , 座標 , view , up ) を  代入する  。 
	ここまで実行 
非公開 : 	view という ベクトル3D を  おく  。 
	lookDir という ベクトル3D を  おく  。 
	up という ベクトル3D を  おく  。 
	yaw という 実数 を  おく  。 
	pitch という 実数 を  おく  。 
} 
クラス : ${"ja":"シーン", "natja":"シーン", "en":"Scene", "naten":"Scene"}$ {
公開 : 	${"ja":"スプライト配列", "natja":"スプライト配列", "en":"sprites", "naten":"sprites"}$ という 配列 < * モデル > を  おく  。 
	${"ja":"光源配列", "natja":"光源配列", "en":"lights", "naten":"lights"}$ という 配列 < * 光源クラス > を  おく  。 
	${"ja":"目", "natja":"目", "en":"camera", "naten":"camera"}$ という カメラ を  おく  。 
	平行光源 という 光源クラス を  おく  。 
	関数 シーン を  おく  。 ここから
		last に 時間計測 ( )  / 1000.0 を  代入する  。 
		now に 0.0 を  代入する  。 
		elapsedTime に 0.0 を  代入する  。 
		lastX に マウス絶対座標X ( ) を  代入する  。 
		lastY に マウス絶対座標Y ( ) を  代入する  。 
		projMat の 単位化 する  。 
		viewMat の 単位化 する  。 
		projMat に 視点行列3D ( projMat , 90.0 , 720.0 , 1280.0 , 0.100000000000000006 , 100.0 ) を  代入する  。 
		temp という ベクトル3D の  オブジェクト  を 0.0 , 0.0 , 0  - 4.0 で  初期化  。 
		temp 目 の カメラ する  。 
		スプライト配列 の 配列 する  。 
		光源配列 の 配列 する  。 
		方向 という ベクトル3D の  オブジェクト  を ( 0  - ( 1.0 ) ) , ( 0  - ( 1.0 ) ) , ( 0  - ( 1.0 ) ) で  初期化  。 
		白 という ベクトル3D の  オブジェクト  を 1.0 , 1.0 , 1.0 で  初期化  。 
		平行光源 の 座標 に 方向 を  代入する  。 
		平行光源 の ambient に 白  * 0.5 を  代入する  。 
		平行光源 の diffuse に 白  * 0.5 を  代入する  。 
		平行光源 の specular に 白  * 0.0 を  代入する  。 
	ここまで実行 
	( 感度 という 実数 ) を  とり ${"ja":"感度設定", "natja":"感度設定", "en":"setSensitivity", "naten":"setSensitivity"}$ という  関数  を  おく  。 ここから
		感度 目 の 感度設定 する  。 
	ここまで実行 
	関数 ${"ja":"描画", "natja":"描画", "en":"draw", "naten":"draw"}$ を  おく  。 ここから
		now に 時間計測 ( )  / 1000.0 を  代入する  。 
		elapsedTime に now  - last を  代入する  。 
		last に now を  代入する  。 
		0.0 , 0.0 , 0.0 , 1.0 glClearColor する  。 
		1.0 glClearDepth する  。 
		2929 glEnable する  。 
		515 glDepthFunc する  。 
		16640 glClear する  。 
		xOffset という 実数 を マウス絶対座標X ( )  - lastX で  初期化  。 
		yOffset という 実数 を マウス絶対座標Y ( )  - lastY で  初期化  。 
		lastX に マウス絶対座標X ( ) を  代入する  。 
		lastY に マウス絶対座標Y ( ) を  代入する  。 
		viewMat の 単位化 する  。 
		viewMat に 目 の アップデート ( xOffset , yOffset , elapsedTime ) を  代入する  。 
		スプライト配列 の 長さ ( ) 回繰り返す ここから
			もし スプライト配列 の 取得 ( カウンタ ) -> lightID  >= 0 ならば ここから
				スプライト配列 の 取得 ( カウンタ ) -> 座標 光源配列 の 取得 ( スプライト配列 の 取得 ( カウンタ ) -> lightID ) -> 座標設定 する  。 
			ここまで実行 
		ここまで実行 
		( i という 整数 を 0 で  初期化  。 ) から ( i  は スプライト配列 の size ) まで ( i に i  + 1 を  代入する  。 ) 繰り返し ここから
			projMat , viewMat , 目 の 座標 , 光源配列 , 平行光源 スプライト配列 の 取得 ( i ) -> 描画 する  。 
		ここまで実行 
	ここまで実行 
	( size という 実数 , 色 という ベクトル3D , 座標 という ベクトル3D ) を  とり ( id という 整数 ) を  返す ${"ja":"キューブ追加", "natja":"キューブ追加", "en":"addCube", "naten":"addCube"}$ という  関数  を  おく  。 ここから
		vertices [ 12 ] [ 3 ] [ 6 ] という 実数 を [ [ [ 0  - size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 0.0 , 0.0 , 0  - 1.0 ] , [ 0  - size  / 2 , size  / 2 , 0  - size  / 2 , 0.0 , 0.0 , 0  - 1.0 ] , [ size  / 2 , size  / 2 , 0  - size  / 2 , 0.0 , 0.0 , 0  - 1.0 ] ] , [ [ 0  - size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 0.0 , 0.0 , 0  - 1.0 ] , [ size  / 2 , size  / 2 , 0  - size  / 2 , 0.0 , 0.0 , 0  - 1.0 ] , [ size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 0.0 , 0.0 , 0  - 1.0 ] ] , [ [ size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 1.0 , 0.0 , 0.0 ] , [ size  / 2 , size  / 2 , 0  - size  / 2 , 1.0 , 0.0 , 0.0 ] , [ size  / 2 , size  / 2 , size  / 2 , 1.0 , 0.0 , 0.0 ] ] , [ [ size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 1.0 , 0.0 , 0.0 ] , [ size  / 2 , size  / 2 , size  / 2 , 1.0 , 0.0 , 0.0 ] , [ size  / 2 , 0  - size  / 2 , size  / 2 , 1.0 , 0.0 , 0.0 ] ] , [ [ size  / 2 , 0  - size  / 2 , size  / 2 , 0.0 , 0.0 , 1.0 ] , [ size  / 2 , size  / 2 , size  / 2 , 0.0 , 0.0 , 1.0 ] , [ 0  - size  / 2 , size  / 2 , size  / 2 , 0.0 , 0.0 , 1.0 ] ] , [ [ size  / 2 , 0  - size  / 2 , size  / 2 , 0.0 , 0.0 , 1.0 ] , [ 0  - size  / 2 , size  / 2 , size  / 2 , 0.0 , 0.0 , 1.0 ] , [ 0  - size  / 2 , 0  - size  / 2 , size  / 2 , 0.0 , 0.0 , 1.0 ] ] , [ [ 0  - size  / 2 , 0  - size  / 2 , size  / 2 , 0  - 1.0 , 0.0 , 0.0 ] , [ 0  - size  / 2 , size  / 2 , size  / 2 , 0  - 1.0 , 0.0 , 0.0 ] , [ 0  - size  / 2 , size  / 2 , 0  - size  / 2 , 0  - 1.0 , 0.0 , 0.0 ] ] , [ [ 0  - size  / 2 , 0  - size  / 2 , size  / 2 , 0  - 1.0 , 0.0 , 0.0 ] , [ 0  - size  / 2 , size  / 2 , 0  - size  / 2 , 0  - 1.0 , 0.0 , 0.0 ] , [ 0  - size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 0  - 1.0 , 0.0 , 0.0 ] ] , [ [ 0  - size  / 2 , size  / 2 , 0  - size  / 2 , 0.0 , 1.0 , 0.0 ] , [ 0  - size  / 2 , size  / 2 , size  / 2 , 0.0 , 1.0 , 0.0 ] , [ size  / 2 , size  / 2 , size  / 2 , 0.0 , 1.0 , 0.0 ] ] , [ [ 0  - size  / 2 , size  / 2 , 0  - size  / 2 , 0.0 , 1.0 , 0.0 ] , [ size  / 2 , size  / 2 , size  / 2 , 0.0 , 1.0 , 0.0 ] , [ size  / 2 , size  / 2 , 0  - size  / 2 , 0.0 , 1.0 , 0.0 ] ] , [ [ size  / 2 , 0  - size  / 2 , size  / 2 , 0.0 , 0  - 1.0 , 0.0 ] , [ 0  - size  / 2 , 0  - size  / 2 , size  / 2 , 0.0 , 0  - 1.0 , 0.0 ] , [ 0  - size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 0.0 , 0  - 1.0 , 0.0 ] ] , [ [ size  / 2 , 0  - size  / 2 , size  / 2 , 0.0 , 0  - 1.0 , 0.0 ] , [ 0  - size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 0.0 , 0  - 1.0 , 0.0 ] , [ size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 0.0 , 0  - 1.0 , 0.0 ] ] ] で  初期化  。 
		cube という * モデル を メモリ確保 ( バイト数 ( cube に  ある  オブジェクト ) ) で  初期化  。 
		& vertices , 36 , 色 , 座標 , 0 cube -> モデル する  。 
		cube スプライト配列 の 追加 する  。 
		id に スプライト配列 の 長さ ( )  - 1 を  代入する  。 
	ここまで実行 
	( width という 実数 , height という 実数 , depth という 実数 , 色 という ベクトル3D , 座標 という ベクトル3D ) を  とり ( id という 整数 ) を  返す ${"ja":"直方体追加", "natja":"直方体追加", "en":"addCuboid", "naten":"addCuboid"}$ という  関数  を  おく  。 ここから
		id に キューブ追加 ( 1.0 , 色 , 座標 ) を  代入する  。 
		width , height , depth スプライト配列 の 取得 ( id ) -> 拡大縮小 する  。 
	ここまで実行 
	( size という 実数 , 色 という ベクトル3D , 座標 という ベクトル3D , 強さ という 実数 ) を  とり ( id という 整数 ) を  返す ${"ja":"ライト追加", "natja":"ライト追加", "en":"addLight", "naten":"addLight"}$ という  関数  を  おく  。 ここから
		vertices [ 12 ] [ 3 ] [ 6 ] という 実数 を [ [ [ 0  - size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 0.0 , 0.0 , 0  - 1.0 ] , [ 0  - size  / 2 , size  / 2 , 0  - size  / 2 , 0.0 , 0.0 , 0  - 1.0 ] , [ size  / 2 , size  / 2 , 0  - size  / 2 , 0.0 , 0.0 , 0  - 1.0 ] ] , [ [ 0  - size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 0.0 , 0.0 , 0  - 1.0 ] , [ size  / 2 , size  / 2 , 0  - size  / 2 , 0.0 , 0.0 , 0  - 1.0 ] , [ size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 0.0 , 0.0 , 0  - 1.0 ] ] , [ [ size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 1.0 , 0.0 , 0.0 ] , [ size  / 2 , size  / 2 , 0  - size  / 2 , 1.0 , 0.0 , 0.0 ] , [ size  / 2 , size  / 2 , size  / 2 , 1.0 , 0.0 , 0.0 ] ] , [ [ size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 1.0 , 0.0 , 0.0 ] , [ size  / 2 , size  / 2 , size  / 2 , 1.0 , 0.0 , 0.0 ] , [ size  / 2 , 0  - size  / 2 , size  / 2 , 1.0 , 0.0 , 0.0 ] ] , [ [ size  / 2 , 0  - size  / 2 , size  / 2 , 0.0 , 0.0 , 1.0 ] , [ size  / 2 , size  / 2 , size  / 2 , 0.0 , 0.0 , 1.0 ] , [ 0  - size  / 2 , size  / 2 , size  / 2 , 0.0 , 0.0 , 1.0 ] ] , [ [ size  / 2 , 0  - size  / 2 , size  / 2 , 0.0 , 0.0 , 1.0 ] , [ 0  - size  / 2 , size  / 2 , size  / 2 , 0.0 , 0.0 , 1.0 ] , [ 0  - size  / 2 , 0  - size  / 2 , size  / 2 , 0.0 , 0.0 , 1.0 ] ] , [ [ 0  - size  / 2 , 0  - size  / 2 , size  / 2 , 0  - 1.0 , 0.0 , 0.0 ] , [ 0  - size  / 2 , size  / 2 , size  / 2 , 0  - 1.0 , 0.0 , 0.0 ] , [ 0  - size  / 2 , size  / 2 , 0  - size  / 2 , 0  - 1.0 , 0.0 , 0.0 ] ] , [ [ 0  - size  / 2 , 0  - size  / 2 , size  / 2 , 0  - 1.0 , 0.0 , 0.0 ] , [ 0  - size  / 2 , size  / 2 , 0  - size  / 2 , 0  - 1.0 , 0.0 , 0.0 ] , [ 0  - size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 0  - 1.0 , 0.0 , 0.0 ] ] , [ [ 0  - size  / 2 , size  / 2 , 0  - size  / 2 , 0.0 , 1.0 , 0.0 ] , [ 0  - size  / 2 , size  / 2 , size  / 2 , 0.0 , 1.0 , 0.0 ] , [ size  / 2 , size  / 2 , size  / 2 , 0.0 , 1.0 , 0.0 ] ] , [ [ 0  - size  / 2 , size  / 2 , 0  - size  / 2 , 0.0 , 1.0 , 0.0 ] , [ size  / 2 , size  / 2 , size  / 2 , 0.0 , 1.0 , 0.0 ] , [ size  / 2 , size  / 2 , 0  - size  / 2 , 0.0 , 1.0 , 0.0 ] ] , [ [ size  / 2 , 0  - size  / 2 , size  / 2 , 0.0 , 0  - 1.0 , 0.0 ] , [ 0  - size  / 2 , 0  - size  / 2 , size  / 2 , 0.0 , 0  - 1.0 , 0.0 ] , [ 0  - size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 0.0 , 0  - 1.0 , 0.0 ] ] , [ [ size  / 2 , 0  - size  / 2 , size  / 2 , 0.0 , 0  - 1.0 , 0.0 ] , [ 0  - size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 0.0 , 0  - 1.0 , 0.0 ] , [ size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 0.0 , 0  - 1.0 , 0.0 ] ] ] で  初期化  。 
		light という * モデル を メモリ確保 ( バイト数 ( light に  ある  オブジェクト ) ) で  初期化  。 
		& vertices , 36 , 色 , 座標 , 1 , 光源配列 の 長さ ( ) light -> モデル する  。 
		lightObject という * 光源クラス を メモリ確保 ( バイト数 ( lightObject に  ある  オブジェクト ) ) で  初期化  。 
		座標 , 強さ , 色  * 0.5 , 色  * 0.5 , 色  * 0.200000000000000011 , 光源配列 の 長さ ( ) lightObject -> 光源クラス する  。 
		light スプライト配列 の 追加 する  。 
		lightObject 光源配列 の 追加 する  。 
		id に スプライト配列 の 長さ ( )  - 1 を  代入する  。 
	ここまで実行 
	( 方向 という ベクトル3D , 色 という ベクトル3D , ambient という 実数 , diffuse という 実数 , specular という 実数 ) を  とり ${"ja":"平行光源設定", "natja":"平行光源設定", "en":"setDirectionalLight", "naten":"setDirectionalLight"}$ という  関数  を  おく  。 ここから
		平行光源 の 座標 に 方向 を  代入する  。 
		平行光源 の ambient に 色  * ambient を  代入する  。 
		平行光源 の diffuse に 色  * diffuse を  代入する  。 
		平行光源 の specular に 色  * specular を  代入する  。 
	ここまで実行 
	( data という 配列 < ベクトル3D > , normals という 配列 < ベクトル3D > , vertexIndices という 配列 < 整数32 > , normalIndices という 配列 < 整数32 > , 色 という ベクトル3D , 座標 という ベクトル3D ) を  とり ( id という 整数 ) を  返す ${"ja":"_モデル追加", "natja":"_モデル追加", "en":"_addModel", "naten":"_addModel"}$ という  関数  を  おく  。 ここから
		vertices という 配列 < 実数 > を  おく  。 
		もし normals の 長さ ( )  > 0 ならば ここから
			vertexIndices の 長さ ( ) 回繰り返す ここから
				data の 取得 ( vertexIndices の 取得 ( カウンタ )  - 1 ) の x vertices の 追加 する  。 
				data の 取得 ( vertexIndices の 取得 ( カウンタ )  - 1 ) の y vertices の 追加 する  。 
				data の 取得 ( vertexIndices の 取得 ( カウンタ )  - 1 ) の z vertices の 追加 する  。 
				normals の 取得 ( normalIndices の 取得 ( カウンタ )  - 1 ) の x vertices の 追加 する  。 
				normals の 取得 ( normalIndices の 取得 ( カウンタ )  - 1 ) の y vertices の 追加 する  。 
				normals の 取得 ( normalIndices の 取得 ( カウンタ )  - 1 ) の z vertices の 追加 する  。 
			ここまで実行 
		ここまで実行 でなければ ここから
			三角形 という 配列 < ベクトル3D > を  おく  。 
			vertexIndices の 長さ ( ) 回繰り返す ここから
				data の 取得 ( vertexIndices の 取得 ( カウンタ )  - 1 ) 三角形 の 追加 する  。 
				もし ( カウンタ  % 3 )  は 2 ならば ここから
					辺1 という ベクトル3D を 三角形 の 取得 ( 1 )  - 三角形 の 取得 ( 0 ) で  初期化  。 
					辺2 という ベクトル3D を 三角形 の 取得 ( 2 )  - 三角形 の 取得 ( 0 ) で  初期化  。 
					normal という ベクトル3D を ベクトル3Dの外積 ( 辺1 , 辺2 ) で  初期化  。 
					normal の 正規化 する  。 
					三角形 の 長さ ( ) 回繰り返す ここから
						三角形 の 取得 ( カウンタ ) の x vertices の 追加 する  。 
						三角形 の 取得 ( カウンタ ) の y vertices の 追加 する  。 
						三角形 の 取得 ( カウンタ ) の z vertices の 追加 する  。 
						normal の x vertices の 追加 する  。 
						normal の y vertices の 追加 する  。 
						normal の z vertices の 追加 する  。 
					ここまで実行 
					三角形 に 三角形 の 範囲削除 ( 0 , 3 ) を  代入する  。 
				ここまで実行 
			ここまで実行 
		ここまで実行 
		model という * モデル を メモリ確保 ( バイト数 ( model に  ある  オブジェクト ) ) で  初期化  。 
		vertices の content , vertexIndices の 長さ ( ) , 色 , 座標 , 0 model -> モデル する  。 
		model スプライト配列 の 追加 する  。 
		id に スプライト配列 の 長さ ( )  - 1 を  代入する  。 
	ここまで実行 
	( data という 文字列 , 色 という ベクトル3D , 座標 という ベクトル3D ) を  とり ( id という 整数 ) を  返す ${"ja":"モデル追加", "natja":"モデル追加", "en":"addModel", "naten":"addModel"}$ という  関数  を  おく  。 ここから
		vertices という 配列 < ベクトル3D > を  おく  。 
		lines という 配列 < 文字列 > を data の 分割 ( '\n') で  初期化  。 
		vertexIndices という 配列 < 整数32 > を  おく  。 
		normalIndices という 配列 < 整数32 > を  おく  。 
		uvIndices という 配列 < 整数32 > を  おく  。 
		normals という 配列 < ベクトル3D > を  おく  。 
		lines の 長さ ( ) 回繰り返す ここから
			line という 文字列 を lines の 取得 ( カウンタ ) で  初期化  。 
			words という 配列 < 文字列 > を line の 分割 ( ' ') で  初期化  。 
			もし words の 取得 ( 0 )  は "v"ならば ここから
				temp という ベクトル3D の  オブジェクト  を words の 取得 ( 1 ) の 実数変換 ( ) , words の 取得 ( 2 ) の 実数変換 ( ) , words の 取得 ( 3 ) の 実数変換 ( ) で  初期化  。 
				temp vertices の 追加 する  。 
			ここまで実行 
			もし words の 取得 ( 0 )  は "f"ならば ここから
				words の 長さ ( ) 回繰り返す ここから
					もし カウンタ  != 0 ならば ここから
						faceData という 配列 < 文字列 > を words の 取得 ( カウンタ ) の 分割 ( '/') で  初期化  。 
						faceData の 取得 ( 0 ) の 整数変換 ( ) vertexIndices の 追加 する  。 
						もし faceData の 長さ ( )  は 3 ならば ここから
							faceData の 取得 ( 1 ) の 整数変換 ( ) uvIndices の 追加 する  。 
							faceData の 取得 ( 2 ) の 整数変換 ( ) normalIndices の 追加 する  。 
						ここまで実行 
					ここまで実行 
				ここまで実行 
			ここまで実行 
			もし words の 取得 ( 0 )  は "vn"ならば ここから
				temp という ベクトル3D の  オブジェクト  を words の 取得 ( 1 ) の 実数変換 ( ) , words の 取得 ( 2 ) の 実数変換 ( ) , words の 取得 ( 3 ) の 実数変換 ( ) で  初期化  。 
				temp normals の 追加 する  。 
			ここまで実行 
		ここまで実行 
		id に _モデル追加 ( vertices , normals , vertexIndices , normalIndices , 色 , 座標 ) を  代入する  。 
	ここまで実行 
非公開 : 	projMat という 行列4x4 を  おく  。 
	viewMat という 行列4x4 を  おく  。 
	last という 実数 を  おく  。 
	now という 実数 を  おく  。 
	elapsedTime という 実数 を  おく  。 
	lastX という 実数 を  おく  。 
	lastY という 実数 を  おく  。 
} 
クラス : ${"ja":"ベクトル2D", "natja":"ベクトル2D", "en":"Vector2D", "naten":"Vector2D"}$ {
公開 : 	x という 実数 を  おく  。 
	y という 実数 を  おく  。 
	( a という 実数 , b という 実数 ) を  とり ベクトル2D という  関数  を  おく  。 ここから
		x に a を  代入する  。 
		y に b を  代入する  。 
	ここまで実行 
	( l という 実数 ) を  返す ${"ja":"長さ", "natja":"長さ", "en":"length", "naten":"length"}$ という  関数  を  おく  。 ここから
		l に 平方根 ( x  * x  + y  * y ) を  代入する  。 
	ここまで実行 
	関数 ${"ja":"正規化", "natja":"正規化", "en":"normalize", "naten":"normalize"}$ を  おく  。 ここから
		l という 実数 を 平方根 ( x  * x  + y  * y ) で  初期化  。 
		x に x  / l を  代入する  。 
		y に y  / l を  代入する  。 
	ここまで実行 
	関数 : 演算子  + ( a という ベクトル2D ) => ( b という ベクトル2D ) ここから
		b の x に a の x  + x を  代入する  。 
		b の y に a の y  + y を  代入する  。 
	ここまで実行 
	関数 : 演算子  - ( a という ベクトル2D ) => ( b という ベクトル2D ) ここから
		b の x に x  - a の x を  代入する  。 
		b の y に y  - a の y を  代入する  。 
	ここまで実行 
	関数 : 演算子  * ( k という 実数 ) => ( b という ベクトル2D ) ここから
		b の x に x  * k を  代入する  。 
		b の y に y  * k を  代入する  。 
	ここまで実行 
	関数 : 演算子  / ( k という 実数 ) => ( b という ベクトル2D ) ここから
		b の x に x  / k を  代入する  。 
		b の y に y  / k を  代入する  。 
	ここまで実行 
	関数 : 演算子  は ( a という ベクトル2D ) => ( b という 真偽 ) ここから
		b に ( ( a の x  は x )  && ( a の y  は y ) ) を  代入する  。 
	ここまで実行 
	関数 : 演算子  != ( a という ベクトル2D ) => ( b という 真偽 ) ここから
		b に ( ( a の x  != x )  || ( a の y  != y ) ) を  代入する  。 
	ここまで実行 
} 
( a という ベクトル2D , b という ベクトル2D ) を  とり ( result という ベクトル2D ) を  返す ${"ja":"ベクトル2Dの和", "natja":"ベクトル2Dの和", "en":"addVector2D", "naten":"addVector2D"}$ という  関数  を  おく  。 ここから
	result の x に a の x  + b の x を  代入する  。 
	result の y に a の y  + b の y を  代入する  。 
ここまで実行 
( a という ベクトル2D , b という ベクトル2D ) を  とり ( result という ベクトル2D ) を  返す ${"ja":"ベクトル2Dの差", "natja":"ベクトル2Dの差", "en":"subVector2D", "naten":"subVector2D"}$ という  関数  を  おく  。 ここから
	result の x に a の x  - b の x を  代入する  。 
	result の y に a の y  - b の y を  代入する  。 
ここまで実行 
( a という ベクトル2D , b という ベクトル2D ) を  とり ( x という 実数 ) を  返す ${"ja":"ベクトル2Dの内積", "natja":"ベクトル2Dの内積", "en":"dotVector2D", "naten":"dotVector2D"}$ という  関数  を  おく  。 ここから
	x に a の x  * b の x  + a の y  * b の y を  代入する  。 
ここまで実行 
( a という ベクトル2D , x という 実数 ) を  とり ( result という ベクトル2D ) を  返す ${"ja":"ベクトル2D拡大", "natja":"ベクトル2D拡大", "en":"extendVector2D", "naten":"extendVector2D"}$ という  関数  を  おく  。 ここから
	result の x に a の x  * x を  代入する  。 
	result の y に a の y  * x を  代入する  。 
ここまで実行 
( a という ベクトル2D , x という 実数 ) を  とり ( result という ベクトル2D ) を  返す ${"ja":"ベクトル2D縮小", "natja":"ベクトル2D縮小", "en":"divVector2D", "naten":"divVector2D"}$ という  関数  を  おく  。 ここから
	もし x  は 0.0 ならば ここから
		10000000 表示 する  。 
	ここまで実行 
	result の x に a の x  / x を  代入する  。 
	result の y に a の y  / x を  代入する  。 
ここまで実行 
クラス : ${"ja":"アニメーション情報", "natja":"アニメーション情報", "en":"AnimationInfo", "naten":"AnimationInfo"}$ {
公開 : 	id という 整数 を  おく  。 
	startTime という 実数 を  おく  。 
	duration という 実数 を  おく  。 
	info という ベクトル2D を  おく  。 
	( a という 整数 , start という 実数 , d という 実数 , x という 実数 , y という 実数 ) を  とり アニメーション情報 という  関数  を  おく  。 ここから
		id に a を  代入する  。 
		startTime に start を  代入する  。 
		duration に d を  代入する  。 
		info の x に x を  代入する  。 
		info の y に y を  代入する  。 
	ここまで実行 
	関数 アニメーション情報 を  おく  。 ここから
		id に 0 を  代入する  。 
		startTime に 0 を  代入する  。 
		duration に 0 を  代入する  。 
		info の x に 0 を  代入する  。 
		info の y に 0 を  代入する  。 
	ここまで実行 
	関数 : 演算子  は ( a という アニメーション情報 ) => ( b という 真偽 ) ここから
		b に ( ( a の id  は id )  && ( a の startTime  は startTime )  && ( a の duration  は duration )  && ( a の info  は info )  && ( a の info  は info ) ) を  代入する  。 
	ここまで実行 
	関数 : 演算子  != ( a という アニメーション情報 ) => ( b という 真偽 ) ここから
		b に ( ( a の id  != id )  || ( a の startTime  != startTime )  || ( a の duration  != duration )  || ( a の info  != info )  || ( a の info  != info ) ) を  代入する  。 
	ここまで実行 
} 
クラス : ${"ja":"スプライト", "natja":"スプライト", "en":"Sprite", "naten":"Sprite"}$ {
公開 : 	色 という ベクトル3D を  おく  。 
	座標 という ベクトル2D を  おく  。 
	( data という * 実数 , pnum という 整数 , indicesData という * 整数32 , vnum という 整数 , c という ベクトル3D , p という ベクトル2D , s という 整数 , st という 整数 , zI という 実数 ) を  とり スプライト という  関数  を  おく  。 ここから
		vertices に data を  代入する  。 
		pointNum に pnum を  代入する  。 
		indices に indicesData を  代入する  。 
		vertexNum に vnum を  代入する  。 
		zIndex に zI を  代入する  。 
		透明度 に 1.0 を  代入する  。 
		spriteType に st を  代入する  。 
		色 に c を  代入する  。 
		座標 に p を  代入する  。 
		scaleX に 1.0 を  代入する  。 
		scaleY に 1.0 を  代入する  。 
		theta に 0.0 を  代入する  。 
		shaderID に s を  代入する  。 
		animations の 配列 する  。 
		modelMat の 単位化 する  。 
		transMat の 単位化 する  。 
		scaleMat の 単位化 する  。 
		rotateMat の 単位化 する  。 
		projMatUniformLoc に glGetUniformLocation ( shaderID , "projection") を  代入する  。 
		modelMatUniformLoc に glGetUniformLocation ( shaderID , "model") を  代入する  。 
		もし shaderID  は 4 ならば ここから
			transparencyUniLoc に glGetUniformLocation ( shaderID , "transparency") を  代入する  。 
			objectColorUniLoc に glGetUniformLocation ( shaderID , "objectColor") を  代入する  。 
		ここまで実行 
		もし shaderID  は 3 ならば ここから
			samplerUniformLoc に glGetUniformLocation ( shaderID , "uSampler") を  代入する  。 
		ここまで実行 
		buffer に glCreateBuffer ( ) を  代入する  。 
		34962 , buffer glBindBuffer する  。 
		34962 , vertices , pnum  * 3 , 35044 glBufferData する  。 
		もし vnum  > 0 ならば ここから
			elementBuffer に glCreateBuffer ( ) を  代入する  。 
			34963 , elementBuffer glBindBuffer する  。 
			34963 , indices , vnum , 35044 glElementBufferData する  。 
		ここまで実行 
	ここまで実行 
	( tex という * 実数 , url という 文字列 ) を  とり ${"ja":"テクスチャ設定", "natja":"テクスチャ設定", "en":"setTexture", "naten":"setTexture"}$ という  関数  を  おく  。 ここから
		shaderID に 0 を  代入する  。 
		texCoords に tex を  代入する  。 
		texture に テクスチャロード ( url の content , url の 長さ ) を  代入する  。 
		url の content , url の 長さ _文字列表示 する  。 
		texCoordBuffer に glCreateBuffer ( ) を  代入する  。 
		34962 , texCoordBuffer glBindBuffer する  。 
		34962 , tex , vertexNum  * 2 , 35044 glBufferData する  。 
	ここまで実行 
	( tex という * 実数 , テクスチャ という 整数32 ) を  とり ${"ja":"リピートテクスチャ設定", "natja":"リピートテクスチャ設定", "en":"setRepeatTexture", "naten":"setRepeatTexture"}$ という  関数  を  おく  。 ここから
		shaderID に 0 を  代入する  。 
		texCoords に tex を  代入する  。 
		texture に テクスチャ を  代入する  。 
		texCoordBuffer に glCreateBuffer ( ) を  代入する  。 
		34962 , texCoordBuffer glBindBuffer する  。 
		34962 , tex , vertexNum  * 2 , 35044 glBufferData する  。 
	ここまで実行 
	( coord という ベクトル2D ) を  とり ${"ja":"座標設定", "natja":"座標設定", "en":"setPos", "naten":"setPos"}$ という  関数  を  おく  。 ここから
		座標 に coord を  代入する  。 
	ここまで実行 
	( offset という ベクトル2D ) を  とり ${"ja":"移動", "natja":"移動", "en":"translate", "naten":"translate"}$ という  関数  を  おく  。 ここから
		座標 に ベクトル2Dの和 ( 座標 , offset ) を  代入する  。 
	ここまで実行 
	( x という 実数 , y という 実数 ) を  とり ${"ja":"拡大縮小", "natja":"拡大縮小", "en":"scale", "naten":"scale"}$ という  関数  を  おく  。 ここから
		scaleX に scaleX  * x を  代入する  。 
		scaleY に scaleY  * y を  代入する  。 
	ここまで実行 
	( x という 実数 , y という 実数 ) を  とり ${"ja":"拡大縮小設定", "natja":"拡大縮小設定", "en":"setScale", "naten":"setScale"}$ という  関数  を  おく  。 ここから
		scaleX に x を  代入する  。 
		scaleY に y を  代入する  。 
	ここまで実行 
	( t という 実数 ) を  とり ${"ja":"回転", "natja":"回転", "en":"rotate", "naten":"rotate"}$ という  関数  を  おく  。 ここから
		theta に theta  + t を  代入する  。 
	ここまで実行 
	( t という 実数 ) を  とり ${"ja":"角度設定", "natja":"角度設定", "en":"setRotation", "naten":"setRotation"}$ という  関数  を  おく  。 ここから
		theta に t を  代入する  。 
	ここまで実行 
	( x という 実数 ) を  とり ${"ja":"重なり順設定", "natja":"重なり順設定", "en":"setZIndex", "naten":"setZIndex"}$ という  関数  を  おく  。 ここから
		zIndex に x を  代入する  。 
	ここまで実行 
	( x という 実数 ) を  とり ${"ja":"透明度設定", "natja":"透明度設定", "en":"setTransparency", "naten":"setTransparency"}$ という  関数  を  おく  。 ここから
		透明度 に x を  代入する  。 
	ここまで実行 
	( 色 という ベクトル3D ) を  とり ${"ja":"色設定", "natja":"色設定", "en":"setColor", "naten":"setColor"}$ という  関数  を  おく  。 ここから
		色 に 色 を  代入する  。 
	ここまで実行 
	( projMat という 行列4x4 ) を  とり ${"ja":"描画", "natja":"描画", "en":"draw", "naten":"draw"}$ という  関数  を  おく  。 ここから
		PI という 実数 を 3.14159265358979312 で  初期化  。 
		( カウンタ という 整数 を 0 で  初期化  。 ) から ( カウンタ  は animations の size ) まで ( カウンタ に カウンタ  + 1 を  代入する  。 ) 繰り返し ここから
			info という アニメーション情報 を animations の 取得 ( カウンタ ) で  初期化  。 
			もし ( info の startTime  <= 時間計測 ( ) )  && ( ( info の startTime  + info の duration )  >= 時間計測 ( ) ) ならば ここから
				もし info の id  は 0 ならば ここから
					elapsedTime という 実数 を 時間計測 ( )  - info の startTime で  初期化  。 
					info の info の x  * elapsedTime 回転 する  。 
				ここまで実行 
				もし info の id  は 1 ならば ここから
					info の info の x , info の info の y 拡大縮小 する  。 
				ここまで実行 
				もし info の id  は 2 ならば ここから
					elapsedTime という 実数 を 時間計測 ( )  - info の startTime で  初期化  。 
					offset という ベクトル2D の  オブジェクト  を info の info の x  * elapsedTime , info の info の y  * elapsedTime で  初期化  。 
					offset 移動 する  。 
				ここまで実行 
			ここまで実行 
		ここまで実行 
		pos3d という ベクトル3D の  オブジェクト  を 座標 の x , 座標 の y , 0  - zIndex  * 0.00100000000000000002 で  初期化  。 
		transMat の 単位化 する  。 
		pos3d transMat の 移動 する  。 
		scaleMat の 単位化 する  。 
		scaleX , scaleY , 1.0 scaleMat の 拡大縮小 する  。 
		回転軸 という ベクトル3D の  オブジェクト  を 0.0 , 0.0 , 1.0 で  初期化  。 
		rotateMat の 単位化 する  。 
		回転軸 , theta rotateMat の 回転 する  。 
		modelMat の 単位化 する  。 
		modelMat に 行列4x4の積 ( scaleMat , modelMat ) を  代入する  。 
		modelMat に 行列4x4の積 ( rotateMat , modelMat ) を  代入する  。 
		modelMat に 行列4x4の積 ( transMat , modelMat ) を  代入する  。 
		shaderID glUseProgram する  。 
		34962 , buffer glBindBuffer する  。 
		0 glEnableVertexAttribArray する  。 
		0 , 3 , 5126 , 0 , 0 , 0 glVertexAttribPointer する  。 
		もし shaderID  は 4 ならば ここから
			transparencyUniLoc , 透明度 glUniform1f する  。 
			objectColorUniLoc , 色 の x , 色 の y , 色 の z glUniform3f する  。 
		ここまで実行 
		もし shaderID  は 3 ならば ここから
			34962 , texCoordBuffer glBindBuffer する  。 
			1 glEnableVertexAttribArray する  。 
			1 , 2 , 5126 , 0 , 0 , 0 glVertexAttribPointer する  。 
			texture  + 33984 glActiveTexture する  。 
			3553 , texture glBindTexture する  。 
			samplerUniformLoc , texture glUniform1i する  。 
		ここまで実行 
		projMatUniformLoc , 0 , projMat の matrix glUniformMatrix4fv する  。 
		modelMatUniformLoc , 0 , modelMat の matrix glUniformMatrix4fv する  。 
		もし spriteType  は 1 ならば ここから
			34962 , buffer glBindBuffer する  。 
			3 , 0 , pointNum glDrawArrays する  。 
		ここまで実行 でなければ ここから
			もし vertexNum  > 0 ならば ここから
				34963 , elementBuffer glBindBuffer する  。 
				4 , vertexNum , 5123 , 0 glDrawElements する  。 
			ここまで実行 
			もし ( vertexNum  は 0 )  && ( shaderID  は 4 ) ならば ここから
				34962 , buffer glBindBuffer する  。 
				5 , 0 , pointNum glDrawArrays する  。 
			ここまで実行 
		ここまで実行 
		rotateMat の 単位化 する  。 
		transMat の 単位化 する  。 
		scaleMat の 単位化 する  。 
	ここまで実行 
	( theta という 実数 , start という 実数 , duration という 実数 ) を  とり ${"ja":"回転アニメーション", "natja":"回転アニメーション", "en":"rotateAnimation", "naten":"rotateAnimation"}$ という  関数  を  おく  。 ここから
		temp という アニメーション情報 の  オブジェクト  を 0 , start , duration , theta , 0.0 で  初期化  。 
		temp animations の 追加 する  。 
	ここまで実行 
	( x という 実数 , y という 実数 , start という 実数 , duration という 実数 ) を  とり ${"ja":"拡大縮小アニメーション", "natja":"拡大縮小アニメーション", "en":"scaleAnimation", "naten":"scaleAnimation"}$ という  関数  を  おく  。 ここから
		temp という アニメーション情報 の  オブジェクト  を 1 , start , duration , x , y で  初期化  。 
		temp animations の 追加 する  。 
	ここまで実行 
	( offset という ベクトル2D , start という 実数 , duration という 実数 ) を  とり ${"ja":"移動アニメーション", "natja":"移動アニメーション", "en":"translateAnimation", "naten":"translateAnimation"}$ という  関数  を  おく  。 ここから
		temp という アニメーション情報 の  オブジェクト  を 0 , start , duration , offset の x , offset の y で  初期化  。 
		temp animations の 追加 する  。 
	ここまで実行 
非公開 : 	vertices という * 実数 を  おく  。 
	indices という * 整数32 を  おく  。 
	texCoords という * 実数 を  おく  。 
	vertexNum という 整数 を  おく  。 
	pointNum という 整数 を  おく  。 
	buffer という 整数32 を  おく  。 
	texCoordBuffer という 整数32 を  おく  。 
	elementBuffer という 整数32 を  おく  。 
	texture という 整数32 を  おく  。 
	modelMat という 行列4x4 を  おく  。 
	transMat という 行列4x4 を  おく  。 
	scaleMat という 行列4x4 を  おく  。 
	rotateMat という 行列4x4 を  おく  。 
	zIndex という 実数 を  おく  。 
	shaderID という 整数 を  おく  。 
	objectColorUniLoc という 整数32 を  おく  。 
	transparencyUniLoc という 整数32 を  おく  。 
	projMatUniformLoc という 整数32 を  おく  。 
	modelMatUniformLoc という 整数32 を  おく  。 
	samplerUniformLoc という 整数32 を  おく  。 
	animations という 配列 < アニメーション情報 > を  おく  。 
	透明度 という 実数 を  おく  。 
	scaleX という 実数 を  おく  。 
	scaleY という 実数 を  おく  。 
	theta という 実数 を  おく  。 
	spriteType という 整数 を  おく  。 
} 
クラス : ${"ja":"シーン2D", "natja":"シーン2D", "en":"Scene2D", "naten":"Scene2D"}$ {
公開 : 	${"ja":"スプライト配列", "natja":"スプライト配列", "en":"sprites", "naten":"sprites"}$ という 配列 < * スプライト > を  おく  。 
	${"ja":"背景色", "natja":"背景色", "en":"backgroundColor", "naten":"backgroundColor"}$ という ベクトル3D を  おく  。 
	${"ja":"背景透明度", "natja":"背景透明度", "en":"backgroundTransparency", "naten":"backgroundTransparency"}$ という 実数 を  おく  。 
	zoom という 実数 を  おく  。 
	( 高さ という 実数 , 色 という ベクトル3D ) を  とり シーン2D という  関数  を  おく  。 ここから
		zoom に 100.0 を  代入する  。 
		last に 時間計測 ( )  / 1000.0 を  代入する  。 
		now に 0.0 を  代入する  。 
		elapsedTime に 0.0 を  代入する  。 
		projMat の 単位化 する  。 
		projMat に 視点行列2D ( projMat , ( ( 0  - ( 高さ ) ) )  * ( 16.0  / 9.0 ) , ( 高さ )  * ( 16.0  / 9.0 ) , ( 0  - ( 高さ ) ) , 高さ , 0.0  - 5.0 , 5.0 ) を  代入する  。 
		スプライト配列 の 配列 する  。 
		背景色 に 色 を  代入する  。 
		背景透明度 に 1.0 を  代入する  。 
	ここまで実行 
	( a という 実数 ) を  とり ${"ja":"背景透明度設定", "natja":"背景透明度設定", "en":"setBackgroundTransparency", "naten":"setBackgroundTransparency"}$ という  関数  を  おく  。 ここから
		背景透明度 に a を  代入する  。 
	ここまで実行 
	関数 ${"ja":"描画", "natja":"描画", "en":"draw", "naten":"draw"}$ を  おく  。 ここから
		zoom に zoom  + スクロール座標 ( ) を  代入する  。 
		もし zoom  > 400.0 ならば ここから
			zoom に 400.0 を  代入する  。 
		ここまで実行 
		もし zoom  < 8.0 ならば ここから
			zoom に 8.0 を  代入する  。 
		ここまで実行 
		now に 時間計測 ( )  / 1000.0 を  代入する  。 
		elapsedTime に now  - last を  代入する  。 
		last に now を  代入する  。 
		背景色 の x , 背景色 の y , 背景色 の z , 背景透明度 glClearColor する  。 
		1.0 glClearDepth する  。 
		2929 glEnable する  。 
		515 glDepthFunc する  。 
		3042 glEnable する  。 
		770 , 771 glBlendFunc する  。 
		16640 glClear する  。 
		( i という 整数 を 0 で  初期化  。 ) から ( i  は スプライト配列 の size ) まで ( i に i  + 1 を  代入する  。 ) 繰り返し ここから
			1.0  / ( zoom  * 0.0100000000000000002 ) , 1.0  / ( zoom  * 0.0100000000000000002 ) スプライト配列 の 取得 ( i ) -> 拡大縮小設定 する  。 
			projMat スプライト配列 の 取得 ( i ) -> 描画 する  。 
		ここまで実行 
	ここまで実行 
	( size という 実数 , 座標 という ベクトル2D , 色 という ベクトル3D , zIndex という 実数 ) を  とり ( id という 整数 ) を  返す ${"ja":"正方形追加", "natja":"正方形追加", "en":"addSquare", "naten":"addSquare"}$ という  関数  を  おく  。 ここから
		vertices [ 4 ] [ 3 ] という 実数 を [ [ size  / 2 , size  / 2 , 0  - zIndex  * 0.00100000000000000002 ] , [ size  / 2 , 0  - size  / 2 , 0  - zIndex  * 0.00100000000000000002 ] , [ 0  - size  / 2 , 0  - size  / 2 , 0  - zIndex  * 0.00100000000000000002 ] , [ 0  - size  / 2 , size  / 2 , 0  - zIndex  * 0.00100000000000000002 ] ] で  初期化  。 
		texCoords [ 4 ] [ 2 ] という 実数 を [ [ 1.0 , 0.0 ] , [ 1.0 , 1.0 ] , [ 0.0 , 1.0 ] , [ 0.0 , 0.0 ] ] で  初期化  。 
		indices [ 6 ] という 整数32 を [ 0 , 1 , 3 , 1 , 2 , 3 ] で  初期化  。 
		sprite という * スプライト を メモリ確保 ( バイト数 ( sprite に  ある  オブジェクト ) ) で  初期化  。 
		& vertices , 4 , & indices , 6 , 色 , 座標 , 4 , 0 , zIndex sprite -> スプライト する  。 
		sprite スプライト配列 の 追加 する  。 
		id に スプライト配列 の 長さ ( )  - 1 を  代入する  。 
	ここまで実行 
	( width という 実数 , height という 実数 , 座標 という ベクトル2D , url という 文字列 , zIndex という 実数 ) を  とり ( id という 整数 ) を  返す ${"ja":"スプライト追加", "natja":"スプライト追加", "en":"addSprite", "naten":"addSprite"}$ という  関数  を  おく  。 ここから
		vertices [ 4 ] [ 3 ] という 実数 を [ [ width  / 2 , height  / 2 , 0  - zIndex  * 0.00100000000000000002 ] , [ width  / 2 , 0  - height  / 2 , 0  - zIndex  * 0.00100000000000000002 ] , [ 0  - width  / 2 , 0  - height  / 2 , 0  - zIndex  * 0.00100000000000000002 ] , [ 0  - width  / 2 , height  / 2 , 0  - zIndex  * 0.00100000000000000002 ] ] で  初期化  。 
		texCoords [ 4 ] [ 2 ] という 実数 を [ [ 1.0 , 0.0 ] , [ 1.0 , 1.0 ] , [ 0.0 , 1.0 ] , [ 0.0 , 0.0 ] ] で  初期化  。 
		indices [ 6 ] という 整数32 を [ 0 , 1 , 3 , 1 , 2 , 3 ] で  初期化  。 
		色 という ベクトル3D の  オブジェクト  を 0.0 , 0.0 , 0.0 で  初期化  。 
		sprite という * スプライト を メモリ確保 ( バイト数 ( sprite に  ある  オブジェクト ) ) で  初期化  。 
		& vertices , 4 , & indices , 6 , 色 , 座標 , 3 , 0 , zIndex sprite -> スプライト する  。 
		& texCoords , url sprite -> テクスチャ設定 する  。 
		sprite スプライト配列 の 追加 する  。 
		id に スプライト配列 の 長さ ( )  - 1 を  代入する  。 
	ここまで実行 
	( width という 実数 , height という 実数 , 座標 という ベクトル2D , texture という 整数32 , zIndex という 実数 ) を  とり ( id という 整数 ) を  返す ${"ja":"リピートスプライト追加", "natja":"リピートスプライト追加", "en":"addRepeatSprite", "naten":"addRepeatSprite"}$ という  関数  を  おく  。 ここから
		vertices [ 4 ] [ 3 ] という 実数 を [ [ width  / 2 , height  / 2 , 0  - zIndex  * 0.00100000000000000002 ] , [ width  / 2 , 0  - height  / 2 , 0  - zIndex  * 0.00100000000000000002 ] , [ 0  - width  / 2 , 0  - height  / 2 , 0  - zIndex  * 0.00100000000000000002 ] , [ 0  - width  / 2 , height  / 2 , 0  - zIndex  * 0.00100000000000000002 ] ] で  初期化  。 
		texCoords [ 4 ] [ 2 ] という 実数 を [ [ 1.0 , 0.0 ] , [ 1.0 , 1.0 ] , [ 0.0 , 1.0 ] , [ 0.0 , 0.0 ] ] で  初期化  。 
		indices [ 6 ] という 整数32 を [ 0 , 1 , 3 , 1 , 2 , 3 ] で  初期化  。 
		色 という ベクトル3D の  オブジェクト  を 0.0 , 0.0 , 0.0 で  初期化  。 
		sprite という * スプライト を メモリ確保 ( バイト数 ( sprite に  ある  オブジェクト ) ) で  初期化  。 
		& vertices , 4 , & indices , 6 , 色 , 座標 , 3 , 0 , zIndex sprite -> スプライト する  。 
		& texCoords , texture sprite -> リピートテクスチャ設定 する  。 
		sprite スプライト配列 の 追加 する  。 
		id に スプライト配列 の 長さ ( )  - 1 を  代入する  。 
	ここまで実行 
	( width という 実数 , height という 実数 , 座標 という ベクトル2D , 色 という ベクトル3D , zIndex という 実数 ) を  とり ( id という 整数 ) を  返す ${"ja":"四角形追加", "natja":"四角形追加", "en":"addRectangle", "naten":"addRectangle"}$ という  関数  を  おく  。 ここから
		vertices [ 4 ] [ 3 ] という 実数 を [ [ width  / 2 , height  / 2 , 0  - zIndex  * 0.00100000000000000002 ] , [ 0  - width  / 2 , height  / 2 , 0  - zIndex  * 0.00100000000000000002 ] , [ width  / 2 , 0  - height  / 2 , 0  - zIndex  * 0.00100000000000000002 ] , [ 0  - width  / 2 , 0  - height  / 2 , 0  - zIndex  * 0.00100000000000000002 ] ] で  初期化  。 
		sprite という * スプライト を メモリ確保 ( バイト数 ( sprite に  ある  オブジェクト ) ) で  初期化  。 
		& vertices , 4 , メモリ確保 ( 0 ) , 0 , 色 , 座標 , 4 , 0 , zIndex sprite -> スプライト する  。 
		sprite スプライト配列 の 追加 する  。 
		id に スプライト配列 の 長さ ( )  - 1 を  代入する  。 
	ここまで実行 
	( points という 配列 < ベクトル2D > , 座標 という ベクトル2D , 色 という ベクトル3D , zIndex という 実数 ) を  とり ( id という 整数 ) を  返す ${"ja":"多角形追加", "natja":"多角形追加", "en":"addPolygon", "naten":"addPolygon"}$ という  関数  を  おく  。 ここから
		temp という 配列 < 実数 > を  おく  。 
		points の 長さ ( ) 回繰り返す ここから
			points の content [ カウンタ ] の x temp の 追加 する  。 
			points の content [ カウンタ ] の y temp の 追加 する  。 
			( 0  - ( zIndex  * 0.00100000000000000002 ) ) temp の 追加 する  。 
		ここまで実行 
		sprite という * スプライト を メモリ確保 ( バイト数 ( sprite に  ある  オブジェクト ) ) で  初期化  。 
		temp の content , temp の 長さ ( )  / 3 , メモリ確保 ( 0 ) , 0 , 色 , 座標 , 4 , 0 , zIndex sprite -> スプライト する  。 
		sprite スプライト配列 の 追加 する  。 
		id に スプライト配列 の 長さ ( )  - 1 を  代入する  。 
	ここまで実行 
	( r という 実数 , 座標 という ベクトル2D , 色 という ベクトル3D , zIndex という 実数 ) を  とり ( id という 整数 ) を  返す ${"ja":"円追加", "natja":"円追加", "en":"addCircle", "naten":"addCircle"}$ という  関数  を  おく  。 ここから
		PI という 実数 を 3.14159265358979312 で  初期化  。 
		points という 配列 < ベクトル2D > を  おく  。 
		頂点数 という 整数 を 60 で  初期化  。 
		( i という 整数 を 0 で  初期化  。 ) から ( i  は 頂点数 ) まで ( i に i  + 1 を  代入する  。 ) 繰り返し ここから
			theta という 実数 を 0 で  初期化  。 
			もし ( i  % 2 )  は 0 ならば ここから
				theta に 0.5  * PI  + ( ( PI  * i )  / 頂点数 ) を  代入する  。 
			ここまで実行 
			もし ( i  % 2 )  は 1 ならば ここから
				theta に 0.5  * PI  - ( ( PI  * ( 1.0  + i ) )  / 頂点数 ) を  代入する  。 
			ここまで実行 
			temp という ベクトル2D の  オブジェクト  を r  * cos ( theta ) , r  * sin ( theta ) で  初期化  。 
			temp points の 追加 する  。 
		ここまで実行 
		id に 多角形追加 ( points , 座標 , 色 , zIndex ) を  代入する  。 
	ここまで実行 
	( start という ベクトル2D , end という ベクトル2D , 色 という ベクトル3D , zIndex という 実数 ) を  とり ( id という 整数 ) を  返す ${"ja":"線追加", "natja":"線追加", "en":"addLine", "naten":"addLine"}$ という  関数  を  おく  。 ここから
		points という 配列 < 実数 > を  おく  。 
		start の x points の 追加 する  。 
		start の y points の 追加 する  。 
		( 0  - ( zIndex  * 0.00100000000000000002 ) ) points の 追加 する  。 
		end の x points の 追加 する  。 
		end の y points の 追加 する  。 
		( 0  - ( zIndex  * 0.00100000000000000002 ) ) points の 追加 する  。 
		sprite という * スプライト を メモリ確保 ( バイト数 ( sprite に  ある  オブジェクト ) ) で  初期化  。 
		points の content , points の 長さ ( )  / 3 , メモリ確保 ( 0 ) , 0 , 色 , ベクトル2D ( 0.0 , 0.0 ) , 4 , 1 , zIndex sprite -> スプライト する  。 
		sprite スプライト配列 の 追加 する  。 
		id に スプライト配列 の 長さ ( )  - 1 を  代入する  。 
	ここまで実行 
	( c という 関数 : ( a という 実数 ) => ( b という 実数 ) , dx という 実数 , start という 実数 , end という 実数 , 座標 という ベクトル2D , 色 という ベクトル3D , zIndex という 実数 ) を  とり ( id という 整数 ) を  返す ${"ja":"線追加", "natja":"線追加", "en":"addLine", "naten":"addLine"}$ という  関数  を  おく  。 ここから
		points という 配列 < 実数 > を  おく  。 
		( x という 実数 を start で  初期化  。 ) から ( x  >= end ) まで ( x に x  + dx を  代入する  。 ) 繰り返し ここから
			x points の 追加 する  。 
			c ( x ) points の 追加 する  。 
			( 0  - ( zIndex  * 0.00100000000000000002 ) ) points の 追加 する  。 
		ここまで実行 
		sprite という * スプライト を メモリ確保 ( バイト数 ( sprite に  ある  オブジェクト ) ) で  初期化  。 
		points の content , points の 長さ ( )  / 3 , メモリ確保 ( 0 ) , 0 , 色 , 座標 , 4 , 1 , zIndex sprite -> スプライト する  。 
		sprite スプライト配列 の 追加 する  。 
		id に スプライト配列 の 長さ ( )  - 1 を  代入する  。 
	ここまで実行 
	( c という 関数 : ( theta という 実数 ) => ( pos という ベクトル2D ) , dx という 実数 , start という 実数 , end という 実数 , 座標 という ベクトル2D , 色 という ベクトル3D , zIndex という 実数 ) を  とり ( id という 整数 ) を  返す ${"ja":"媒介変数表示線追加", "natja":"媒介変数表示線追加", "en":"addLine", "naten":"addLine"}$ という  関数  を  おく  。 ここから
		points という 配列 < 実数 > を  おく  。 
		( x という 実数 を start で  初期化  。 ) から ( x  >= end ) まで ( x に x  + dx を  代入する  。 ) 繰り返し ここから
			temp という ベクトル2D を c ( x ) で  初期化  。 
			temp の x points の 追加 する  。 
			temp の y points の 追加 する  。 
			( 0  - ( zIndex  * 0.00100000000000000002 ) ) points の 追加 する  。 
		ここまで実行 
		sprite という * スプライト を メモリ確保 ( バイト数 ( sprite に  ある  オブジェクト ) ) で  初期化  。 
		points の content , points の 長さ ( )  / 3 , メモリ確保 ( 0 ) , 0 , 色 , 座標 , 4 , 1 , zIndex sprite -> スプライト する  。 
		sprite スプライト配列 の 追加 する  。 
		id に スプライト配列 の 長さ ( )  - 1 を  代入する  。 
	ここまで実行 
非公開 : 	projMat という 行列4x4 を  おく  。 
	last という 実数 を  おく  。 
	now という 実数 を  おく  。 
	elapsedTime という 実数 を  おく  。 
} 
( callback という 関数 : ( ) => ( ) ) を  とり 引数なしjsリスナー呼び出し という  関数  を  おく  。 ここから
	callback する  。 
ここまで実行 
js書き出し ( 引数なしjsリスナー呼び出し , "jsCallListenerNoParam") 。 
関数 __setUpVariableNamesForSamples を  おく  。 ここから
	${"ja":"前の数", "natja":"前の数", "en":"numberBefore", "naten":"numberBefore"}$ という 実数 を  おく  。 
	${"ja":"数", "natja":"数", "en":"number", "naten":"number"}$ という 実数 を  おく  。 
	${"ja":"入力", "natja":"入力", "en":"input", "naten":"input"}$ という 実数 を  おく  。 
	${"ja":"出力", "natja":"出力", "en":"output", "naten":"output"}$ という 実数 を  おく  。 
	${"ja":"返り値", "natja":"返り値", "en":"returnValue", "naten":"returnValue"}$ という 実数 を  おく  。 
	${"ja":"初期数", "natja":"初期数", "en":"initialNumber", "naten":"initialNumber"}$ という 実数 を  おく  。 
	${"ja":"コラッツ", "natja":"コラッツ", "en":"collatz", "naten":"collatz"}$ という 実数 を  おく  。 
	${"ja":"結果", "natja":"結果", "en":"result", "naten":"result"}$ という 実数 を  おく  。 
	${"ja":"かける数", "natja":"かける数", "en":"numberToMultiply", "naten":"numberToMultiply"}$ という 実数 を  おく  。 
	${"ja":"ワールド", "natja":"ワールド", "en":"world", "naten":"world"}$ という 実数 を  おく  。 
	${"ja":"光源座標", "natja":"光源座標", "en":"lightPosition", "naten":"lightPosition"}$ という 実数 を  おく  。 
	${"ja":"回転軸", "natja":"回転軸", "en":"axis", "naten":"axis"}$ という 実数 を  おく  。 
	${"ja":"位置", "natja":"位置", "en":"position", "naten":"position"}$ という 実数 を  おく  。 
	${"ja":"キューブID", "natja":"キューブID", "en":"cubeID", "naten":"cubeID"}$ という 実数 を  おく  。 
	${"ja":"光源ID", "natja":"光源ID", "en":"lightID", "naten":"lightID"}$ という 実数 を  おく  。 
	${"ja":"キューブIDリスト", "natja":"キューブIDリスト", "en":"cubeIDlist", "naten":"cubeIDlist"}$ という 実数 を  おく  。 
	${"ja":"回数", "natja":"回数", "en":"numberOfTimes", "naten":"numberOfTimes"}$ という 実数 を  おく  。 
	${"ja":"初期位置", "natja":"初期位置", "en":"initialPosition", "naten":"initialPosition"}$ という 実数 を  おく  。 
	${"ja":"幅", "natja":"幅", "en":"width", "naten":"width"}$ という 実数 を  おく  。 
	${"ja":"高さ", "natja":"高さ", "en":"height", "naten":"height"}$ という 実数 を  おく  。 
	${"ja":"質量", "natja":"質量", "en":"mass", "naten":"mass"}$ という 実数 を  おく  。 
	${"ja":"慣性モーメント", "natja":"慣性モーメント", "en":"momentOfInertia", "naten":"momentOfInertia"}$ という 実数 を  おく  。 
	${"ja":"速度", "natja":"速度", "en":"velocity", "naten":"velocity"}$ という 実数 を  おく  。 
	${"ja":"角度", "natja":"角度", "en":"angle", "naten":"angle"}$ という 実数 を  おく  。 
	${"ja":"角速度", "natja":"角速度", "en":"angularVelocity", "naten":"angularVelocity"}$ という 実数 を  おく  。 
	${"ja":"力", "natja":"力", "en":"force", "naten":"force"}$ という 実数 を  おく  。 
	${"ja":"トルク", "natja":"トルク", "en":"torque", "naten":"torque"}$ という 実数 を  おく  。 
	${"ja":"形", "natja":"形", "en":"shape", "naten":"shape"}$ という 実数 を  おく  。 
	${"ja":"物理ワールド2D", "natja":"物理ワールド2D", "en":"physicsWorld2D", "naten":"physicsWorld2D"}$ という 実数 を  おく  。 
	${"ja":"物体配列", "natja":"物体配列", "en":"bodyArray", "naten":"bodyArray"}$ という 実数 を  おく  。 
	${"ja":"重力加速度", "natja":"重力加速度", "en":"gravitationalAccelaration", "naten":"gravitationalAccelaration"}$ という 実数 を  おく  。 
	${"ja":"前回の時間", "natja":"前回の時間", "en":"timeBefore", "naten":"timeBefore"}$ という 実数 を  おく  。 
	${"ja":"物体追加", "natja":"物体追加", "en":"addBody", "naten":"addBody"}$ という 実数 を  おく  。 
	${"ja":"重力", "natja":"重力", "en":"gravity", "naten":"gravity"}$ という 実数 を  おく  。 
	${"ja":"アップデート", "natja":"アップデート", "en":"update", "naten":"update"}$ という 実数 を  おく  。 
	${"ja":"経過時間", "natja":"経過時間", "en":"timePassed", "naten":"timePassed"}$ という 実数 を  おく  。 
	${"ja":"角加速度", "natja":"角加速度", "en":"angularAccelaration", "naten":"angularAccelaration"}$ という 実数 を  おく  。 
	${"ja":"物理ワールド", "natja":"物理ワールド", "en":"physicsWorld", "naten":"physicsWorld"}$ という 実数 を  おく  。 
	${"ja":"初速度", "natja":"初速度", "en":"initialVelocity", "naten":"initialVelocity"}$ という 実数 を  おく  。 
	${"ja":"初速度", "natja":"初速度", "en":"initialVelocity", "naten":"initialVelocity"}$ という 実数 を  おく  。 
	${"ja":"素数", "natja":"素数", "en":"primeNumbers", "naten":"primeNumbers"}$ という 実数 を  おく  。 
	${"ja":"フラグ", "natja":"フラグ", "en":"flag", "naten":"flag"}$ という 実数 を  おく  。 
	${"ja":"漸化式", "natja":"漸化式", "en":"recursion", "naten":"recursion"}$ という 実数 を  おく  。 
	${"ja":"変数1", "natja":"変数1", "en":"variable1", "naten":"variable1"}$ という 実数 を  おく  。 
	${"ja":"変数2", "natja":"変数2", "en":"variable2", "naten":"variable2"}$ という 実数 を  おく  。 
	${"ja":"変数3", "natja":"変数3", "en":"variable3", "naten":"variable3"}$ という 実数 を  おく  。 
	${"ja":"変数4", "natja":"変数4", "en":"variable4", "naten":"variable4"}$ という 実数 を  おく  。 
	${"ja":"変数5", "natja":"変数5", "en":"variable5", "naten":"variable5"}$ という 実数 を  おく  。 
	${"ja":"変数6", "natja":"変数6", "en":"variable6", "naten":"variable6"}$ という 実数 を  おく  。 
	${"ja":"変数7", "natja":"変数7", "en":"variable7", "naten":"variable7"}$ という 実数 を  おく  。 
	${"ja":"変数8", "natja":"変数8", "en":"variable8", "naten":"variable8"}$ という 実数 を  おく  。 
	${"ja":"変数9", "natja":"変数9", "en":"variable9", "naten":"variable9"}$ という 実数 を  おく  。 
	${"ja":"ロボット", "natja":"ロボット", "en":"robot", "naten":"robot"}$ という 実数 を  おく  。 
	${"ja":"コース", "natja":"コース", "en":"course", "naten":"course"}$ という 実数 を  おく  。 
ここまで実行 
クラス : ArduinoClass {
公開 : 	${"ja":"出力ピン", "natja":"出力ピン", "en":"OUTPUT", "naten":"OUTPUT"}$ という 文字 を  おく  。 
	${"ja":"入力ピン", "natja":"入力ピン", "en":"INPUT", "naten":"INPUT"}$ という 文字 を  おく  。 
	関数 ArduinoClass を  おく  。 ここから
		出力ピン に '出'を  代入する  。 
		入力ピン に '入'を  代入する  。 
	ここまで実行 
} 
( ピン番号 という 整数 ) を  とり ${"ja":"Arduino5V送る", "natja":"Arduino5V送る", "en":"ArduinoOutput5V", "naten":"ArduinoOutput5V"}$ という  関数  を  おく  。 ここから
	'H', ピン番号 Arduinoコマンド送信 する  。 
ここまで実行 
( ピン番号 という 整数 ) を  とり ${"ja":"Arduino0V送る", "natja":"Arduino0V送る", "en":"ArduinoOutput0V", "naten":"ArduinoOutput0V"}$ という  関数  を  おく  。 ここから
	'L', ピン番号 Arduinoコマンド送信 する  。 
ここまで実行 
( ピン番号 という 整数 , 入出力 という 文字 ) を  とり ${"ja":"Arduinoピン入出力設定", "natja":"Arduinoピン入出力設定", "en":"ArduinoSetPinmode", "naten":"ArduinoSetPinmode"}$ という  関数  を  おく  。 ここから
	もし 入出力  は '入'ならば ここから
		'I', ピン番号 Arduinoコマンド送信 する  。 
	ここまで実行 
	もし 入出力  は '出'ならば ここから
		'O', ピン番号 Arduinoコマンド送信 する  。 
	ここまで実行 
ここまで実行 
( ピン番号 という 整数 ) を  とり ${"ja":"Arduinoアナログ入力ピン設定", "natja":"Arduinoアナログ入力ピン設定", "en":"ArduinoSetAnalogInputPin", "naten":"ArduinoSetAnalogInputPin"}$ という  関数  を  おく  。 ここから
	'A', ピン番号 Arduinoコマンド送信 する  。 
ここまで実行 
( ピン番号 という 整数 ) を  とり ${"ja":"ArduinoHCSR04設定", "natja":"ArduinoHCSR04設定", "en":"ArduinoHCSR04Trigger", "naten":"ArduinoHCSR04Trigger"}$ という  関数  を  おく  。 ここから
	'T', ピン番号 Arduinoコマンド送信 する  。 
ここまで実行 
クラス : ${"ja":"ライントレースシミュレーション", "natja":"ライントレースシミュレーション", "en":"linetraceSimulation", "naten":"linetraceSimulation"}$ {
公開 : 	ワールド という シーン を  おく  。 
	直線データ という 配列 < ベクトル2D > を  おく  。 
	${"ja":"センサー値", "natja":"センサー値", "en":"sensorValue", "naten":"sensorValue"}$ [ 2 ] という 実数 を  おく  。 
	${"ja":"左モーターON", "natja":"左モーターON", "en":"leftMotorON", "naten":"leftMotorON"}$ という 整数 を  おく  。 
	${"ja":"右モーターON", "natja":"右モーターON", "en":"rightMotorON", "naten":"rightMotorON"}$ という 整数 を  おく  。 
	${"ja":"左モーター向き", "natja":"左モーター向き", "en":"leftMotorSequence", "naten":"leftMotorSequence"}$ という 整数 を  おく  。 
	${"ja":"右モーター向き", "natja":"右モーター向き", "en":"rightMotorSequence", "naten":"rightMotorSequence"}$ という 整数 を  おく  。 
	${"ja":"左モーター速度", "natja":"左モーター速度", "en":"leftMotorSpeed", "naten":"leftMotorSpeed"}$ という 実数 を  おく  。 
	${"ja":"右モーター速度", "natja":"右モーター速度", "en":"rightMotorSpeed", "naten":"rightMotorSpeed"}$ という 実数 を  おく  。 
	スタートタイム という 実数 を  おく  。 
	エンドタイム という 実数 を  おく  。 
	( points という 配列 < 実数 > , firstPos という ベクトル2D , ax という 実数 , ay という 実数 , bx という 実数 , byp という 実数 ) を  とり ライントレースシミュレーション という  関数  を  おく  。 ここから
		直線データ の 配列 する  。 
		ワールド の シーン する  。 
		0.0 , 1.0 ロボット移動方向 の ベクトル2D する  。 
		スタートマーク [ 0 ] に ax を  代入する  。 
		スタートマーク [ 1 ] に ay を  代入する  。 
		スタートマーク [ 2 ] に bx を  代入する  。 
		スタートマーク [ 3 ] に byp を  代入する  。 
		左モーター速度 に 3 を  代入する  。 
		右モーター速度 に 3 を  代入する  。 
		左モーター向き に 1 を  代入する  。 
		右モーター向き に 1 を  代入する  。 
		左モーターON に 0 を  代入する  。 
		右モーターON に 0 を  代入する  。 
		スタートタイム に 時間計測 ( ) を  代入する  。 
		ロボット速度 に 1.0 を  代入する  。 
		ロボット座標 に firstPos を  代入する  。 
		灰色 という ベクトル3D の  オブジェクト  を 0.800000000000000044 , 0.800000000000000044 , 0.800000000000000044 で  初期化  。 
		白 という ベクトル3D の  オブジェクト  を 1.0 , 1.0 , 1.0 で  初期化  。 
		黒 という ベクトル3D の  オブジェクト  を 0.0 , 0.0 , 0.0 で  初期化  。 
		初期位置1 という ベクトル3D の  オブジェクト  を firstPos の x , 0.0 , firstPos の y で  初期化  。 
		初期位置2 という ベクトル3D の  オブジェクト  を 5.0 , 5.0 , 5.0 で  初期化  。 
		初期位置3 という ベクトル3D の  オブジェクト  を 0.0 , ( 0  - ( 0.5 ) ) , 0.0 で  初期化  。 
		初期位置4 という ベクトル3D の  オブジェクト  を firstPos の x , 10.0 , firstPos の y で  初期化  。 
		回転軸 という ベクトル3D の  オブジェクト  を 0.0 , 1.0 , 0.0 で  初期化  。 
		points の 取得 ( 0 ) points の 追加 する  。 
		points の 取得 ( 1 ) points の 追加 する  。 
		初期位置3 , 白 , 0.0500000000000000028 , 0.0500000000000000028 , 0.0 ワールド の 平行光源設定 する  。 
		5.0 ワールド の 目 の 感度設定 する  。 
		初期位置4 ワールド の 目 の 座標設定 する  。 
		90.0 , ( 0  - ( 90.0 ) ) ワールド の 目 の 視点角度設定 する  。 
		ロボットID に ワールド の モデル追加 ( サンプルモデルロード ( "robot") , 灰色 , 初期位置1 ) を  代入する  。 
		ベクトル3D ( 0.0 , 1.0 , 0.0 ) , ラジアンへ ( 180 ) ワールド の スプライト配列 の 取得 ( ロボットID ) -> 回転設定 する  。 
		ライトID に ワールド の ライト追加 ( 1.0 , 白 , 初期位置2 , 1000.0 ) を  代入する  。 
		センサー1ID に ワールド の キューブ追加 ( 0.200000000000000011 , ベクトル3D ( 0.0 , 0.0 , 0.0 ) , ベクトル3D ( 0.0 , 0.0 , 0.0 ) ) を  代入する  。 
		センサー2ID に ワールド の キューブ追加 ( 0.200000000000000011 , ベクトル3D ( 0.0 , 0.0 , 0.0 ) , ベクトル3D ( 0.0 , 0.0 , 0.0 ) ) を  代入する  。 
		100.0 , 1.0 , 100.0 , 白 , 初期位置3 ワールド の 直方体追加 する  。 
		( カウンタ という 整数 を 0 で  初期化  。 ) から ( カウンタ  は ( points の 長さ ( )  - 2 ) ) まで ( カウンタ に カウンタ  + 2 を  代入する  。 ) 繰り返し ここから
			A という ベクトル2D の  オブジェクト  を points の 取得 ( カウンタ ) , points の 取得 ( カウンタ  + 1 ) で  初期化  。 
			B という ベクトル2D の  オブジェクト  を points の 取得 ( カウンタ  + 2 ) , points の 取得 ( カウンタ  + 3 ) で  初期化  。 
			もし A  != B ならば ここから
				差 という ベクトル2D を B  - A で  初期化  。 
				和 という ベクトル2D を A  + B で  初期化  。 
				傾き という 実数 を ( A の y  - B の y )  / ( A の x  - B の x ) で  初期化  。 
				A 直線データ の 追加 する  。 
				長さ という 実数 を 差 の 長さ ( ) で  初期化  。 
				temp座標 という ベクトル2D を 和  * 0.5 で  初期化  。 
				temp3D座標 という ベクトル3D の  オブジェクト  を temp座標 の x , 0.0 , temp座標 の y で  初期化  。 
				tempID という 整数 を ワールド の 直方体追加 ( 長さ , 0.25 , 0.25 , 黒 , temp3D座標 ) で  初期化  。 
				回転軸 , ( 0  - ( jsArcTan ( 傾き ) ) ) ワールド の スプライト配列 の 取得 ( tempID ) -> 回転設定 する  。 
			ここまで実行 
		ここまで実行 
		ベクトル2D ( points の 取得 ( 0 ) , points の 取得 ( 1 ) ) 直線データ の 追加 する  。 
	ここまで実行 
	関数 移動 を  おく  。 ここから
		PI という 実数 を 3.14159265358979312 で  初期化  。 
		左モーター距離 という 実数 を 左モーター速度  * 左モーターON  * 左モーター向き  * 0.0160000000000000003 で  初期化  。 
		右モーター距離 という 実数 を 右モーター速度  * 右モーターON  * 右モーター向き  * 0.0160000000000000003 で  初期化  。 
		基本距離 という 実数 を 右モーター距離 で  初期化  。 
		a という 実数 を 1.0 で  初期化  。 
		もし 右モーター距離  >= 左モーター距離 ならば ここから
			基本距離 に 左モーター距離 を  代入する  。 
			a に ( 0  - ( 1.0 ) ) を  代入する  。 
		ここまで実行 
		b という 実数 を ( 0  - ( 1.0 ) ) で  初期化  。 
		theta という 実数 を 180.0  * jsArcTan ( 右モーター距離  - 左モーター距離 )  / PI で  初期化  。 
		もし 右モーター距離  は 左モーター距離 ならば ここから
			theta に 0 を  代入する  。 
			a に 0.0 を  代入する  。 
			b に 0.0 を  代入する  。 
		ここまで実行 
		a に a  * ( ( 0  - ( 1.0 ) ) ) を  代入する  。 
		b に b  * ( ( 0  - ( 1.0 ) ) ) を  代入する  。 
		ロボット角度 に ロボット角度  + theta を  代入する  。 
		ロボット移動方向 の x に cos ( ラジアンへ ( ロボット角度  + 90.0 ) ) を  代入する  。 
		ロボット移動方向 の y に sin ( ラジアンへ ( ロボット角度  + 90.0 ) ) を  代入する  。 
		ロボット座標 の x に ロボット座標 の x  + a  * cos ( ラジアンへ ( ロボット角度 ) )  - b  * sin ( ラジアンへ ( ロボット角度 ) )  - a を  代入する  。 
		ロボット座標 の x に ロボット座標 の x  - ( a  * cos ( ラジアンへ ( ロボット角度  - theta ) )  - b  * sin ( ラジアンへ ( ロボット角度  - theta ) )  - a ) を  代入する  。 
		ロボット座標 の y に ロボット座標 の y  + a  * sin ( ラジアンへ ( ロボット角度 ) )  + b  * cos ( ラジアンへ ( ロボット角度 ) )  - b を  代入する  。 
		ロボット座標 の y に ロボット座標 の y  - ( a  * sin ( ラジアンへ ( ロボット角度  - theta ) )  + b  * cos ( ラジアンへ ( ロボット角度  - theta ) )  - b ) を  代入する  。 
		ベクトル3D ( 0.0 , 1.0 , 0.0 ) , ラジアンへ ( ( 0  - ( ロボット角度  + 180 ) ) ) ワールド の スプライト配列 の 取得 ( ロボットID ) -> 回転設定 する  。 
		ロボット座標 に ロボット座標  + ( ロボット移動方向  * 基本距離 ) を  代入する  。 
	ここまで実行 
	関数 アップデート を  おく  。 ここから
		センサー座標 [ 2 ] という ベクトル2D を ロボット座標 で  初期化  。 
		もし ( ! おわり )  && 線分当たり判定 ( センサー座標 [ 0 ] の x , センサー座標 [ 0 ] の y , センサー座標 [ 1 ] の x , センサー座標 [ 1 ] の y , スタートマーク [ 0 ] , スタートマーク [ 1 ] , スタートマーク [ 2 ] , スタートマーク [ 3 ] ) ならば ここから
			おわり に 真 を  代入する  。 
			エンドタイム に 時間計測 ( ) を  代入する  。 
			( エンドタイム  - スタートタイム )  / 1000 updateLinetraceTime する  。 
		ここまで実行 
		もし ! おわり ならば ここから
			移動 する  。 
			センサー座標 [ 0 ] の x に 1.75  * cos ( ラジアンへ ( ロボット角度  + 79.0 ) )  + ロボット座標 の x を  代入する  。 
			センサー座標 [ 0 ] の y に 1.75  * sin ( ラジアンへ ( ロボット角度  + 79.0 ) )  + ロボット座標 の y を  代入する  。 
			センサー座標 [ 1 ] の x に 1.75  * cos ( ラジアンへ ( ロボット角度  + 101.0 ) )  + ロボット座標 の x を  代入する  。 
			センサー座標 [ 1 ] の y に 1.75  * sin ( ラジアンへ ( ロボット角度  + 101.0 ) )  + ロボット座標 の y を  代入する  。 
			ベクトル3D ( センサー座標 [ 0 ] の x , 0.400000000000000022 , センサー座標 [ 0 ] の y ) ワールド の スプライト配列 の 取得 ( センサー1ID ) -> 座標設定 する  。 
			ベクトル3D ( センサー座標 [ 1 ] の x , 0.400000000000000022 , センサー座標 [ 1 ] の y ) ワールド の スプライト配列 の 取得 ( センサー2ID ) -> 座標設定 する  。 
			ベクトル3D ( 0.0 , 1.0 , 0.0 ) , ラジアンへ ( ( 0  - ( ロボット角度  + 180 ) ) ) ワールド の スプライト配列 の 取得 ( センサー1ID ) -> 回転設定 する  。 
			ベクトル3D ( 0.0 , 1.0 , 0.0 ) , ラジアンへ ( ( 0  - ( ロボット角度  + 180 ) ) ) ワールド の スプライト配列 の 取得 ( センサー2ID ) -> 回転設定 する  。 
			センサー距離 [ 2 ] という 実数 を [ 10000.0 , 10000.0 ] で  初期化  。 
			センサー数 という 整数 を 2 で  初期化  。 
			センサー数 回繰り返す ここから
				( i という 整数 を 0 で  初期化  。 ) から ( i  は ( 直線データ の 長さ ( )  - 1 ) ) まで ( i に i  + 1 を  代入する  。 ) 繰り返し ここから
					A という ベクトル2D を 直線データ の 取得 ( i ) で  初期化  。 
					B という ベクトル2D を 直線データ の 取得 ( i  + 1 ) で  初期化  。 
					AB という ベクトル2D を B  - A で  初期化  。 
					Aセンサー座標 という ベクトル2D を センサー座標 [ カウンタ ]  - A で  初期化  。 
					Bセンサー座標 という ベクトル2D を センサー座標 [ カウンタ ]  - B で  初期化  。 
					もし ( ベクトル2Dの内積 ( AB , Aセンサー座標 )  >= 0 )  && ( ベクトル2Dの内積 ( AB  * ( 0  - ( 1.0 ) ) , Bセンサー座標 )  >= 0 ) ならば ここから
						傾き という 実数 を ( A の y  - B の y )  / ( A の x  - B の x ) で  初期化  。 
						y切片 という 実数 を A の y  - ( 傾き  * A の x ) で  初期化  。 
						距離 という 実数 を 絶対値 ( 傾き  * センサー座標 [ カウンタ ] の x  - センサー座標 [ カウンタ ] の y  + y切片 )  / 平方根 ( 1.0  + 傾き  * 傾き ) で  初期化  。 
						もし 絶対値 ( 傾き )  > 10000.0 ならば ここから
							距離 に 絶対値 ( A の x  - センサー座標 [ カウンタ ] の x ) を  代入する  。 
						ここまで実行 
						もし センサー距離 [ カウンタ ]  > 距離 ならば ここから
							センサー距離 [ カウンタ ] に 距離 を  代入する  。 
						ここまで実行 
					ここまで実行 でなければ ここから
						もし センサー距離 [ カウンタ ]  > Aセンサー座標 の 長さ ( ) ならば ここから
							センサー距離 [ カウンタ ] に Aセンサー座標 の 長さ ( ) を  代入する  。 
						ここまで実行 
						もし センサー距離 [ カウンタ ]  > Bセンサー座標 の 長さ ( ) ならば ここから
							センサー距離 [ カウンタ ] に Bセンサー座標 の 長さ ( ) を  代入する  。 
						ここまで実行 
					ここまで実行 
				ここまで実行 
			ここまで実行 
			センサー値 [ 0 ] に センサー距離 [ 0 ]  * 768.0 を  代入する  。 
			センサー値 [ 1 ] に センサー距離 [ 1 ]  * 768.0 を  代入する  。 
			もし センサー値 [ 0 ]  > 255 ならば ここから
				センサー値 [ 0 ] に 255.0 を  代入する  。 
			ここまで実行 
			もし センサー値 [ 1 ]  > 255 ならば ここから
				センサー値 [ 1 ] に 255.0 を  代入する  。 
			ここまで実行 
			ロボット座標3D という ベクトル3D の  オブジェクト  を ロボット座標 の x , 0.0 , ロボット座標 の y で  初期化  。 
			ライト座標3D という ベクトル3D の  オブジェクト  を ロボット座標 の x  + 5.0 , 5.0 , ロボット座標 の y  + 5.0 で  初期化  。 
			ロボット座標3D ワールド の スプライト配列 の 取得 ( ロボットID ) -> 座標設定 する  。 
			ライト座標3D ワールド の スプライト配列 の 取得 ( ライトID ) -> 座標設定 する  。 
		ここまで実行 
		ワールド の 描画 する  。 
	ここまで実行 
非公開 : 	ロボットID という 整数 を  おく  。 
	ライトID という 整数 を  おく  。 
	ロボット角度 という 実数 を  おく  。 
	ロボット移動方向 という ベクトル2D を  おく  。 
	ロボット速度 という 実数 を  おく  。 
	ロボット座標 という ベクトル2D を  おく  。 
	ロボット初期位置 という ベクトル2D を  おく  。 
	センサー1ID という 整数 を  おく  。 
	センサー2ID という 整数 を  おく  。 
	ロボットoffset という ベクトル2D を  おく  。 
	おわり という 真偽 を  おく  。 
	スタートマーク [ 4 ] という 実数 を  おく  。 
} 
