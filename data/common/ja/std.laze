関数: ${"ja":"実数表示", "natja":"実数表示", "en":"printDouble", "naten":"printDouble"}$(実数: x) => () = js読み込み("console", "log");
関数: ${"ja":"デバッグ表示", "natja":"デバッグ表示", "en":"debug", "naten":"debug"}$(実数: x) => () = js読み込み("console", "debug");
関数: ${"ja":"行列表示", "natja":"行列表示", "en":"printMatrix", "naten":"printMatrix"}$(実数: offset[4][4]) => () = js読み込み("console", "logMatrix");
関数: ${"ja":"アドレス表示", "natja":"アドレス表示", "en":"printAddress", "naten":"printAddress"}$(*無: x) => () = js読み込み("console", "log");
関数: ${"ja":"_文字列表示", "natja":"_文字列表示", "en":"_printString", "naten":"_printString"}$(*文字: x, 整数: 長さ) => () = js読み込み("console", "logstring");
関数: ${"ja":"時間計測", "natja":"時間計測", "en":"getTime", "naten":"getTime"}$() => (実数: 時間) = js読み込み("std", "performanceNow");
関数: ${"ja":"glClearDepth", "natja":"glClearDepth", "en":"glClearDepth", "naten":"glClearDepth"}$(整数32: i) => () = js読み込み("graphics", "clearDepth");
関数: ${"ja":"glDepthFunc", "natja":"glDepthFunc", "en":"glDepthFunc", "naten":"glDepthFunc"}$(整数32: i) => () = js読み込み("graphics", "depthFunc");
関数: ${"ja":"glEnable", "natja":"glEnable", "en":"glEnable", "naten":"glEnable"}$(整数32: i) => () = js読み込み("graphics", "enable");
関数: ${"ja":"glDisable", "natja":"glDisable", "en":"glDisable", "naten":"glDisable"}$(整数32: i) => () = js読み込み("graphics", "disable");
関数: ${"ja":"glCreateProgram", "natja":"glCreateProgram", "en":"glCreateProgram", "naten":"glCreateProgram"}$() => (整数32: prog) = js読み込み("graphics", "createProgram");
関数: ${"ja":"glCreateBuffer", "natja":"glCreateBuffer", "en":"glCreateBuffer", "naten":"glCreateBuffer"}$() => (整数32: buffer) = js読み込み("graphics", "createBuffer");
関数: ${"ja":"glBindBuffer", "natja":"glBindBuffer", "en":"glBindBuffer", "naten":"glBindBuffer"}$(整数32: i, 整数32: j) => () = js読み込み("graphics", "bindBuffer");
関数: ${"ja":"glBufferData", "natja":"glBufferData", "en":"glBufferData", "naten":"glBufferData"}$(整数32: i, *実数: offset, 整数32: size, 整数32: j) => () = js読み込み("graphics", "bufferData");
関数: ${"ja":"glElementBufferData", "natja":"glElementBufferData", "en":"glElementBufferData", "naten":"glElementBufferData"}$(整数32: i, *整数32: offset, 整数32: size, 整数32: j) => () = js読み込み("graphics", "elementBufferData");
関数: ${"ja":"glUseProgram", "natja":"glUseProgram", "en":"glUseProgram", "naten":"glUseProgram"}$(整数32: i) => () = js読み込み("graphics", "useProgram");
関数: ${"ja":"glGetAttribLocation", "natja":"glGetAttribLocation", "en":"glGetAttribLocation", "naten":"glGetAttribLocation"}$(整数32: i, *文字: offset, 整数32: size) => (整数32: loc) = js読み込み("graphics", "getAttribLocation");
関数: ${"ja":"glVertexAttribPointer", "natja":"glVertexAttribPointer", "en":"glVertexAttribPointer", "naten":"glVertexAttribPointer"}$(整数32: index, 整数32: size, 整数32: ty, 整数32: normalized, 整数32: stride, 整数32: offset) => () = js読み込み("graphics", "vertexAttribPointer");
関数: ${"ja":"glEnableVertexAttribArray", "natja":"glEnableVertexAttribArray", "en":"glEnableVertexAttribArray", "naten":"glEnableVertexAttribArray"}$(整数32: index) => () = js読み込み("graphics", "enableVertexAttribArray");
関数: ${"ja":"glDrawArrays", "natja":"glDrawArrays", "en":"glDrawArrays", "naten":"glDrawArrays"}$(整数32: i, 整数32: first, 整数32: count) => () = js読み込み("graphics", "drawArrays");
関数: ${"ja":"_glGetUniformLocation", "natja":"_glGetUniformLocation", "en":"_glGetUniformLocation", "naten":"_glGetUniformLocation"}$(整数32: i, *文字: offset, 整数32: size) => (整数32: loc) = js読み込み("graphics", "getUniformLocation");
関数: ${"ja":"glUniformMatrix2fv", "natja":"glUniformMatrix2fv", "en":"glUniformMatrix2fv", "naten":"glUniformMatrix2fv"}$(整数32: loc, 整数32: trans, *実数: offset) => () = js読み込み("graphics", "uniformMatrix2fv");
関数: ${"ja":"glUniformMatrix3fv", "natja":"glUniformMatrix3fv", "en":"glUniformMatrix3fv", "naten":"glUniformMatrix3fv"}$(整数32: loc, 整数32: trans, *実数: offset) => () = js読み込み("graphics", "uniformMatrix3fv");
関数: ${"ja":"glUniformMatrix4fv", "natja":"glUniformMatrix4fv", "en":"glUniformMatrix4fv", "naten":"glUniformMatrix4fv"}$(整数32: loc, 整数32: trans, 実数: offset[16]) => () = js読み込み("graphics", "uniformMatrix4fv");
関数: ${"ja":"glUniform1f", "natja":"glUniform1f", "en":"glUniform1f", "naten":"glUniform1f"}$(整数32: loc, 実数: v0) => () = js読み込み("graphics", "uniform1f");
関数: ${"ja":"glUniform1fv", "natja":"glUniform1fv", "en":"glUniform1fv", "naten":"glUniform1fv"}$(整数32: loc, 実数: v0) => () = js読み込み("graphics", "uniform1fv");
関数: ${"ja":"glUniform1i", "natja":"glUniform1i", "en":"glUniform1i", "naten":"glUniform1i"}$(整数32: loc, 整数32: v0) => () = js読み込み("graphics", "uniform1i");
関数: ${"ja":"glUniform1iv", "natja":"glUniform1iv", "en":"glUniform1iv", "naten":"glUniform1iv"}$(整数32: loc, 整数32: v0) => () = js読み込み("graphics", "uniform1iv");
関数: ${"ja":"glUniform2f", "natja":"glUniform2f", "en":"glUniform2f", "naten":"glUniform2f"}$(整数32: loc, 実数: v0, 実数: v1) => () = js読み込み("graphics", "uniform2f");
関数: ${"ja":"glUniform2fv", "natja":"glUniform2fv", "en":"glUniform2fv", "naten":"glUniform2fv"}$(整数32: loc, 実数: v0, 実数: v1) => () = js読み込み("graphics", "uniform2fv");
関数: ${"ja":"glUniform2i", "natja":"glUniform2i", "en":"glUniform2i", "naten":"glUniform2i"}$(整数32: loc, 整数32: v0, 整数32: v1) => () = js読み込み("graphics", "uniform2i");
関数: ${"ja":"glUniform2iv", "natja":"glUniform2iv", "en":"glUniform2iv", "naten":"glUniform2iv"}$(整数32: loc, 整数32: v0, 整数32: v1) => () = js読み込み("graphics", "uniform2iv");
関数: ${"ja":"glUniform3f", "natja":"glUniform3f", "en":"glUniform3f", "naten":"glUniform3f"}$(整数32: loc, 実数: v0, 実数: v1, 実数: v2) => () = js読み込み("graphics", "uniform3f");
関数: ${"ja":"glUniform3fv", "natja":"glUniform3fv", "en":"glUniform3fv", "naten":"glUniform3fv"}$(整数32: loc, 実数: v0, 実数: v1, 実数: v2) => () = js読み込み("graphics", "uniform3fv");
関数: ${"ja":"glUniform3i", "natja":"glUniform3i", "en":"glUniform3i", "naten":"glUniform3i"}$(整数32: loc, 整数32: v0, 整数32: v1, 整数32: v2) => () = js読み込み("graphics", "uniform3i");
関数: ${"ja":"glUniform3iv", "natja":"glUniform3iv", "en":"glUniform3iv", "naten":"glUniform3iv"}$(整数32: loc, 整数32: v0, 整数32: v1, 整数32: v2) => () = js読み込み("graphics", "uniform3iv");
関数: ${"ja":"glUniform4f", "natja":"glUniform4f", "en":"glUniform4f", "naten":"glUniform4f"}$(整数32: loc, 実数: v0, 実数: v1, 実数: v2, 実数: v3) => () = js読み込み("graphics", "uniform4f");
関数: ${"ja":"glUniform4fv", "natja":"glUniform4fv", "en":"glUniform4fv", "naten":"glUniform4fv"}$(整数32: loc, 実数: v0, 実数: v1, 実数: v2, 実数: v3) => () = js読み込み("graphics", "uniform4fv");
関数: ${"ja":"glUniform4i", "natja":"glUniform4i", "en":"glUniform4i", "naten":"glUniform4i"}$(整数32: loc, 整数32: v0, 整数32: v1, 整数32: v2, 整数32: v3) => () = js読み込み("graphics", "uniform4i");
関数: ${"ja":"glUniform4iv", "natja":"glUniform4iv", "en":"glUniform4iv", "naten":"glUniform4iv"}$(整数32: loc, 整数32: v0, 整数32: v1, 整数32: v2, 整数32: v3) => () = js読み込み("graphics", "uniform4iv");
関数: ${"ja":"glClearColor", "natja":"glClearColor", "en":"glClearColor", "naten":"glClearColor"}$(実数: r, 実数: g, 実数: b, 実数: a) => () = js読み込み("graphics", "clearColor");
関数: ${"ja":"glClear", "natja":"glClear", "en":"glClear", "naten":"glClear"}$(整数32: color) => () = js読み込み("graphics", "clear");
関数: ${"ja":"glDrawElements", "natja":"glDrawElements", "en":"glDrawElements", "naten":"glDrawElements"}$(整数32: i, 整数32: count, 整数32: ty, 整数32: offset) => () = js読み込み("graphics", "drawElements");
関数: ${"ja":"glBlendFunc", "natja":"glBlendFunc", "en":"glBlendFunc", "naten":"glBlendFunc"}$(整数32: i, 整数32: j) => () = js読み込み("graphics", "blendFunc");
関数: ${"ja":"キーチェック", "natja":"キーチェック", "en":"checkKeyPress", "naten":"checkKeyPress"}$(整数32: keyCode) => (整数: pressed) = js読み込み("std", "checkKeyPress");
関数: ${"ja":"マウスチェック", "natja":"マウスチェック", "en":"checkMousePress", "naten":"checkMousePress"}$() => (整数: pressed) = js読み込み("std", "checkMousePress");
関数: ${"ja":"マウス相対座標X", "natja":"マウス相対座標X", "en":"checkRelativeMouseX", "naten":"checkRelativeMouseX"}$() => (実数: x) = js読み込み("std", "checkRelativeMouseX");
関数: ${"ja":"マウス相対座標Y", "natja":"マウス相対座標Y", "en":"checkRelativeMouseY", "naten":"checkRelativeMouseY"}$() => (実数: x) = js読み込み("std", "checkRelativeMouseY");
関数: ${"ja":"マウス絶対座標X", "natja":"マウス絶対座標X", "en":"checkAbsoluteMouseX", "naten":"checkAbsoluteMouseX"}$() => (実数: x) = js読み込み("std", "checkAbsoluteMouseX");
関数: ${"ja":"マウス絶対座標Y", "natja":"マウス絶対座標Y", "en":"checkAbsoluteMouseY", "naten":"checkAbsoluteMouseY"}$() => (実数: x) = js読み込み("std", "checkAbsoluteMouseY");
関数: ${"ja":"スクロール座標", "natja":"スクロール座標", "en":"checkScroll", "naten":"checkScroll"}$() => (実数: x) = js読み込み("std", "checkScrollY");
関数: ${"ja":"ランダム数生成", "natja":"ランダム数生成", "en":"rand", "naten":"rand"}$() => (実数: x) = js読み込み("std", "rand");
関数: ${"ja":"メモリ確保", "natja":"メモリ確保", "en":"allocMemory", "naten":"allocMemory"}$(整数32: size) => (*無: p) = js読み込み("std", "alloc");
関数: ${"ja":"テクスチャロード", "natja":"テクスチャロード", "en":"_loadTexture", "naten":"_loadTexture"}$(*文字: offset, 整数32: length) => (整数32: a) = js読み込み("graphics", "loadTexture");
関数: ${"ja":"glActiveTexture", "natja":"glActiveTexture", "en":"glActiveTexture", "naten":"glActiveTexture"}$(整数32: i) => () = js読み込み("graphics", "activeTexture");
関数: ${"ja":"glBindTexture", "natja":"glBindTexture", "en":"glBindTexture", "naten":"glBindTexture"}$(整数32: i, 整数32: j) => () = js読み込み("graphics", "bindTexture");
関数: ${"ja":"マウスキャプチャ", "natja":"マウスキャプチャ", "en":"captureMouse", "naten":"captureMouse"}$() => () = js読み込み("graphics", "lockPointer");
関数:${"ja":"Arduino設定", "natja":"Arduino設定", "en":"ArduinoSetup", "naten":"ArduinoSetup"}$(整数:vendorId, 関数:c() => ()) => () = js読み込み("arduino", "setUp");
関数:${"ja":"Arduinoコマンド送信", "natja":"Arduinoコマンド送信", "en":"ArduinoSendCommand", "naten":"ArduinoSendCommand"}$(文字:コマンド, 整数32:data) => () = js読み込み("arduino", "sendCommand");
関数:${"ja":"Arduinoデータ受信", "natja":"Arduinoデータ受信", "en":"ArduinoReceiveData", "naten":"ArduinoReceiveData"}$() => () = js読み込み("arduino", "checkInput");
関数:${"ja":"Arduinoアナログ入力", "natja":"Arduinoアナログ入力", "en":"ArduinoAnalogInput", "naten":"ArduinoAnalogInput"}$(整数:ピン番号) => (整数32:データ) = js読み込み("arduino", "analogRead");
関数:${"ja":"Arduinoデジタル入力", "natja":"Arduinoデジタル入力", "en":"ArduinoDigitalInput", "naten":"ArduinoDigitalInput"}$(整数:ピン番号) => (整数32:データ) = js読み込み("arduino", "digitalRead");
関数:${"ja":"ArduinoHCSR04距離入力", "natja":"ArduinoHCSR04距離入力", "en":"ArduinoHCSR04DistanceInput", "naten":"ArduinoHCSR04DistanceInput"}$(整数:ピン番号) => (整数32:データ) = js読み込み("arduino", "distanceRead");
関数:getTeapot() => (*無:s) = js読み込み("graphics", "getTeapot");
関数:getMountains() => (*無:s) = js読み込み("graphics", "getMountains");
関数:getTeddybear() => (*無:s) = js読み込み("graphics", "getTeddybear");
関数:getCow() => (*無:s) = js読み込み("graphics", "getCow");
関数:getFox() => (*無:s) = js読み込み("graphics", "getFox");
関数:getRobot() => (*無:s) = js読み込み("graphics", "getRobot");
関数:getCheckpoint() => (*無:s) = js読み込み("graphics", "getCheckpoint");
関数:jsArcSin(実数:x) => (実数:r) = js読み込み("std", "asin");
関数:jsArcCos(実数:x) => (実数:r) = js読み込み("std", "acos");
関数:jsArcTan(実数:x) => (実数:r) = js読み込み("std", "atan");
関数:jsLog(実数:x) => (実数:r) = js読み込み("std", "log");
関数:jsEPow(実数:x) => (実数:r) = js読み込み("std", "ePow");
関数:jsPow(実数:x, 実数:y) => (実数:r) = js読み込み("std", "exp");
関数:updateLinetraceTime(実数: x) => () = js読み込み("linetrace", "updateLinetraceTime");


関数: ${"ja":"sin", "natja":"sin", "en":"sin", "naten":"sin"}$(実数: input) => (実数: 結果){
	実数: PI = 3.14159265358979312;
	整数: temp = input / (2.0 * PI);
	実数: rad = input - (2.0 * PI * temp);
	実数: plusminus = 1.0;
	もし(rad < 0.0)ならば{
		rad = rad + (2.0 * PI);
	}
	もし(rad > PI)ならば{
		plusminus = 0 - 1.0;
		もし(rad > 1.5 * PI)ならば{
			rad = (2.0 * PI) - rad;
		}でなければ{
			rad = rad - PI;
		}
	}でなければ{
		もし(rad > 0.5 * PI)ならば{
			rad = PI - rad;
		}
	}
	もし(rad > 0.25 * PI)ならば{
		rad = (0.5 * PI) - rad;
		実数: doubleRad = rad * rad;
		結果 = 1.0 - (doubleRad) / 2.0 + (doubleRad * doubleRad) / 24.0 - (doubleRad * doubleRad * doubleRad) / 720.0 + (doubleRad * doubleRad * doubleRad * doubleRad) / 40320.0 - (doubleRad * doubleRad * doubleRad * doubleRad * doubleRad) / 3628800.0 + (doubleRad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad) / 479001600.0;
		結果 = 結果 * plusminus;
	}でなければ{
		実数: doubleRad = rad * rad;
		結果 = rad - (rad * doubleRad) / 6.0 + (rad * doubleRad * doubleRad) / 120.0 - (rad * doubleRad * doubleRad * doubleRad) / 5040.0 + (rad * doubleRad * doubleRad * doubleRad * doubleRad) / 362880.0 - (rad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad) / 39916800.0 + (rad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad) / 6227020800.0 - (rad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad) / 1307674368000.0;
		結果 = 結果 * plusminus;
	}
}
関数: ${"ja":"cos", "natja":"cos", "en":"cos", "naten":"cos"}$(実数: input) => (実数: 結果){
	実数: PI = 3.14159265358979312;
	整数: temp = input / (2 * PI);
	実数: rad = input - (2 * PI * temp);
	実数: plusminus = 1.0;
	もし(rad < 0.0)ならば{
		rad = rad + (2.0 * PI);
	}
	もし(rad > PI)ならば{
		もし(rad > 1.5 * PI)ならば{
			rad = (2.0 * PI) - rad;
		}でなければ{
			plusminus = 0 - 1.0;
			rad = rad - PI;
		}
	}でなければ{
		もし(rad > 0.5 * PI)ならば{
			plusminus = 0 - 1.0;
			rad = PI - rad;
		}
	}
	もし(rad < 0.25 * PI)ならば{
		実数: doubleRad = rad * rad;
		結果 = 1.0 - (doubleRad) / 2.0 + (doubleRad * doubleRad) / 24.0 - (doubleRad * doubleRad * doubleRad) / 720.0 + (doubleRad * doubleRad * doubleRad * doubleRad) / 40320.0 - (doubleRad * doubleRad * doubleRad * doubleRad * doubleRad) / 3628800.0 + (doubleRad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad) / 479001600.0;
		結果 = 結果 * plusminus;
	}でなければ{
		rad = (0.5 * PI) - rad;
		実数: doubleRad = rad * rad;
		結果 = rad - (rad * doubleRad) / 6.0 + (rad * doubleRad * doubleRad) / 120.0 - (rad * doubleRad * doubleRad * doubleRad) / 5040.0 + (rad * doubleRad * doubleRad * doubleRad * doubleRad) / 362880.0 - (rad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad) / 39916800.0 + (rad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad) / 6227020800.0 - (rad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad) / 1307674368000.0;
		結果 = 結果 * plusminus;
	}
}
関数: ${"ja":"tan", "natja":"tan", "en":"tan", "naten":"tan"}$(実数: rad) => (実数: 結果){
	実数: PI = 3.14159265358979312;
	実数: sqRad = rad * rad;
	結果 = sin(rad) / cos(rad);
}
関数: ${"ja":"絶対値", "natja":"絶対値", "en":"abs", "naten":"abs"}$(実数: a) => (実数: b){
	もし(a >= 0)ならば{
		b = a;
	}でなければ{
		b = - a;
	}
}
関数: ${"ja":"ラジアンへ", "natja":"ラジアンへ", "en":"toRad", "naten":"toRad"}$(実数: deg) => (実数: rad){
	実数: PI = 3.14159265358979312;
	rad = (deg / 180) * PI;
}
関数: ${"ja":"平方根", "natja":"平方根", "en":"root", "naten":"root"}$(実数: x) => (実数: y){
	y = 5;
	(整数: i = 0;)から(i == 20)まで(i = i + 1;){
		y = 0.5 * (y + (x / y));
	}
}
関数: ${"ja":"線分当たり判定", "natja":"線分当たり判定", "en":"checkLineCross", "naten":"checkLineCross"}$(実数: ax, 実数: ay, 実数: bx, 実数: byp, 実数: cx, 実数: cy, 実数: dx, 実数: dy) => (真偽: b){
	実数:ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);
  実数:tb = (cx - dx) * (byp - cy) + (cy - dy) * (cx - bx);
  実数:tc = (ax - bx) * (cy - ay) + (ay - byp) * (ax - cx);
  実数:td = (ax - bx) * (dy - ay) + (ay - byp) * (ax - dx);

  b = ((tc * td) < 0) && ((ta * tb) < 0);
}
型<T>: クラス: ${"ja":"配列", "natja":"配列", "en":"Array", "naten":"Array"}${
公開: 	*T: content;
	整数: size;
	整数: allocated;
	関数: 配列() => (){
		size = 0;
		allocated = 4;
		content = メモリ確保(バイト数(*content) * allocated);
	}
	関数: ${"ja":"取得", "natja":"取得", "en":"get", "naten":"get"}$(整数: index) => (T: result){
		終了(content[index]);
	}
	// 85
	関数: ${"ja":"追加", "natja":"追加", "en":"push", "naten":"push"}$(T: new) => (){
		もし(size == allocated)ならば{
			allocated = allocated * 2;
			*T: temp = content;
			content = メモリ確保(バイト数(*content) * allocated);
			(整数: i = 0;)から(i == (allocated/2))まで(i = i + 1;){
				content[i] = temp[i];
			}
		}
		content[size] = new;
		size += 1;
	}
	関数: ${"ja":"長さ", "natja":"長さ", "en":"length", "naten":"length"}$() => (整数: a){
		a = size;
	}
	関数: ${"ja":"ポップ", "natja":"ポップ", "en":"pop", "naten":"pop"}$() => (){
		size = size - 1;
	}
    関数: 演算子 = (*T: offset, 整数: l) => (){
		content = offset;
		size = l;
	}
	関数: 演算子 = (配列<T>:a) => (){
		content = メモリ確保(バイト数(*content) * (a.allocated));
		size = a.size;
		allocated = a.allocated;
		(size)回繰り返す{
			content[カウンタ] = a.content[カウンタ];
		}
	}
	関数: 演算子 == (配列<T>:a) => (真偽:b){
		b = 真;
		もし(size != a.size)ならば{
			終了(偽);
		}
		(size)回繰り返す{
			もし(content[カウンタ] != a.content[カウンタ])ならば{
				終了(偽);
			}
		}
	}
	関数: 演算子 == (*T:offset, 整数:l) => (真偽:b){
		b = 真;
		もし(size != l)ならば{
			終了(偽);
		}
		(size)回繰り返す{
			もし(content[カウンタ] != offset[カウンタ])ならば{
				終了(偽);
			}
		}
	}
	関数: 演算子 != (配列<T>:a) => (真偽:b){
		b = 偽;
		もし(size != a.size)ならば{
			終了(真);
		}
		(size)回繰り返す{
			もし(content[カウンタ] != a.content[カウンタ])ならば{
				終了(真);
			}
		}
	}
	関数: 演算子 != (*T:offset, 整数:l) => (真偽:b){
		b = 偽;
		もし(size != l)ならば{
			終了(真);
		}
		(size)回繰り返す{
			もし(content[カウンタ] != offset[カウンタ])ならば{
				終了(真);
			}
		}
	}
	関数: 演算子 + (配列<T>:a) => (配列<T>:b){
		配列<T>:結果();
		(size)回繰り返す{
			結果.追加(content[カウンタ]);
		}
		(a.size)回繰り返す{
			結果.追加(a.取得(カウンタ));
		}
		終了(結果);
	}
	関数: 演算子 + (*T:offset, 整数:l) => (配列<T>:b){
		配列<T>:結果();
		(size)回繰り返す{
			結果.追加(content[カウンタ]);
		}
		(l)回繰り返す{
			結果.追加(offset[カウンタ]);
		}
		終了(結果);
	}
	関数: ${"ja":"全要素操作", "natja":"全要素操作", "en":"forEach", "naten":"forEach"}$(関数:c(T:a) => ()) => (){
		(size)回繰り返す{
			c(content[カウンタ]);
		}
	}
	関数: ${"ja":"全要素変更", "natja":"全要素変更", "en":"map", "naten":"map"}$(関数:c(T:a) => (T:b)) => (){
		配列<T>:結果();
		結果.content = メモリ確保(バイト数(*content) * (allocated));
		結果.size = size;
		結果.allocated = allocated;
		(size)回繰り返す{
			結果.content[カウンタ] = c(content[カウンタ]);
		}
		終了(結果);
	}
	関数:__ソート(整数: s, 整数: e, 関数:c(T:a, T:b) => (整数:r)) => (){
		もし(s < e)ならば{
			整数:loc = e;
			T:pivot = content[loc];
			整数:i = s - 1;
			整数:l = e - s;
			(l)回繰り返す{
				もし(c(content[カウンタ + s], pivot) < 0)ならば{
					i += 1;
					T:temp = content[カウンタ + s];
					content[カウンタ + s] = content[i];
					content[i] = temp;
				}
			}
			T:temp = content[loc];
			content[loc] = content[i + 1];
			content[i + 1] = temp;
			__ソート(s, i, c);
			__ソート(i + 2, e, c);
		}
	}
	関数: ${"ja":"ソート", "natja":"ソート", "en":"sort", "naten":"sort"}$(関数:c(T:a, T:b) => (整数:r)) => (){
		__ソート(0, size - 1, c);
	}
	関数: ${"ja":"フィルター", "natja":"フィルター", "en":"filter", "naten":"filter"}$(関数:c(T:a) => (真偽:r)) => (配列<T>:b){
		配列<T>:結果();
		(size)回繰り返す{
			もし(c(content[カウンタ]))ならば{
				結果.追加(content[カウンタ]);
			}
		}
		終了(結果);
	}
	関数: ${"ja":"削除", "natja":"削除", "en":"remove", "naten":"remove"}$(整数:i) => (配列<T>:b){
		配列<T>:結果();
		(size)回繰り返す{
			もし(カウンタ != i)ならば{
				結果.追加(content[カウンタ]);
			}
		}
		終了(結果);
	}
	関数: ${"ja":"範囲削除", "natja":"範囲削除", "en":"removeRange", "naten":"removeRange"}$(整数:i, 整数:r) => (配列<T>:b){
		配列<T>:結果();
		(size)回繰り返す{
			もし((カウンタ < i) || (カウンタ >= (i + r)))ならば{
				結果.追加(content[カウンタ]);
			}
		}
		終了(結果);
	}
	関数: ${"ja":"部分列", "natja":"部分列", "en":"subseq", "naten":"subseq"}$(整数:s, 整数: e) => (配列<T>:b){
		配列<T>:結果();
		もし(s >= e)ならば{
			終了(結果);
		}
		(size)回繰り返す{
			もし((s <= カウンタ) && (カウンタ < e))ならば{
				結果.追加(content[カウンタ]);
			}
		}
		終了(結果);
	}
	関数: ${"ja":"範囲部分列", "natja":"範囲部分列", "en":"subseqRange", "naten":"subseqRange"}$(整数:s, 整数: l) => (配列<T>:b){
		配列<T>:結果();
		もし(s >= size)ならば{
			終了(結果);
		}
		(size)回繰り返す{
			もし((s <= カウンタ) && (カウンタ < (s + l)))ならば{
				結果.追加(content[カウンタ]);
			}
		}
		終了(結果);
	}
	関数: ${"ja":"置換", "natja":"置換", "en":"replace", "naten":"replace"}$(T:a, T:b) => (){
		(size)回繰り返す{
			もし(content[カウンタ] == a)ならば{
				content[カウンタ] = b;
			}
		}
	}
	関数: ${"ja":"範囲置換", "natja":"範囲置換", "en":"replaceRange", "naten":"replaceRange"}$(整数:s, 整数:l, T:a) => (){
		(size)回繰り返す{
			もし((s <= カウンタ) && (カウンタ < (s + l)))ならば{
				content[カウンタ] = a;
			}
		}
	}
	関数: ${"ja":"範囲置換", "natja":"範囲置換", "en":"replaceRange", "naten":"replaceRange"}$(整数:s, 整数:l, 配列<T>:a) => (){
		(size)回繰り返す{
			もし((s <= カウンタ) && (カウンタ < (s + l)))ならば{
				content[カウンタ] = a.content[カウンタ - s];
			}
		}
	}
	関数: ${"ja":"探索", "natja":"探索", "en":"find", "naten":"find"}$(T:b) => (整数:i){
		(size)回繰り返す{
			もし(content[カウンタ] == b)ならば{
				終了(カウンタ);
			}
		}
		終了(size);
	}
}
関数:${"ja":"整数文字変換", "natja":"整数文字変換", "en":"intToChar", "naten":"intToChar"}$(整数:a) => (文字:b){
	a %= 10;
	もし(a == 0)ならば{
		b = '0';
	}
	でなければ、もし(a == 1)ならば{
		b = '1';
	}
	でなければ、もし(a == 2)ならば{
		b = '2';
	}
	でなければ、もし(a == 3)ならば{
		b = '3';
	}
	でなければ、もし(a == 4)ならば{
		b = '4';
	}
	でなければ、もし(a == 5)ならば{
		b = '5';
	}
	でなければ、もし(a == 6)ならば{
		b = '6';
	}
	でなければ、もし(a == 7)ならば{
		b = '7';
	}
	でなければ、もし(a == 8)ならば{
		b = '8';
	}
	でなければ、もし(a == 9)ならば{
		b = '9';
	}
}
クラス: ${"ja":"文字列", "natja":"文字列", "en":"string", "naten":"string"}${
公開: 	*文字: content;
	整数: 長さ;
	関数: 文字列(*文字: offset, 整数: l) => (){
		content = offset;
		長さ = l;
	}
	関数:文字列() => (){
		content = メモリ確保(0);
		長さ = 0;
	}
	関数: 演算子 = (*文字: offset, 整数: l) => (){
		content = offset;
		長さ = l;
	}
	関数:演算子 = (文字列:a) => (){
		content = メモリ確保(バイト数(*content) * (a.長さ));
		長さ = a.長さ;
		// アドレス表示(a.content);
		// _文字列表示(a.content, a.長さ);
		(長さ)回繰り返す{
			content[カウンタ] = a.content[カウンタ];
		}
	}
	関数:演算子 = (文字:a) => (){
		content = メモリ確保(バイト数(*content));
		長さ = 1;
		content[0] = a;
	}
	関数: 演算子 + (文字:a) => (文字列:b){
		b.content = メモリ確保(バイト数(*content) * (長さ + 1));
		(長さ)回繰り返す{
			b.content[カウンタ] = content[カウンタ];
		}
		b.content[長さ] = a;
		b.長さ = 長さ + 1;
	}
	関数: 演算子 + (*文字:offset, 整数:l) =>(文字列:b){
		b.content = メモリ確保(バイト数(*content) * (長さ + l));
		(長さ)回繰り返す{
			b.content[カウンタ] = content[カウンタ];
		}
		(l)回繰り返す{
			b.content[長さ + カウンタ] = offset[カウンタ];
		}
		b.長さ = 長さ + l;
	}
	関数: 演算子 + (文字列:a) => (文字列:b){
		b.content = メモリ確保(バイト数(*content) * (長さ + a.長さ));
		(長さ)回繰り返す{
			b.content[カウンタ] = content[カウンタ];
		}
		(a.長さ)回繰り返す{
			b.content[長さ + カウンタ] = a.content[カウンタ];
		}
		b.長さ = 長さ + a.長さ;
	}
	関数: 演算子 + (整数:a) => (文字列:b){
		文字列:str = 整数文字変換(a);
		もし(絶対値(a) >= 10)ならば{
    		(a <= 10)まで{
    		    a /= 10;
    		    文字列:temp = 整数文字変換(a);
    		    str = temp + str;
    		}
		}
		b.content = メモリ確保(バイト数(*content) * 長さ);
		(長さ)回繰り返す{
			b.content[カウンタ] = content[カウンタ];
		}
		b.長さ = 長さ;
		b += str;
	}
	関数: 演算子 + (整数32:a) => (文字列:b){
		文字列:str = 整数文字変換(a);
    	(a <= 10)まで{
    	    a /= 10;
    	    文字列:temp = 整数文字変換(a);
    	    str = temp + str;
    	}
		b.content = メモリ確保(バイト数(*content) * 長さ);
		(長さ)回繰り返す{
			b.content[カウンタ] = content[カウンタ];
		}
		b.長さ = 長さ;
		b += str;
	}
	関数: 演算子 + (実数:a) => (文字列:b){
		整数:inta = a;
    	実数:reala = a - inta;
    	文字列:str = "";
    	str += inta;
    	str += ".";
    	(6)回繰り返す{
    	    reala *= 10.0;
    	    str += 整数文字変換(reala);
    	}
		b.content = メモリ確保(バイト数(*content) * 長さ);
		(長さ)回繰り返す{
			b.content[カウンタ] = content[カウンタ];
		}
		b.長さ = 長さ;
		b += str;
	}
	関数: 演算子 == (文字列:a) => (真偽:b){
		b = 真;
		もし(長さ != a.長さ)ならば{
			終了(偽);
		}
		(長さ)回繰り返す{
			もし(content[カウンタ] != a.content[カウンタ])ならば{
				終了(偽);
			}
		}
	}
	関数: 演算子 == (*文字:offset, 整数:l) => (真偽:b){
		b = 真;
		もし(長さ != l)ならば{
			終了(偽);
		}
		(長さ)回繰り返す{
			もし(content[カウンタ] != offset[カウンタ])ならば{
				終了(偽);
			}
		}
	}
	関数: 演算子 != (文字列:a) => (真偽:b){
		b = 偽;
		もし(長さ != a.長さ)ならば{
			終了(真);
		}
		(長さ)回繰り返す{
			もし(content[カウンタ] != a.content[カウンタ])ならば{
				終了(真);
			}
		}
	}
	関数: 演算子 != (*文字:offset, 整数:l) => (真偽:b){
		b = 偽;
		もし(長さ != l)ならば{
			終了(真);
		}
		(長さ)回繰り返す{
			もし(content[カウンタ] != offset[カウンタ])ならば{
				終了(真);
			}
		}
	}
	関数:${"ja":"切り取り", "natja":"切り取り", "en":"substr", "naten":"substr"}$(整数:s, 整数:e) => (文字列:b){
		もし(s > 長さ)ならば{
			s = 長さ;
		}
		もし(e > 長さ)ならば{
			e = 長さ;
		}
		b.content = メモリ確保(バイト数(*content) * (e - s));
		b.長さ = e - s;
		(整数:i = s;)から(i == e)まで(i+=1;){
			b.content[i - s] = content[i];
		}
	}
	関数:${"ja":"範囲切り取り", "natja":"範囲切り取り", "en":"substrRange", "naten":"substrRange"}$(整数:s, 整数:l) => (文字列:b){
		もし(s > 長さ)ならば{
			s = 長さ;
		}
		もし(s + l > 長さ)ならば{
			l = 長さ - s;
		}
		b.content = メモリ確保(バイト数(*content) * l);
		b.長さ = l;
		(整数:i = s;)から(i == (s + l))まで(i+=1;){
			b.content[i - s] = content[i];
		}
	}
	関数:${"ja":"分割", "natja":"分割", "en":"separate", "naten":"separate"}$(文字:a) => (配列<文字列>:b){
		配列<文字列>:結果();
		整数:開始 = 0;
		(長さ)回繰り返す{
			もし(content[カウンタ] == a)ならば{
				文字列:temp = 切り取り(開始, カウンタ);
				結果.追加(temp);
				開始 = カウンタ + 1;
			}
		}
		結果.追加(切り取り(開始, 長さ));
		終了(結果);
	}
	関数:${"ja":"整数変換", "natja":"整数変換", "en":"toInteger", "naten":"toInteger"}$() => (整数:a){
		a = 0;
		(長さ)回繰り返す{
			文字:c = content[カウンタ];
			もし(c != '-')ならば{
				a *= 10;
			}
			もし(c == '1')ならば{
				a += 1;	
			}
			もし(c == '2')ならば{
				a += 2;	
			}
			もし(c == '3')ならば{
				a += 3;	
			}
			もし(c == '4')ならば{
				a += 4;	
			}
			もし(c == '5')ならば{
				a += 5;	
			}
			もし(c == '6')ならば{
				a += 6;	
			}
			もし(c == '7')ならば{
				a += 7;	
			}
			もし(c == '8')ならば{
				a += 8;
			}
			もし(c == '9')ならば{
				a += 9;
			}
		}
		もし(content[0] == '-')ならば{
			a *= -1.0;
		}
	}
	関数:${"ja":"実数変換", "natja":"実数変換", "en":"toDouble", "naten":"toDouble"}$() => (実数:a){
		a = 0;
		もし(content[0] == '-')ならば{
			文字列:str = 範囲切り取り(1, 長さ);
			a = str.実数変換() * -1.0;
		}
		でなければ{
			配列<文字列>:b = 分割('.');
			もし(b.長さ() != 2)ならば{
				終了(0.0);
			}
			a += b.content[0].整数変換();
			実数:temp = b.content[1].整数変換();
			(b.content[1].長さ)回繰り返す{
				temp *= 0.1;
			}
			a += temp;
		}
	}
	関数:${"ja":"置換", "natja":"置換", "en":"replace", "naten":"replace"}$(文字列:a, 文字列:b) => (文字列:c){
		文字列:結果();
		整数:開始 = 0;
		(長さ)回繰り返す{
			もし(content[カウンタ] == a.content[0])ならば{
				もし(範囲切り取り(カウンタ, a.長さ) == a)ならば{
					結果 += 切り取り(開始, カウンタ);
					結果 += b;
					カウンタ += a.長さ;
					開始 = カウンタ;
				}
			}
		}
		結果 += 切り取り(開始, 長さ);
		終了(結果);
	}
}
関数: ${"ja":"文字列表示", "natja":"文字列表示", "en":"printString", "naten":"printString"}$(文字列: a) => (){
	_文字列表示(a.content, a.長さ);
}
関数: ${"ja":"表示", "natja":"表示", "en":"print", "naten":"print"}$(実数: x) => (){
	実数表示(x);
}
関数: ${"ja":"表示", "natja":"表示", "en":"print", "naten":"print"}$(整数: n) => (){
	実数表示(n);
}
関数: ${"ja":"表示", "natja":"表示", "en":"print", "naten":"print"}$(整数32: n) => (){
	実数表示(n);
}
関数: ${"ja":"表示", "natja":"表示", "en":"print", "naten":"print"}$(文字列: a) => (){
	文字列表示(a);
}
関数: ${"ja":"glGetUniformLocation", "natja":"glGetUniformLocation", "en":"glGetUniformLocation", "naten":"glGetUniformLocation"}$(整数32: i, 文字列: a) => (整数32: loc){
	loc = _glGetUniformLocation(i, a.content, a.長さ);
}
関数: ${"ja":"サンプルモデルロード", "natja":"サンプルモデルロード", "en":"loadSampleModel", "naten":"loadSampleModel"}$(文字列: a) => (文字列:b){
	*文字列:data = "";
	もし(a == "teapot")ならば{
		data = getTeapot();
	}
	もし(a == "mountains")ならば{
		data = getMountains();
	}
	もし(a == "teddybear")ならば{
		data = getTeddybear();
	}
	もし(a == "cow")ならば{
		data = getCow();
	}
	もし(a == "fox")ならば{
		data = getFox();
	}
	もし(a == "robot")ならば{
		data = getRobot();
	}
	もし(a == "checkpoint")ならば{
		data = getCheckpoint();
	}
	b = *data;
}
クラス: ${"ja":"ベクトル3D", "natja":"ベクトル3D", "en":"Vector3D", "naten":"Vector3D"}${
公開:
	実数: x;
	実数: y;
	実数: z;
	関数: ベクトル3D(実数: a, 実数: b, 実数: c) => (){
		x = a;
		y = b;
		z = c;
	}
	関数: ${"ja":"長さ", "natja":"長さ", "en":"length", "naten":"length"}$() => (実数: l){
		l = 平方根(x * x + y * y + z * z);
	}
	関数: ${"ja":"正規化", "natja":"正規化", "en":"normalize", "naten":"normalize"}$() => (){
		実数: l = 平方根((x * x) + (y * y) + (z * z));
		x = x / l;
		y = y / l;
		z = z / l;
	}
	関数: 演算子 + (ベクトル3D: a) => (ベクトル3D: b){
		b.x = a.x + x;
		b.y = a.y + y;
		b.z = a.z + z;
	}
	関数: 演算子 - (ベクトル3D: a) => (ベクトル3D: b){
		b.x = x - a.x;
		b.y = y - a.y;
		b.z = z - a.z;
	}
	関数: 演算子 * (実数: k) => (ベクトル3D: b){
		b.x = x * k;
		b.y = y * k;
		b.z = z * k;
	}
	関数: 演算子 * (ベクトル3D: a) => (ベクトル3D: b){
		b.x = y * a.z - z * a.y;
		b.y = z * a.x - x * a.z;
		b.z = x * a.y - y * a.x;
	}
	関数: 演算子 / (実数: k) => (ベクトル3D: b){
		b.x = x / k;
		b.y = y / k;
		b.z = z / k;		
	}
	関数: 演算子 == (ベクトル3D:a) => (真偽:b){
		b = ((a.x == x) && (a.y == y) && (a.z == z));
	}
	関数: 演算子 != (ベクトル3D:a) => (真偽:b){
		b = ((a.x != x) || (a.y != y) || (a.z != z));
	}
}
関数: ${"ja":"ベクトル3Dの和", "natja":"ベクトル3Dの和", "en":"addVector3D", "naten":"addVector3D"}$(ベクトル3D: a, ベクトル3D: b) => (ベクトル3D: result){
	result.x = a.x + b.x;
	result.y = a.y + b.y;
	result.z = a.z + b.z;
}
関数: ${"ja":"ベクトル3Dの差", "natja":"ベクトル3Dの差", "en":"subVector3D", "naten":"subVector3D"}$(ベクトル3D: a, ベクトル3D: b) => (ベクトル3D: result){
	result.x = a.x - b.x;
	result.y = a.y - b.y;
	result.z = a.z - b.z;
}
関数: ${"ja":"ベクトル3Dの内積", "natja":"ベクトル3Dの内積", "en":"dotVector3D", "naten":"dotVector3D"}$(ベクトル3D: a, ベクトル3D: b) => (実数: x){
	x = (a.x * b.x) + (a.y * b.y) + (a.z * b.z);
}
関数: ${"ja":"ベクトル3Dの外積", "natja":"ベクトル3Dの外積", "en":"crossVector3D", "naten":"crossVector3D"}$(ベクトル3D: a, ベクトル3D: b) => (ベクトル3D: result){
	result.x = (a.y * b.z) - (a.z * b.y);
	result.y = (a.z * b.x) - (a.x * b.z);
	result.z = (a.x * b.y) - (a.y * b.x);
}
関数: ${"ja":"ベクトル3D拡大", "natja":"ベクトル3D拡大", "en":"extendVector3D", "naten":"extendVector3D"}$(ベクトル3D: a, 実数: x) => (ベクトル3D: result){
	result.x = a.x * x;
	result.y = a.y * x;
	result.z = a.z * x;
}
関数: ${"ja":"ベクトル3D縮小", "natja":"ベクトル3D縮小", "en":"divVector3D", "naten":"divVector3D"}$(ベクトル3D: a, 実数: x) => (ベクトル3D: result){
	もし(x == 0.0)ならば{
		表示(10000000);
	}
	result.x = a.x / x;
	result.y = a.y / x;
	result.z = a.z / x;
}
クラス: ${"ja":"行列4x4", "natja":"行列4x4", "en":"Matrix4x4", "naten":"Matrix4x4"}${
公開: 	実数: matrix[16];
	関数: 行列4x4() => (){
		matrix = [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0];
	}
	関数: ${"ja":"単位化", "natja":"単位化", "en":"identity", "naten":"identity"}$() => (){
		matrix = [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0];
	}
	関数: ${"ja":"移動", "natja":"移動", "en":"translate", "naten":"translate"}$(ベクトル3D: offset) => (){
		実数: mat12 = matrix[12];
		実数: mat13 = matrix[13];
		実数: mat14 = matrix[14];
		実数: mat15 = matrix[15];
		matrix[12] = matrix[0] * offset.x + matrix[4] * offset.y + matrix[8] * offset.z + mat12;
		matrix[13] = matrix[1] * offset.x + matrix[5] * offset.y + matrix[9] * offset.z + mat13;
		matrix[14] = matrix[2] * offset.x + matrix[6] * offset.y + matrix[10] * offset.z + mat13;
		matrix[15] = matrix[3] * offset.x + matrix[7] * offset.y + matrix[11] * offset.z + mat15;
	}
	関数: ${"ja":"回転", "natja":"回転", "en":"rotate", "naten":"rotate"}$(ベクトル3D: axis, 実数: theta) => (){
		axis.正規化();
		実数: s = sin(theta);
		実数: c = cos(theta);
		実数: t = 1.0 - c;
		実数: a00 = matrix[0];
		実数: a01 = matrix[1];
		実数: a02 = matrix[2];
		実数: a03 = matrix[3];
		実数: a10 = matrix[4];
		実数: a11 = matrix[5];
		実数: a12 = matrix[6];
		実数: a13 = matrix[7];
		実数: a20 = matrix[8];
		実数: a21 = matrix[9];
		実数: a22 = matrix[10];
		実数: a23 = matrix[11];
		実数: b00 = axis.x * axis.x * t + c;
		実数: b01 = axis.y * axis.x * t + axis.z * s;
		実数: b02 = axis.z * axis.x * t - axis.y * s;
		実数: b10 = axis.x * axis.y * t - axis.z * s;
		実数: b11 = axis.y * axis.y * t + c;
		実数: b12 = axis.z * axis.y * t + axis.x * s;
		実数: b20 = axis.x * axis.z * t + axis.y * s;
		実数: b21 = axis.y * axis.z * t - axis.x * s;
		実数: b22 = axis.z * axis.z * t + c;
		matrix[0] = a00 * b00 + a10 * b01 + a20 * b02;
		matrix[1] = a01 * b00 + a11 * b01 + a21 * b02;
		matrix[2] = a02 * b00 + a12 * b01 + a22 * b02;
		matrix[3] = a03 * b00 + a13 * b01 + a23 * b02;
		matrix[4] = a00 * b10 + a10 * b11 + a20 * b12;
		matrix[5] = a01 * b10 + a11 * b11 + a21 * b12;
		matrix[6] = a02 * b10 + a12 * b11 + a22 * b12;
		matrix[7] = a03 * b10 + a13 * b11 + a23 * b12;
		matrix[8] = a00 * b20 + a10 * b21 + a20 * b22;
		matrix[9] = a01 * b20 + a11 * b21 + a21 * b22;
		matrix[10] = a02 * b20 + a12 * b21 + a22 * b22;
		matrix[11] = a03 * b20 + a13 * b21 + a23 * b22;
	}
	関数: ${"ja":"拡大縮小", "natja":"拡大縮小", "en":"scale", "naten":"scale"}$(実数: x, 実数: y, 実数: z) => (){
		matrix[0] = matrix[0] * x;
		matrix[1] = matrix[1] * x;
		matrix[2] = matrix[2] * x;
		matrix[3] = matrix[3] * x;
		matrix[4] = matrix[4] * y;
		matrix[5] = matrix[5] * y;
		matrix[6] = matrix[6] * y;
		matrix[7] = matrix[7] * y;
		matrix[8] = matrix[8] * z;
		matrix[9] = matrix[9] * z;
		matrix[10] = matrix[10] * z;
		matrix[11] = matrix[11] * z;
	}
	関数: 演算子 *(行列4x4:a) => (行列4x4:b){
		b.matrix[0] = a.matrix[0] * matrix[0] + a.matrix[1] * matrix[4] + a.matrix[2] * matrix[8] + a.matrix[3] * matrix[12];
		b.matrix[1] = a.matrix[0] * matrix[1] + a.matrix[1] * matrix[5] + a.matrix[2] * matrix[9] + a.matrix[3] * matrix[13];
		b.matrix[2] = a.matrix[0] * matrix[2] + a.matrix[1] * matrix[6] + a.matrix[2] * matrix[10] + a.matrix[3] * matrix[14];
		b.matrix[3] = a.matrix[0] * matrix[3] + a.matrix[1] * matrix[7] + a.matrix[2] * matrix[11] + a.matrix[3] * matrix[15];
		b.matrix[4] = a.matrix[4] * matrix[0] + a.matrix[5] * matrix[4] + a.matrix[6] * matrix[8] + a.matrix[7] * matrix[12];
		b.matrix[5] = a.matrix[4] * matrix[1] + a.matrix[5] * matrix[5] + a.matrix[6] * matrix[9] + a.matrix[7] * matrix[13];
		b.matrix[6] = a.matrix[4] * matrix[2] + a.matrix[5] * matrix[6] + a.matrix[6] * matrix[10] + a.matrix[7] * matrix[14];
		b.matrix[7] = a.matrix[4] * matrix[3] + a.matrix[5] * matrix[7] + a.matrix[6] * matrix[11] + a.matrix[7] * matrix[15];
		b.matrix[8] = a.matrix[8] * matrix[0] + a.matrix[9] * matrix[4] + a.matrix[10] * matrix[8] + a.matrix[11] * matrix[12];
		b.matrix[9] = a.matrix[8] * matrix[1] + a.matrix[9] * matrix[5] + a.matrix[10] * matrix[9] + a.matrix[11] * matrix[13];
		b.matrix[10] = a.matrix[8] * matrix[2] + a.matrix[9] * matrix[6] + a.matrix[10] * matrix[10] + a.matrix[11] * matrix[14];
		b.matrix[11] = a.matrix[8] * matrix[3] + a.matrix[9] * matrix[7] + a.matrix[10] * matrix[11] + a.matrix[11] * matrix[15];
		b.matrix[12] = a.matrix[12] * matrix[0] + a.matrix[13] * matrix[4] + a.matrix[14] * matrix[8] + a.matrix[15] * matrix[12];
		b.matrix[13] = a.matrix[12] * matrix[1] + a.matrix[13] * matrix[5] + a.matrix[14] * matrix[9] + a.matrix[15] * matrix[13];
		b.matrix[14] = a.matrix[12] * matrix[2] + a.matrix[13] * matrix[6] + a.matrix[14] * matrix[10] + a.matrix[15] * matrix[14];
		b.matrix[15] = a.matrix[12] * matrix[3] + a.matrix[13] * matrix[7] + a.matrix[14] * matrix[11] + a.matrix[15] * matrix[15];
	}
}
関数: ${"ja":"カメラ行列", "natja":"カメラ行列", "en":"setCameraMat", "naten":"setCameraMat"}$(行列4x4: m, ベクトル3D: pos, ベクトル3D: lookAt, ベクトル3D: up) => (行列4x4: res){
	ベクトル3D: newForward(lookAt.x - pos.x, lookAt.y - pos.y, lookAt.z - pos.z);
	ベクトル3D: a(0.0, 0.0, 0.0);
	a = ベクトル3D拡大(newForward, ベクトル3Dの内積(up, newForward));
	ベクトル3D: newUp(up.x - a.x, up.y - a.y, up.z - a.z);
	newUp.正規化();
	ベクトル3D: newRight(0, 0, 0);
	newRight = ベクトル3Dの外積(newUp, newForward);
	m.matrix = [newRight.x, newUp.x, newForward.x, 0.0, newRight.y, newUp.y, newForward.y, 0.0, newRight.z, newUp.z, newForward.z, 0.0, 0 - ベクトル3Dの内積(newRight, pos), 0 - ベクトル3Dの内積(newUp, pos), 0 - ベクトル3Dの内積(newForward, pos), 1.0];
	終了(m);
}
関数: ${"ja":"視点行列3D", "natja":"視点行列3D", "en":"perspectiveMat3D", "naten":"perspectiveMat3D"}$(行列4x4: m, 実数: fov, 実数: width, 実数: height, 実数: zN, 実数: zF) => (行列4x4: result){
	実数: PI = 3.14159265358979312;
	実数: fov = 1.0 / tan((90.0 / 360.0) * PI);
	実数: aspectRatio = width / height;
	実数: zNear = zN;
	実数: zFar = zF;
	実数: zQ = zF / (zF - zN);
	m.matrix = [aspectRatio * fov, 0.0, 0.0, 0.0, 0.0, fov, 0.0, 0.0, 0.0, 0.0, zQ, 1.0, 0.0, 0.0, (0 - zFar * zNear) / (zFar - zNear), 0.0];
	終了(m);
}
関数: ${"ja":"視点行列2D", "natja":"視点行列2D", "en":"perspectiveMat2D", "naten":"perspectiveMat2D"}$(行列4x4: m, 実数: left, 実数: right, 実数: bottom, 実数: top, 実数: near, 実数: far) => (行列4x4: result){
	m.matrix = [2.0 / (right - left), 0.0, 0.0, 0.0, 0.0, 2.0 / (top - bottom), 0.0, 0.0, 0.0, 0.0, 0 - 2.0 / (near - far), 0.0, 0 - (right + left) / (right - left), 0 - (top + bottom) / (top - bottom), 0 - (far + near) / (far - near), 1.0];
	終了(m);
}
関数: ${"ja":"行列4x4の積", "natja":"行列4x4の積", "en":"mulMatrix4x4", "naten":"mulMatrix4x4"}$(行列4x4: a, 行列4x4: b) => (行列4x4: out){
	out.matrix[0] = b.matrix[0] * a.matrix[0] + b.matrix[1] * a.matrix[4] + b.matrix[2] * a.matrix[8] + b.matrix[3] * a.matrix[12];
	out.matrix[1] = b.matrix[0] * a.matrix[1] + b.matrix[1] * a.matrix[5] + b.matrix[2] * a.matrix[9] + b.matrix[3] * a.matrix[13];
	out.matrix[2] = b.matrix[0] * a.matrix[2] + b.matrix[1] * a.matrix[6] + b.matrix[2] * a.matrix[10] + b.matrix[3] * a.matrix[14];
	out.matrix[3] = b.matrix[0] * a.matrix[3] + b.matrix[1] * a.matrix[7] + b.matrix[2] * a.matrix[11] + b.matrix[3] * a.matrix[15];
	out.matrix[4] = b.matrix[4] * a.matrix[0] + b.matrix[5] * a.matrix[4] + b.matrix[6] * a.matrix[8] + b.matrix[7] * a.matrix[12];
	out.matrix[5] = b.matrix[4] * a.matrix[1] + b.matrix[5] * a.matrix[5] + b.matrix[6] * a.matrix[9] + b.matrix[7] * a.matrix[13];
	out.matrix[6] = b.matrix[4] * a.matrix[2] + b.matrix[5] * a.matrix[6] + b.matrix[6] * a.matrix[10] + b.matrix[7] * a.matrix[14];
	out.matrix[7] = b.matrix[4] * a.matrix[3] + b.matrix[5] * a.matrix[7] + b.matrix[6] * a.matrix[11] + b.matrix[7] * a.matrix[15];
	out.matrix[8] = b.matrix[8] * a.matrix[0] + b.matrix[9] * a.matrix[4] + b.matrix[10] * a.matrix[8] + b.matrix[11] * a.matrix[12];
	out.matrix[9] = b.matrix[8] * a.matrix[1] + b.matrix[9] * a.matrix[5] + b.matrix[10] * a.matrix[9] + b.matrix[11] * a.matrix[13];
	out.matrix[10] = b.matrix[8] * a.matrix[2] + b.matrix[9] * a.matrix[6] + b.matrix[10] * a.matrix[10] + b.matrix[11] * a.matrix[14];
	out.matrix[11] = b.matrix[8] * a.matrix[3] + b.matrix[9] * a.matrix[7] + b.matrix[10] * a.matrix[11] + b.matrix[11] * a.matrix[15];
	out.matrix[12] = b.matrix[12] * a.matrix[0] + b.matrix[13] * a.matrix[4] + b.matrix[14] * a.matrix[8] + b.matrix[15] * a.matrix[12];
	out.matrix[13] = b.matrix[12] * a.matrix[1] + b.matrix[13] * a.matrix[5] + b.matrix[14] * a.matrix[9] + b.matrix[15] * a.matrix[13];
	out.matrix[14] = b.matrix[12] * a.matrix[2] + b.matrix[13] * a.matrix[6] + b.matrix[14] * a.matrix[10] + b.matrix[15] * a.matrix[14];
	out.matrix[15] = b.matrix[12] * a.matrix[3] + b.matrix[13] * a.matrix[7] + b.matrix[14] * a.matrix[11] + b.matrix[15] * a.matrix[15];
}
クラス: ${"ja":"光源クラス", "natja":"光源クラス", "en":"LightClass", "naten":"LightClass"}${
	ベクトル3D: ${"ja":"座標", "natja":"座標", "en":"pos", "naten":"pos"}$;
	実数:半径;
	ベクトル3D: ambient;
	ベクトル3D: diffuse;
	ベクトル3D: specular;
	整数32:posLoc;
	整数32:radiusLoc;
	整数32:ambientLoc;
	整数32:diffuseLoc;
	整数32:specularLoc;
	関数:光源クラス(ベクトル3D:p, 実数:r, ベクトル3D:a, ベクトル3D:d, ベクトル3D:s, 整数: id) => (){
		座標 = p;
		半径 = r;
		ambient = a;
		diffuse = d;
		specular = s;
		文字列:temp = "pointLights[";
		temp += id;
		temp += "]";
		文字列:posStr = temp + ".position";
		posLoc = glGetUniformLocation(0, posStr);
		文字列:radiusStr = temp + ".radius";
		radiusLoc = glGetUniformLocation(0, radiusStr);
		文字列:ambientStr = temp + ".ambient";
		ambientLoc = glGetUniformLocation(0, ambientStr);
		文字列:diffuseStr = temp + ".diffuse";
		diffuseLoc = glGetUniformLocation(0, diffuseStr);
		文字列:specularStr = temp + ".specular";
		specularLoc = glGetUniformLocation(0, specularStr);
	}
	関数: ${"ja":"座標設定", "natja":"座標設定", "en":"setPos", "naten":"setPos"}$(ベクトル3D: coord) => (){
		座標 = coord;
	}
}
クラス: ${"ja":"モデル", "natja":"モデル", "en":"Model", "naten":"Model"}${
公開:
    ベクトル3D: ${"ja":"色", "natja":"色", "en":"color", "naten":"color"}$;
	ベクトル3D: ${"ja":"座標", "natja":"座標", "en":"pos", "naten":"pos"}$;
	整数:lightID;
	ベクトル3D:scale;
	関数: モデル(*実数: data, 整数: num, ベクトル3D: c, ベクトル3D: p, 整数: s) => (){
		scale.ベクトル3D(1.0, 1.0, 1.0);
		vertices = data;
		pointNum = num;
		色 = c;
		座標 = p;
		shaderID = s;
		lightID = -1;
		modelMat.単位化();
		transMat.単位化();
		scaleMat.単位化();
		rotateMat.単位化();
		defaultRotateMat.単位化();
		もし(shaderID == 0)ならば{
			viewPosUniLoc = glGetUniformLocation(0, "viewPos");
			objectColorUniLoc = glGetUniformLocation(0, "objectColor");
			dirLightDirUniLoc = glGetUniformLocation(0, "dirLight.direction");
			dirLightAmbientUniLoc = glGetUniformLocation(0, "dirLight.ambient");
			dirLightDiffuseUniLoc = glGetUniformLocation(0, "dirLight.diffuse");
			dirLightSpecularUniLoc = glGetUniformLocation(0, "dirLight.specular");
		}
		もし(shaderID == 1)ならば{
			lightColorUniLoc = glGetUniformLocation(1, "lightColor");
		}
		projMatUniformLoc = glGetUniformLocation(shaderID, "uProjMat");
		viewMatUniformLoc = glGetUniformLocation(shaderID, "uViewMat");
		modelMatUniformLoc = glGetUniformLocation(shaderID, "uModelMat");
		buffer = glCreateBuffer();
		glBindBuffer(34962, buffer);
		glBufferData(34962, vertices, num * 6, 35044);
	}
	関数: モデル(*実数: data, 整数: num, ベクトル3D: c, ベクトル3D: p, 整数: s, 整数:l) => (){
		scale.ベクトル3D(1.0, 1.0, 1.0);
		lightID = l;
		vertices = data;
		pointNum = num;
		色 = c;
		座標 = p;
		shaderID = s;
		modelMat.単位化();
		transMat.単位化();
		scaleMat.単位化();
		rotateMat.単位化();
		defaultRotateMat.単位化();
		もし(shaderID == 0)ならば{
			viewPosUniLoc = glGetUniformLocation(0, "viewPos");
			objectColorUniLoc = glGetUniformLocation(0, "objectColor");
			dirLightDirUniLoc = glGetUniformLocation(0, "dirLight.direction");
			dirLightAmbientUniLoc = glGetUniformLocation(0, "dirLight.ambient");
			dirLightDiffuseUniLoc = glGetUniformLocation(0, "dirLight.diffuse");
			dirLightSpecularUniLoc = glGetUniformLocation(0, "dirLight.specular");
		}
		もし(shaderID == 1)ならば{
			lightColorUniLoc = glGetUniformLocation(1, "lightColor");
		}
		projMatUniformLoc = glGetUniformLocation(shaderID, "uProjMat");
		viewMatUniformLoc = glGetUniformLocation(shaderID, "uViewMat");
		modelMatUniformLoc = glGetUniformLocation(shaderID, "uModelMat");
		buffer = glCreateBuffer();
		glBindBuffer(34962, buffer);
		glBufferData(34962, vertices, num * 6, 35044);
	}
	関数: ${"ja":"座標設定", "natja":"座標設定", "en":"setPos", "naten":"setPos"}$(ベクトル3D: coord) => (){
		座標 = coord;
	}
	関数: ${"ja":"移動", "natja":"移動", "en":"translate", "naten":"translate"}$(ベクトル3D: offset) => (){
		座標 = ベクトル3Dの和(座標, offset);
	}
	関数: ${"ja":"拡大縮小設定", "natja":"拡大縮小設定", "en":"setScale", "naten":"setScale"}$(実数: x, 実数: y, 実数: z) => (){
		scale.x = x;
		scale.y = y;
		scale.z = z;
	}
	関数: ${"ja":"拡大縮小", "natja":"拡大縮小", "en":"scale", "naten":"scale"}$(実数: x, 実数: y, 実数: z) => (){
		scale.x *= x;
		scale.y *= y;
		scale.z *= z;
	}
	関数: ${"ja":"回転設定", "natja":"回転設定", "en":"setRotate", "naten":"setRotate"}$(ベクトル3D: axis, 実数: t) => (){
		defaultRotateMat.単位化();
		defaultRotateMat.回転(axis, t);
	}
	関数: ${"ja":"回転", "natja":"回転", "en":"rotate", "naten":"rotate"}$(ベクトル3D: axis, 実数: t) => (){
		行列4x4: temp();
		temp.単位化();
		temp.回転(axis, t);
		rotateMat = 行列4x4の積(temp, rotateMat);
	}
	関数: ${"ja":"回転", "natja":"回転", "en":"rotate", "naten":"rotate"}$(ベクトル3D: axis, 実数: t, ベクトル3D: offcenter) => (){
		行列4x4: temp();
		temp.単位化();
		temp.移動(offcenter);
		rotateMat = 行列4x4の積(temp, rotateMat);
		temp.単位化();
		temp.回転(axis, t);
		rotateMat = 行列4x4の積(temp, rotateMat);
	}
	関数: ${"ja":"色設定", "natja":"色設定", "en":"setColor", "naten":"setColor"}$(ベクトル3D: c) => (){
		色 = c;
	}
	関数: ${"ja":"描画", "natja":"描画", "en":"draw", "naten":"draw"}$(行列4x4: projMat, 行列4x4: viewMat, ベクトル3D: camera, 配列<*光源クラス>:lights, 光源クラス: dirLight) => (){
		実数: PI = 3.14159265358979312;
		scaleMat.単位化();
		scaleMat.拡大縮小(scale.x, scale.y, scale.z);
		transMat.移動(座標);
		modelMat.単位化();
		modelMat = 行列4x4の積(scaleMat, modelMat);
		modelMat = 行列4x4の積(defaultRotateMat, modelMat);
		modelMat = 行列4x4の積(rotateMat, modelMat);
		modelMat = 行列4x4の積(transMat, modelMat);
		glBindBuffer(34962, buffer);
		glEnableVertexAttribArray(0);
		glVertexAttribPointer(0, 3, 5126, 0, 6 * 4, 0);
		glEnableVertexAttribArray(1);
		glVertexAttribPointer(1, 3, 5126, 0, 6 * 4, 3 * 4);
		glUseProgram(shaderID);
		もし(shaderID == 0)ならば{
			glUniform3f(objectColorUniLoc, 色.x, 色.y, 色.z);
			glUniform3f(viewPosUniLoc, camera.x, camera.y, camera.z);
			glUniform3f(dirLightDirUniLoc, dirLight.座標.x, dirLight.座標.y, dirLight.座標.z);
			glUniform3f(dirLightAmbientUniLoc, dirLight.ambient.x, dirLight.ambient.y, dirLight.ambient.z);
			glUniform3f(dirLightDiffuseUniLoc, dirLight.diffuse.x, dirLight.diffuse.y, dirLight.diffuse.z);
			glUniform3f(dirLightSpecularUniLoc, dirLight.specular.x, dirLight.specular.y, dirLight.specular.z);
			(lights.長さ())回繰り返す{
				*光源クラス:lightPtr = lights.取得(カウンタ);
				glUniform3f(lightPtr -> posLoc, lightPtr -> 座標.x, lightPtr -> 座標.y, lightPtr -> 座標.z);
				glUniform3f(lightPtr -> ambientLoc, lightPtr -> ambient.x, lightPtr -> ambient.y, lightPtr -> ambient.z);
				glUniform3f(lightPtr -> diffuseLoc, lightPtr -> diffuse.x, lightPtr -> diffuse.y, lightPtr -> diffuse.z);
				glUniform3f(lightPtr -> specularLoc, lightPtr -> specular.x, lightPtr -> specular.y, lightPtr -> specular.z);
				glUniform1f(lightPtr -> radiusLoc, lightPtr -> 半径);
			}
		}
		もし(shaderID == 1)ならば{
			glUniform3f(lightColorUniLoc, 色.x, 色.y, 色.z);
		}
		glUniformMatrix4fv(projMatUniformLoc, 0, projMat.matrix);
		glUniformMatrix4fv(viewMatUniformLoc, 0, viewMat.matrix);
		glUniformMatrix4fv(modelMatUniformLoc, 0, modelMat.matrix);
		
		glBindBuffer(34962, buffer);
		glDrawArrays(4, 0, pointNum);
		rotateMat.単位化();
		transMat.単位化();
		scaleMat.単位化();
	}
非公開: 	
	*実数: vertices;
	整数: pointNum;
	整数32: buffer;
	行列4x4: modelMat;
	行列4x4: transMat;
	行列4x4: scaleMat;
	行列4x4: rotateMat;
	行列4x4: defaultRotateMat;
	整数: shaderID;
	整数32: viewPosUniLoc;
	整数32: lightPosUniLoc;
	整数32: lightColorUniLoc;
	整数32: objectColorUniLoc;
	整数32: dirLightDirUniLoc;
	整数32: dirLightAmbientUniLoc;
	整数32: dirLightDiffuseUniLoc;
	整数32: dirLightSpecularUniLoc;
	整数32: projMatUniformLoc;
	整数32: viewMatUniformLoc;
	整数32: modelMatUniformLoc;
}
クラス: ${"ja":"カメラ", "natja":"カメラ", "en":"Camera", "naten":"Camera"}${
公開:
    ベクトル3D: ${"ja":"座標", "natja":"座標", "en":"pos", "naten":"pos"}$;
	実数: ${"ja":"感度", "natja":"感度", "en":"sensitivity", "naten":"sensitivity"}$;
 	関数: カメラ(ベクトル3D: p) => (){
		座標 = p;
		view.ベクトル3D(0.0, 0.0, 1.0);
		lookDir.ベクトル3D(0.0, 0.0, 1.0);
		up.ベクトル3D(0.0, 1.0, 0.0);
		yaw = 90.0;
		pitch = 0.0;
		感度 = 1.0;
	}
	関数: ${"ja":"座標設定", "natja":"座標設定", "en":"setPos", "naten":"setPos"}$(ベクトル3D: p) => (){
		座標 = p;
	}
	関数: ${"ja":"視点角度設定", "natja":"視点角度設定", "en":"setAngle", "naten":"setAngle"}$(実数:y, 実数:p) => (){
		yaw = y;
		pitch = p;
	}
	関数: ${"ja":"感度設定", "natja":"感度設定", "en":"setSensitivity", "naten":"setSensitivity"}$(実数: s) => (){
		感度 = s;
	}
	関数: ${"ja":"アップデート", "natja":"アップデート", "en":"update", "naten":"update"}$(実数: xOffset, 実数: yOffset, 実数: elapsedTime) => (行列4x4: result){
		もし(キーチェック(32) == 1)ならば{
			座標.y = 座標.y + elapsedTime * 5.0;
		}
		もし(キーチェック(16) == 1)ならば{
			座標.y = 座標.y - elapsedTime * 5.0;
		}
		もし(キーチェック(65) == 1)ならば{
			座標.z = 座標.z - elapsedTime * sin(ラジアンへ(yaw - 90)) * 5.0;
			座標.x = 座標.x - elapsedTime * cos(ラジアンへ(yaw - 90)) * 5.0;
		}
		もし(キーチェック(68) == 1)ならば{
			座標.z = 座標.z + elapsedTime * sin(ラジアンへ(yaw - 90)) * 5.0;
			座標.x = 座標.x + elapsedTime * cos(ラジアンへ(yaw - 90)) * 5.0;
		}
		もし(キーチェック(87) == 1)ならば{
			座標.z = 座標.z + elapsedTime * sin(ラジアンへ(yaw)) * 5.0;
			座標.x = 座標.x + elapsedTime * cos(ラジアンへ(yaw)) * 5.0;
		}
		もし(キーチェック(83) == 1)ならば{
			座標.z = 座標.z - elapsedTime * sin(ラジアンへ(yaw)) * 5.0;
			座標.x = 座標.x - elapsedTime * cos(ラジアンへ(yaw)) * 5.0;
		}
		yaw = yaw - xOffset * 感度 * elapsedTime;
		pitch = pitch - yOffset * 感度 * elapsedTime;
		もし(pitch < 0 - 89.0)ならば{
			pitch = 0 - 89.0;
		}
		もし(pitch > 89.0)ならば{
			pitch = 89.0;
		}
		lookDir.x = cos(ラジアンへ(yaw)) * cos(ラジアンへ(pitch));
		lookDir.y = sin(ラジアンへ(pitch));
		lookDir.z = sin(ラジアンへ(yaw)) * cos(ラジアンへ(pitch));
		lookDir.正規化();
		result.単位化();
		view = ベクトル3Dの和(lookDir, 座標);
		result = カメラ行列(result, 座標, view, up);
	}
非公開: 	ベクトル3D: view;
	ベクトル3D: lookDir;
	ベクトル3D: up;
	実数: yaw;
	実数: pitch;
}
クラス: ${"ja":"シーン", "natja":"シーン", "en":"Scene", "naten":"Scene"}${
公開:
    配列<*モデル>: ${"ja":"スプライト配列", "natja":"スプライト配列", "en":"sprites", "naten":"sprites"}$;
	配列<*光源クラス>: ${"ja":"光源配列", "natja":"光源配列", "en":"lights", "naten":"lights"}$;
	カメラ: ${"ja":"目", "natja":"目", "en":"camera", "naten":"camera"}$;
	光源クラス: 平行光源;
    関数: シーン() => (){
		last = 時間計測() / 1000.0;
		now = 0.0;
		elapsedTime = 0.0;
		lastX = マウス絶対座標X();
		lastY = マウス絶対座標Y();
		projMat.単位化();
		viewMat.単位化();
		projMat = 視点行列3D(projMat, 90.0, 720.0, 1280.0, 0.100000000000000006, 100.0);
		ベクトル3D: temp(0.0, 0.0, 0 - 4.0);
		目.カメラ(temp);
		スプライト配列.配列();
		光源配列.配列();
		ベクトル3D: 方向(-1.0, -1.0, -1.0);
		ベクトル3D: 白(1.0, 1.0, 1.0);
		平行光源.座標 = 方向;
		平行光源.ambient = 白 * 0.5;
		平行光源.diffuse = 白 * 0.5;
		平行光源.specular = 白 * 0.0;
	}
	関数: ${"ja":"感度設定", "natja":"感度設定", "en":"setSensitivity", "naten":"setSensitivity"}$(実数: 感度) => (){
		目.感度設定(感度);
	}
	関数: ${"ja":"描画", "natja":"描画", "en":"draw", "naten":"draw"}$() => (){
		now = 時間計測() / 1000.0;
		elapsedTime = now - last;
		last = now;
		glClearColor(0.0, 0.0, 0.0, 1.0);
		glClearDepth(1.0);
		glEnable(2929);
		glDepthFunc(515);
		glClear(16640);
		実数: xOffset = マウス絶対座標X() - lastX;
		実数: yOffset = マウス絶対座標Y() - lastY;
		lastX = マウス絶対座標X();
		lastY = マウス絶対座標Y();
		viewMat.単位化();
		viewMat = 目.アップデート(xOffset, yOffset, elapsedTime);
		(スプライト配列.長さ())回繰り返す{
			もし(スプライト配列.取得(カウンタ) -> lightID >= 0)ならば{
				光源配列.取得(スプライト配列.取得(カウンタ) -> lightID) -> 座標設定(スプライト配列.取得(カウンタ) -> 座標);
			}
		}
		(整数: i = 0;)から(i == スプライト配列.size)まで(i = i + 1;){
			スプライト配列.取得(i)->描画(projMat, viewMat, 目.座標, 光源配列, 平行光源);
		}
	}
	関数: ${"ja":"キューブ追加", "natja":"キューブ追加", "en":"addCube", "naten":"addCube"}$(実数: size, ベクトル3D: 色, ベクトル3D: 座標) => (整数: id){
		実数: vertices[12][3][6] = [[[0 - size / 2, 0 - size / 2, 0 - size / 2, 0.0, 0.0, 0 - 1.0], [0 - size / 2, size / 2, 0 - size / 2, 0.0, 0.0, 0 - 1.0], [size / 2, size / 2, 0 - size / 2, 0.0, 0.0, 0 - 1.0]], [[0 - size / 2, 0 - size / 2, 0 - size / 2, 0.0, 0.0, 0 - 1.0], [size / 2, size / 2, 0 - size / 2, 0.0, 0.0, 0 - 1.0], [size / 2, 0 - size / 2, 0 - size / 2, 0.0, 0.0, 0 - 1.0]], [[size / 2, 0 - size / 2, 0 - size / 2, 1.0, 0.0, 0.0], [size / 2, size / 2, 0 - size / 2, 1.0, 0.0, 0.0], [size / 2, size / 2, size / 2, 1.0, 0.0, 0.0]], [[size / 2, 0 - size / 2, 0 - size / 2, 1.0, 0.0, 0.0], [size / 2, size / 2, size / 2, 1.0, 0.0, 0.0], [size / 2, 0 - size / 2, size / 2, 1.0, 0.0, 0.0]], [[size / 2, 0 - size / 2, size / 2, 0.0, 0.0, 1.0], [size / 2, size / 2, size / 2, 0.0, 0.0, 1.0], [0 - size / 2, size / 2, size / 2, 0.0, 0.0, 1.0]], [[size / 2, 0 - size / 2, size / 2, 0.0, 0.0, 1.0], [0 - size / 2, size / 2, size / 2, 0.0, 0.0, 1.0], [0 - size / 2, 0 - size / 2, size / 2, 0.0, 0.0, 1.0]], [[0 - size / 2, 0 - size / 2, size / 2, 0 - 1.0, 0.0, 0.0], [0 - size / 2, size / 2, size / 2, 0 - 1.0, 0.0, 0.0], [0 - size / 2, size / 2, 0 - size / 2, 0 - 1.0, 0.0, 0.0]], [[0 - size / 2, 0 - size / 2, size / 2, 0 - 1.0, 0.0, 0.0], [0 - size / 2, size / 2, 0 - size / 2, 0 - 1.0, 0.0, 0.0], [0 - size / 2, 0 - size / 2, 0 - size / 2, 0 - 1.0, 0.0, 0.0]], [[0 - size / 2, size / 2, 0 - size / 2, 0.0, 1.0, 0.0], [0 - size / 2, size / 2, size / 2, 0.0, 1.0, 0.0], [size / 2, size / 2, size / 2, 0.0, 1.0, 0.0]], [[0 - size / 2, size / 2, 0 - size / 2, 0.0, 1.0, 0.0], [size / 2, size / 2, size / 2, 0.0, 1.0, 0.0], [size / 2, size / 2, 0 - size / 2, 0.0, 1.0, 0.0]], [[size / 2, 0 - size / 2, size / 2, 0.0, 0 - 1.0, 0.0], [0 - size / 2, 0 - size / 2, size / 2, 0.0, 0 - 1.0, 0.0], [0 - size / 2, 0 - size / 2, 0 - size / 2, 0.0, 0 - 1.0, 0.0]], [[size / 2, 0 - size / 2, size / 2, 0.0, 0 - 1.0, 0.0], [0 - size / 2, 0 - size / 2, 0 - size / 2, 0.0, 0 - 1.0, 0.0], [size / 2, 0 - size / 2, 0 - size / 2, 0.0, 0 - 1.0, 0.0]]];
		*モデル: cube = メモリ確保(バイト数(*cube));
		cube->モデル(&vertices, 36, 色, 座標, 0);
		スプライト配列.追加(cube);
		id = スプライト配列.長さ() - 1;
	}
	関数: ${"ja":"直方体追加", "natja":"直方体追加", "en":"addCuboid", "naten":"addCuboid"}$(実数: width, 実数: height, 実数:depth, ベクトル3D: 色, ベクトル3D: 座標) => (整数: id){
		id = キューブ追加(1.0, 色, 座標);
		スプライト配列.取得(id) -> 拡大縮小(width, height, depth);
	}
	関数: ${"ja":"ライト追加", "natja":"ライト追加", "en":"addLight", "naten":"addLight"}$(実数: size, ベクトル3D: 色, ベクトル3D: 座標, 実数:強さ) => (整数: id){
		実数: vertices[12][3][6] = [[[0 - size / 2, 0 - size / 2, 0 - size / 2, 0.0, 0.0, 0 - 1.0], [0 - size / 2, size / 2, 0 - size / 2, 0.0, 0.0, 0 - 1.0], [size / 2, size / 2, 0 - size / 2, 0.0, 0.0, 0 - 1.0]], [[0 - size / 2, 0 - size / 2, 0 - size / 2, 0.0, 0.0, 0 - 1.0], [size / 2, size / 2, 0 - size / 2, 0.0, 0.0, 0 - 1.0], [size / 2, 0 - size / 2, 0 - size / 2, 0.0, 0.0, 0 - 1.0]], [[size / 2, 0 - size / 2, 0 - size / 2, 1.0, 0.0, 0.0], [size / 2, size / 2, 0 - size / 2, 1.0, 0.0, 0.0], [size / 2, size / 2, size / 2, 1.0, 0.0, 0.0]], [[size / 2, 0 - size / 2, 0 - size / 2, 1.0, 0.0, 0.0], [size / 2, size / 2, size / 2, 1.0, 0.0, 0.0], [size / 2, 0 - size / 2, size / 2, 1.0, 0.0, 0.0]], [[size / 2, 0 - size / 2, size / 2, 0.0, 0.0, 1.0], [size / 2, size / 2, size / 2, 0.0, 0.0, 1.0], [0 - size / 2, size / 2, size / 2, 0.0, 0.0, 1.0]], [[size / 2, 0 - size / 2, size / 2, 0.0, 0.0, 1.0], [0 - size / 2, size / 2, size / 2, 0.0, 0.0, 1.0], [0 - size / 2, 0 - size / 2, size / 2, 0.0, 0.0, 1.0]], [[0 - size / 2, 0 - size / 2, size / 2, 0 - 1.0, 0.0, 0.0], [0 - size / 2, size / 2, size / 2, 0 - 1.0, 0.0, 0.0], [0 - size / 2, size / 2, 0 - size / 2, 0 - 1.0, 0.0, 0.0]], [[0 - size / 2, 0 - size / 2, size / 2, 0 - 1.0, 0.0, 0.0], [0 - size / 2, size / 2, 0 - size / 2, 0 - 1.0, 0.0, 0.0], [0 - size / 2, 0 - size / 2, 0 - size / 2, 0 - 1.0, 0.0, 0.0]], [[0 - size / 2, size / 2, 0 - size / 2, 0.0, 1.0, 0.0], [0 - size / 2, size / 2, size / 2, 0.0, 1.0, 0.0], [size / 2, size / 2, size / 2, 0.0, 1.0, 0.0]], [[0 - size / 2, size / 2, 0 - size / 2, 0.0, 1.0, 0.0], [size / 2, size / 2, size / 2, 0.0, 1.0, 0.0], [size / 2, size / 2, 0 - size / 2, 0.0, 1.0, 0.0]], [[size / 2, 0 - size / 2, size / 2, 0.0, 0 - 1.0, 0.0], [0 - size / 2, 0 - size / 2, size / 2, 0.0, 0 - 1.0, 0.0], [0 - size / 2, 0 - size / 2, 0 - size / 2, 0.0, 0 - 1.0, 0.0]], [[size / 2, 0 - size / 2, size / 2, 0.0, 0 - 1.0, 0.0], [0 - size / 2, 0 - size / 2, 0 - size / 2, 0.0, 0 - 1.0, 0.0], [size / 2, 0 - size / 2, 0 - size / 2, 0.0, 0 - 1.0, 0.0]]];
		*モデル: light = メモリ確保(バイト数(*light));
		light->モデル(&vertices, 36, 色, 座標, 1, 光源配列.長さ());
		*光源クラス: lightObject = メモリ確保(バイト数(*lightObject));
		lightObject -> 光源クラス(座標, 強さ, 色 * 0.5, 色 * 0.5, 色 * 0.2, 光源配列.長さ());
		スプライト配列.追加(light);
		光源配列.追加(lightObject);
		id = スプライト配列.長さ() - 1;
	}
	関数: ${"ja":"平行光源設定", "natja":"平行光源設定", "en":"setDirectionalLight", "naten":"setDirectionalLight"}$(ベクトル3D:方向, ベクトル3D:色, 実数:ambient, 実数:diffuse, 実数:specular) => (){
		平行光源.座標 = 方向;
		平行光源.ambient = 色 * ambient;
		平行光源.diffuse = 色 * diffuse;
		平行光源.specular = 色 * specular;
	}
	関数: ${"ja":"_モデル追加", "natja":"_モデル追加", "en":"_addModel", "naten":"_addModel"}$(配列<ベクトル3D>: data, 配列<ベクトル3D>:normals, 配列<整数32>:vertexIndices, 配列<整数32>: normalIndices, ベクトル3D: 色, ベクトル3D: 座標) => (整数: id){
		配列<実数>:vertices();
		もし(normals.長さ() > 0)ならば{
			(vertexIndices.長さ())回繰り返す{
				vertices.追加(data.取得(vertexIndices.取得(カウンタ) - 1).x);
				vertices.追加(data.取得(vertexIndices.取得(カウンタ) - 1).y);
				vertices.追加(data.取得(vertexIndices.取得(カウンタ) - 1).z);
				vertices.追加(normals.取得(normalIndices.取得(カウンタ) - 1).x);
				vertices.追加(normals.取得(normalIndices.取得(カウンタ) - 1).y);
				vertices.追加(normals.取得(normalIndices.取得(カウンタ) - 1).z);
			}
		}
		でなければ{
			配列<ベクトル3D>:三角形();
			(vertexIndices.長さ())回繰り返す{
				三角形.追加(data.取得(vertexIndices.取得(カウンタ) - 1));
				もし((カウンタ % 3) == 2)ならば{
					ベクトル3D:辺1 = 三角形.取得(1) - 三角形.取得(0);
					ベクトル3D:辺2 = 三角形.取得(2) - 三角形.取得(0);
					ベクトル3D:normal = ベクトル3Dの外積(辺1, 辺2);
					normal.正規化();
					(三角形.長さ())回繰り返す{
						vertices.追加(三角形.取得(カウンタ).x);
						vertices.追加(三角形.取得(カウンタ).y);
						vertices.追加(三角形.取得(カウンタ).z);
						vertices.追加(normal.x);
						vertices.追加(normal.y);
						vertices.追加(normal.z);
					}
					三角形 = 三角形.範囲削除(0, 3);
				}
			}
		}
		*モデル: model = メモリ確保(バイト数(*model));
		model->モデル(vertices.content, vertexIndices.長さ(), 色, 座標, 0);
		スプライト配列.追加(model);
		id = スプライト配列.長さ() - 1;
	}
	関数: ${"ja":"モデル追加", "natja":"モデル追加", "en":"addModel", "naten":"addModel"}$(文字列:data, ベクトル3D: 色, ベクトル3D: 座標) => (整数: id){
		配列<ベクトル3D>:vertices();
		配列<文字列>:lines = data.分割('\n');
		配列<整数32>:vertexIndices();
		配列<整数32>:normalIndices();
		配列<整数32>:uvIndices();
		配列<ベクトル3D>:normals();
		(lines.長さ())回繰り返す{
			文字列:line = lines.取得(カウンタ);
			配列<文字列>:words = line.分割(' ');
			もし(words.取得(0) == "v")ならば{
				ベクトル3D:temp(words.取得(1).実数変換(), words.取得(2).実数変換(), words.取得(3).実数変換());
				vertices.追加(temp);
			}
			もし(words.取得(0) == "f")ならば{
				(words.長さ())回繰り返す{
					もし(カウンタ != 0)ならば{
						配列<文字列>:faceData = words.取得(カウンタ).分割('/');
						vertexIndices.追加(faceData.取得(0).整数変換());
						もし(faceData.長さ() == 3)ならば{
							uvIndices.追加(faceData.取得(1).整数変換());
							normalIndices.追加(faceData.取得(2).整数変換());
						}
					}
				}
			}
			もし(words.取得(0) == "vn")ならば{
				ベクトル3D:temp(words.取得(1).実数変換(), words.取得(2).実数変換(), words.取得(3).実数変換());
				normals.追加(temp);
			}
		}
		id = _モデル追加(vertices, normals, vertexIndices, normalIndices, 色, 座標);
	}
非公開: 	行列4x4: projMat;
	行列4x4: viewMat;
	実数: last;
	実数: now;
	実数: elapsedTime;
	実数: lastX;
	実数: lastY;
}
クラス: ${"ja":"ベクトル2D", "natja":"ベクトル2D", "en":"Vector2D", "naten":"Vector2D"}${
公開: 	実数: x;
	実数: y;
	関数: ベクトル2D(実数: a, 実数: b) => (){
		x = a;
		y = b;
	}
	関数: ${"ja":"長さ", "natja":"長さ", "en":"length", "naten":"length"}$() => (実数: l){
		l = 平方根(x * x + y * y);
	}
	関数: ${"ja":"正規化", "natja":"正規化", "en":"normalize", "naten":"normalize"}$() => (){
		実数: l = 平方根(x * x + y * y);
		x = x / l;
		y = y / l;
	}
	関数: 演算子 + (ベクトル2D: a) => (ベクトル2D: b){
		b.x = a.x + x;
		b.y = a.y + y;
	}
	関数: 演算子 - (ベクトル2D: a) => (ベクトル2D: b){
		b.x = x - a.x;
		b.y = y - a.y;
	}
	関数: 演算子 * (実数: k) => (ベクトル2D: b){
		b.x = x * k;
		b.y = y * k;
	}
	関数: 演算子 / (実数: k) => (ベクトル2D: b){
		b.x = x / k;
		b.y = y / k;
	}
	関数: 演算子 == (ベクトル2D:a) => (真偽: b){
		b = ((a.x == x) && (a.y == y));
	}
	関数: 演算子 != (ベクトル2D:a) => (真偽:b){
		b = ((a.x != x) || (a.y != y));
	}
}
関数: ${"ja":"ベクトル2Dの和", "natja":"ベクトル2Dの和", "en":"addVector2D", "naten":"addVector2D"}$(ベクトル2D: a, ベクトル2D: b) => (ベクトル2D: result){
	result.x = a.x + b.x;
	result.y = a.y + b.y;
}
関数: ${"ja":"ベクトル2Dの差", "natja":"ベクトル2Dの差", "en":"subVector2D", "naten":"subVector2D"}$(ベクトル2D: a, ベクトル2D: b) => (ベクトル2D: result){
	result.x = a.x - b.x;
	result.y = a.y - b.y;
}
関数: ${"ja":"ベクトル2Dの内積", "natja":"ベクトル2Dの内積", "en":"dotVector2D", "naten":"dotVector2D"}$(ベクトル2D: a, ベクトル2D: b) => (実数: x){
	x = a.x * b.x + a.y * b.y;
}
関数: ${"ja":"ベクトル2D拡大", "natja":"ベクトル2D拡大", "en":"extendVector2D", "naten":"extendVector2D"}$(ベクトル2D: a, 実数: x) => (ベクトル2D: result){
	result.x = a.x * x;
	result.y = a.y * x;
}
関数: ${"ja":"ベクトル2D縮小", "natja":"ベクトル2D縮小", "en":"divVector2D", "naten":"divVector2D"}$(ベクトル2D: a, 実数: x) => (ベクトル2D: result){
	もし(x == 0.0)ならば{
		表示(10000000);
	}
	result.x = a.x / x;
	result.y = a.y / x;
}
クラス: ${"ja":"アニメーション情報", "natja":"アニメーション情報", "en":"AnimationInfo", "naten":"AnimationInfo"}${
公開: 	整数: id;
	実数: startTime;
	実数: duration;
	ベクトル2D: info;
	関数: アニメーション情報(整数: a, 実数: start, 実数: d, 実数: x, 実数: y) => (){
		id = a;
		startTime = start;
		duration = d;
		info.x = x;
		info.y = y;
	}
	関数: アニメーション情報() => (){
		id = 0;
		startTime = 0;
		duration = 0;
		info.x = 0;
		info.y = 0;
	}
	関数: 演算子 == (アニメーション情報: a) => (真偽:b){
		b = ((a.id == id) && (a.startTime == startTime) && (a.duration == duration) && (a.info == info) && (a.info == info));
	}
	関数: 演算子 != (アニメーション情報: a) => (真偽:b){
		b = ((a.id != id) || (a.startTime != startTime) || (a.duration != duration) || (a.info != info) || (a.info != info));
	}
}
クラス: ${"ja":"スプライト", "natja":"スプライト", "en":"Sprite", "naten":"Sprite"}${
公開: 	ベクトル3D: 色;
	ベクトル2D: 座標;
	関数: スプライト(*実数: data, 整数: pnum, *整数32: indicesData, 整数: vnum, ベクトル3D: c, ベクトル2D: p, 整数: s, 整数: st, 実数: zI) => (){
		vertices = data;
		pointNum = pnum;
		indices = indicesData;
		vertexNum = vnum;
		zIndex = zI;
		透明度 = 1.0;
		spriteType = st;
		色 = c;
		座標 = p;
		scaleX = 1.0;
		scaleY = 1.0;
		theta = 0.0;
		shaderID = s;
		animations.配列();
		modelMat.単位化();
		transMat.単位化();
		scaleMat.単位化();
		rotateMat.単位化();
		projMatUniformLoc = glGetUniformLocation(shaderID, "projection");
		modelMatUniformLoc = glGetUniformLocation(shaderID, "model");
		もし(shaderID == 4)ならば{
			transparencyUniLoc = glGetUniformLocation(shaderID, "transparency");
			objectColorUniLoc = glGetUniformLocation(shaderID, "objectColor");
		}
		もし(shaderID == 3)ならば{
			samplerUniformLoc = glGetUniformLocation(shaderID, "uSampler");
		}
		buffer = glCreateBuffer();
		glBindBuffer(34962, buffer);
		glBufferData(34962, vertices, pnum * 3, 35044);
		もし(vnum > 0)ならば{
			elementBuffer = glCreateBuffer();
			glBindBuffer(34963, elementBuffer);
			glElementBufferData(34963, indices, vnum, 35044);
		}
	}
	関数: ${"ja":"テクスチャ設定", "natja":"テクスチャ設定", "en":"setTexture", "naten":"setTexture"}$(*実数: tex, 文字列: url) => (){
		shaderID = 0;
		texCoords = tex;
		texture = テクスチャロード(url.content, url.長さ);
		_文字列表示(url.content, url.長さ);
		texCoordBuffer = glCreateBuffer();
		glBindBuffer(34962, texCoordBuffer);
		glBufferData(34962, tex, vertexNum * 2, 35044);
	}
	関数: ${"ja":"リピートテクスチャ設定", "natja":"リピートテクスチャ設定", "en":"setRepeatTexture", "naten":"setRepeatTexture"}$(*実数: tex, 整数32: テクスチャ) => (){
		shaderID = 0;
		texCoords = tex;
		texture = テクスチャ;
		texCoordBuffer = glCreateBuffer();
		glBindBuffer(34962, texCoordBuffer);
		glBufferData(34962, tex, vertexNum * 2, 35044);
	}
	関数: ${"ja":"座標設定", "natja":"座標設定", "en":"setPos", "naten":"setPos"}$(ベクトル2D: coord) => (){
		座標 = coord;
	}
	関数: ${"ja":"移動", "natja":"移動", "en":"translate", "naten":"translate"}$(ベクトル2D: offset) => (){
		座標 = ベクトル2Dの和(座標, offset);
	}
	関数: ${"ja":"拡大縮小", "natja":"拡大縮小", "en":"scale", "naten":"scale"}$(実数: x, 実数: y) => (){
		scaleX = scaleX * x;
		scaleY = scaleY * y;
	}
	関数: ${"ja":"拡大縮小設定", "natja":"拡大縮小設定", "en":"setScale", "naten":"setScale"}$(実数: x, 実数: y) => (){
		scaleX = x;
		scaleY = y;
	}
	関数: ${"ja":"回転", "natja":"回転", "en":"rotate", "naten":"rotate"}$(実数: t) => (){
		theta = theta + t;
	}
	関数: ${"ja":"角度設定", "natja":"角度設定", "en":"setRotation", "naten":"setRotation"}$(実数: t) => (){
		theta = t;
	}
	関数: ${"ja":"重なり順設定", "natja":"重なり順設定", "en":"setZIndex", "naten":"setZIndex"}$(実数: x) => (){
		zIndex = x;
	}
	関数: ${"ja":"透明度設定", "natja":"透明度設定", "en":"setTransparency", "naten":"setTransparency"}$(実数: x) => (){
		透明度 = x;
	}
	関数: ${"ja":"色設定", "natja":"色設定", "en":"setColor", "naten":"setColor"}$(ベクトル3D: 色) => (){
		色 = 色;
	}
	関数: ${"ja":"描画", "natja":"描画", "en":"draw", "naten":"draw"}$(行列4x4: projMat) => (){
		実数: PI = 3.14159265358979312;
		(整数: カウンタ = 0;)から(カウンタ == animations.size)まで(カウンタ = カウンタ + 1;){
			アニメーション情報: info = animations.取得(カウンタ);
			もし((info.startTime <= 時間計測()) && ((info.startTime + info.duration) >= 時間計測()))ならば{
				もし(info.id == 0)ならば{
					実数: elapsedTime = 時間計測() - info.startTime;
					回転(info.info.x * elapsedTime);
				}
				もし(info.id == 1)ならば{
					拡大縮小(info.info.x, info.info.y);
				}
				もし(info.id == 2)ならば{
					実数: elapsedTime = 時間計測() - info.startTime;
					ベクトル2D: offset(info.info.x * elapsedTime, info.info.y * elapsedTime);
					移動(offset);
				}
			}
		}
		ベクトル3D: pos3d(座標.x, 座標.y, 0 - zIndex * 0.00100000000000000002);
		transMat.単位化();
		transMat.移動(pos3d);
		scaleMat.単位化();
		scaleMat.拡大縮小(scaleX, scaleY, 1.0);
		ベクトル3D: 回転軸(0.0, 0.0, 1.0);
		rotateMat.単位化();
		rotateMat.回転(回転軸, theta);
		modelMat.単位化();
		modelMat = 行列4x4の積(scaleMat, modelMat);
		modelMat = 行列4x4の積(rotateMat, modelMat);
		modelMat = 行列4x4の積(transMat, modelMat);
		glUseProgram(shaderID);
		glBindBuffer(34962, buffer);
		glEnableVertexAttribArray(0);
		glVertexAttribPointer(0, 3, 5126, 0, 0, 0);
		もし(shaderID == 4)ならば{
			glUniform1f(transparencyUniLoc, 透明度);
			glUniform3f(objectColorUniLoc, 色.x, 色.y, 色.z);
		}
		もし(shaderID == 3)ならば{
			glBindBuffer(34962, texCoordBuffer);
			glEnableVertexAttribArray(1);
			glVertexAttribPointer(1, 2, 5126, 0, 0, 0);
			glActiveTexture(texture + 33984);
			glBindTexture(3553, texture);
			glUniform1i(samplerUniformLoc, texture);
		}
		glUniformMatrix4fv(projMatUniformLoc, 0, projMat.matrix);
		glUniformMatrix4fv(modelMatUniformLoc, 0, modelMat.matrix);
		もし(spriteType == 1)ならば{
			glBindBuffer(34962, buffer);
			glDrawArrays(3, 0, pointNum);
		}
		でなければ{
			もし(vertexNum > 0)ならば{
				glBindBuffer(34963, elementBuffer);
				glDrawElements(4, vertexNum, 5123, 0);
			}
			もし((vertexNum == 0) && (shaderID == 4))ならば{
				glBindBuffer(34962, buffer);
				glDrawArrays(5, 0, pointNum);
			}
		}
		rotateMat.単位化();
		transMat.単位化();
		scaleMat.単位化();
	}
	関数: ${"ja":"回転アニメーション", "natja":"回転アニメーション", "en":"rotateAnimation", "naten":"rotateAnimation"}$(実数: theta, 実数: start, 実数: duration) => (){
		アニメーション情報: temp(0, start, duration, theta, 0.0);
		animations.追加(temp);
	}
	関数: ${"ja":"拡大縮小アニメーション", "natja":"拡大縮小アニメーション", "en":"scaleAnimation", "naten":"scaleAnimation"}$(実数: x, 実数: y, 実数: start, 実数: duration) => (){
		アニメーション情報: temp(1, start, duration, x, y);
		animations.追加(temp);
	}
	関数: ${"ja":"移動アニメーション", "natja":"移動アニメーション", "en":"translateAnimation", "naten":"translateAnimation"}$(ベクトル2D: offset, 実数: start, 実数: duration) => (){
		アニメーション情報: temp(0, start, duration, offset.x, offset.y);
		animations.追加(temp);
	}
非公開: 	*実数: vertices;
	*整数32: indices;
	*実数: texCoords;
	整数: vertexNum;
	整数: pointNum;
	整数32: buffer;
	整数32: texCoordBuffer;
	整数32: elementBuffer;
	整数32: texture;
	行列4x4: modelMat;
	行列4x4: transMat;
	行列4x4: scaleMat;
	行列4x4: rotateMat;
	実数: zIndex;
	整数: shaderID;
	整数32: objectColorUniLoc;
	整数32: transparencyUniLoc;
	整数32: projMatUniformLoc;
	整数32: modelMatUniformLoc;
	整数32: samplerUniformLoc;
	配列<アニメーション情報>: animations;
	実数: 透明度;
	実数: scaleX;
	実数: scaleY;
	実数: theta;
	整数: spriteType;
}
クラス: ${"ja":"シーン2D", "natja":"シーン2D", "en":"Scene2D", "naten":"Scene2D"}${
公開:
    配列<*スプライト>: ${"ja":"スプライト配列", "natja":"スプライト配列", "en":"sprites", "naten":"sprites"}$;
	ベクトル3D: ${"ja":"背景色", "natja":"背景色", "en":"backgroundColor", "naten":"backgroundColor"}$;
	実数: ${"ja":"背景透明度", "natja":"背景透明度", "en":"backgroundTransparency", "naten":"backgroundTransparency"}$;
	実数:zoom;
    関数: シーン2D(実数: 高さ, ベクトル3D: 色) => (){
		zoom = 100.0;
		last = 時間計測() / 1000.0;
		now = 0.0;
		elapsedTime = 0.0;
		projMat.単位化();
		projMat = 視点行列2D(projMat, (-高さ) * (16.0 / 9.0), (高さ) * (16.0 / 9.0), -高さ, 高さ, 0.0 - 5.0, 5.0);
		スプライト配列.配列();
		背景色 = 色;
		背景透明度 = 1.0;
	}
	関数: ${"ja":"背景透明度設定", "natja":"背景透明度設定", "en":"setBackgroundTransparency", "naten":"setBackgroundTransparency"}$(実数: a) => (){
		背景透明度 = a;
	}
	関数: ${"ja":"描画", "natja":"描画", "en":"draw", "naten":"draw"}$() => (){
		zoom += スクロール座標();
		もし(zoom > 400.0)ならば{
			zoom = 400.0;
		}
		もし(zoom < 8.0)ならば{
			zoom = 8.0;
		}
		// デバッグ表示(zoom);
		now = 時間計測() / 1000.0;
		elapsedTime = now - last;
		last = now;
		glClearColor(背景色.x, 背景色.y, 背景色.z, 背景透明度);
		glClearDepth(1.0);
		glEnable(2929);
		glDepthFunc(515);
		glEnable(3042);
		glBlendFunc(770, 771);
		glClear(16640);
		(整数: i = 0;)から(i == スプライト配列.size)まで(i = i + 1;){
			スプライト配列.取得(i) -> 拡大縮小設定(1.0/(zoom * 0.01), 1.0/(zoom * 0.01));
			スプライト配列.取得(i)->描画(projMat);
		}
	}
	関数: ${"ja":"正方形追加", "natja":"正方形追加", "en":"addSquare", "naten":"addSquare"}$(実数: size, ベクトル2D: 座標, ベクトル3D: 色, 実数: zIndex) => (整数: id){
		実数: vertices[4][3] = [[size / 2, size / 2, 0 - zIndex * 0.00100000000000000002], [size / 2, 0 - size / 2, 0 - zIndex * 0.00100000000000000002], [0 - size / 2, 0 - size / 2, 0 - zIndex * 0.00100000000000000002], [0 - size / 2, size / 2, 0 - zIndex * 0.00100000000000000002]];
		実数: texCoords[4][2] = [[1.0, 0.0], [1.0, 1.0], [0.0, 1.0], [0.0, 0.0]];
		整数32: indices[6] = [0, 1, 3, 1, 2, 3];
		*スプライト: sprite = メモリ確保(バイト数(*sprite));
		sprite->スプライト(&vertices, 4, &indices, 6, 色, 座標, 4, 0, zIndex);
		スプライト配列.追加(sprite);
		id = スプライト配列.長さ() - 1;
	}
	関数: ${"ja":"スプライト追加", "natja":"スプライト追加", "en":"addSprite", "naten":"addSprite"}$(実数: width, 実数: height, ベクトル2D: 座標, 文字列: url, 実数: zIndex) => (整数: id){
		実数: vertices[4][3] = [[width / 2, height / 2, 0 - zIndex * 0.00100000000000000002], [width / 2, 0 - height / 2, 0 - zIndex * 0.00100000000000000002], [0 - width / 2, 0 - height / 2, 0 - zIndex * 0.00100000000000000002], [0 - width / 2, height / 2, 0 - zIndex * 0.00100000000000000002]];
		実数: texCoords[4][2] = [[1.0, 0.0], [1.0, 1.0], [0.0, 1.0], [0.0, 0.0]];
		整数32: indices[6] = [0, 1, 3, 1, 2, 3];
		ベクトル3D: 色(0.0, 0.0, 0.0);
		*スプライト: sprite = メモリ確保(バイト数(*sprite));
		sprite->スプライト(&vertices, 4, &indices, 6, 色, 座標, 3, 0, zIndex);
		sprite->テクスチャ設定(&texCoords, url);
		スプライト配列.追加(sprite);
		id = スプライト配列.長さ() - 1;
	}
	関数: ${"ja":"リピートスプライト追加", "natja":"リピートスプライト追加", "en":"addRepeatSprite", "naten":"addRepeatSprite"}$(実数: width, 実数: height, ベクトル2D: 座標, 整数32: texture, 実数: zIndex) => (整数: id){
		実数: vertices[4][3] = [[width / 2, height / 2, 0 - zIndex * 0.00100000000000000002], [width / 2, 0 - height / 2, 0 - zIndex * 0.00100000000000000002], [0 - width / 2, 0 - height / 2, 0 - zIndex * 0.00100000000000000002], [0 - width / 2, height / 2, 0 - zIndex * 0.00100000000000000002]];
		実数: texCoords[4][2] = [[1.0, 0.0], [1.0, 1.0], [0.0, 1.0], [0.0, 0.0]];
		整数32: indices[6] = [0, 1, 3, 1, 2, 3];
		ベクトル3D: 色(0.0, 0.0, 0.0);
		*スプライト: sprite = メモリ確保(バイト数(*sprite));
		sprite->スプライト(&vertices, 4, &indices, 6, 色, 座標, 3, 0, zIndex);
		sprite->リピートテクスチャ設定(&texCoords, texture);
		スプライト配列.追加(sprite);
		id = スプライト配列.長さ() - 1;
	}
	関数: ${"ja":"四角形追加", "natja":"四角形追加", "en":"addRectangle", "naten":"addRectangle"}$(実数: width, 実数: height, ベクトル2D: 座標, ベクトル3D: 色, 実数: zIndex) => (整数: id){
		実数: vertices[4][3] = [[width / 2, height / 2, 0 - zIndex * 0.00100000000000000002], [0 - width / 2, height / 2, 0 - zIndex * 0.00100000000000000002], [width / 2, 0 - height / 2, 0 - zIndex * 0.00100000000000000002], [0 - width / 2, 0 - height / 2, 0 - zIndex * 0.00100000000000000002]];
		*スプライト: sprite = メモリ確保(バイト数(*sprite));
		sprite->スプライト(&vertices, 4, メモリ確保(0), 0, 色, 座標, 4, 0, zIndex);
		スプライト配列.追加(sprite);
		id = スプライト配列.長さ() - 1;
	}
	関数: ${"ja":"多角形追加", "natja":"多角形追加", "en":"addPolygon", "naten":"addPolygon"}$(配列<ベクトル2D>:points, ベクトル2D: 座標, ベクトル3D: 色, 実数: zIndex) => (整数: id){
		配列<実数>:temp();
		(points.長さ())回繰り返す{
			temp.追加(points.content[カウンタ].x);
			temp.追加(points.content[カウンタ].y);
			temp.追加( -zIndex * 0.001);
		}
		*スプライト: sprite = メモリ確保(バイト数(*sprite));
		sprite->スプライト(temp.content, temp.長さ()/3, メモリ確保(0), 0, 色, 座標, 4, 0, zIndex);
		スプライト配列.追加(sprite);
		id = スプライト配列.長さ() - 1;
	}
	関数: ${"ja":"円追加", "natja":"円追加", "en":"addCircle", "naten":"addCircle"}$(実数: r, ベクトル2D: 座標, ベクトル3D: 色, 実数: zIndex) => (整数: id){
		実数: PI = 3.14159265358979312;
		配列<ベクトル2D>: points();
		整数: 頂点数 = 60;
		(整数: i = 0;)から(i == 頂点数)まで(i = i + 1;){
			実数: theta = 0;
			もし((i % 2) == 0)ならば{
				theta = 0.5 * PI + ((PI * i) / 頂点数);
			}
			もし((i % 2) == 1)ならば{
				theta = 0.5 * PI - ((PI * (1.0 + i)) / 頂点数);
			}
			ベクトル2D: temp(r * cos(theta), r * sin(theta));
			points.追加(temp);
		}
		id = 多角形追加(points, 座標, 色, zIndex);
	}
	関数: ${"ja":"線追加", "natja":"線追加", "en":"addLine", "naten":"addLine"}$(ベクトル2D:start, ベクトル2D:end, ベクトル3D:色, 実数:zIndex) => (整数:id){
		配列<実数>: points();
		points.追加(start.x);
		points.追加(start.y);
		points.追加(-zIndex * 0.001);
		points.追加(end.x);
		points.追加(end.y);
		points.追加(-zIndex * 0.001);

		*スプライト: sprite = メモリ確保(バイト数(*sprite));
		sprite->スプライト(points.content, points.長さ()/3, メモリ確保(0), 0, 色, ベクトル2D(0.0, 0.0), 4, 1, zIndex);
		スプライト配列.追加(sprite);
		id = スプライト配列.長さ() - 1;
	}
	関数: ${"ja":"線追加", "natja":"線追加", "en":"addLine", "naten":"addLine"}$(関数:c(実数:a) => (実数:b), 実数: dx, 実数:start, 実数:end, ベクトル2D: 座標, ベクトル3D:色, 実数:zIndex) => (整数:id){
		配列<実数>: points();
		(実数:x = start;)から(x >= end)まで(x += dx;){
			points.追加(x);
			points.追加(c(x));
			points.追加(-zIndex * 0.001);
		}
		*スプライト: sprite = メモリ確保(バイト数(*sprite));
		sprite->スプライト(points.content, points.長さ()/3, メモリ確保(0), 0, 色, 座標, 4, 1, zIndex);
		スプライト配列.追加(sprite);
		id = スプライト配列.長さ() - 1;
	}
	関数: ${"ja":"媒介変数表示線追加", "natja":"媒介変数表示線追加", "en":"addLine", "naten":"addLine"}$(関数:c(実数:theta) => (ベクトル2D:pos), 実数: dx, 実数:start, 実数:end, ベクトル2D: 座標, ベクトル3D:色, 実数:zIndex) => (整数:id){
		配列<実数>: points();
		(実数:x = start;)から(x >= end)まで(x += dx;){
			ベクトル2D:temp = c(x);
			points.追加(temp.x);
			points.追加(temp.y);
			points.追加(-zIndex * 0.001);
		}
		*スプライト: sprite = メモリ確保(バイト数(*sprite));
		sprite->スプライト(points.content, points.長さ()/3, メモリ確保(0), 0, 色, 座標, 4, 1, zIndex);
		スプライト配列.追加(sprite);
		id = スプライト配列.長さ() - 1;
	}
非公開: 	行列4x4: projMat;
	実数: last;
	実数: now;
	実数: elapsedTime;
}
関数: 引数なしjsリスナー呼び出し(関数: () => (): callback) => (){
	callback();
}
js書き出し(引数なしjsリスナー呼び出し, "jsCallListenerNoParam");
関数:__setUpVariableNamesForSamples() => (){
	実数:${"ja":"前の数", "natja":"前の数", "en":"numberBefore", "naten":"numberBefore"}$;
	実数:${"ja":"数", "natja":"数", "en":"number", "naten":"number"}$;
	実数:${"ja":"入力", "natja":"入力", "en":"input", "naten":"input"}$;
	実数:${"ja":"出力", "natja":"出力", "en":"output", "naten":"output"}$;
	実数:${"ja":"返り値", "natja":"返り値", "en":"returnValue", "naten":"returnValue"}$;
	実数:${"ja":"初期数", "natja":"初期数", "en":"initialNumber", "naten":"initialNumber"}$;
	実数:${"ja":"コラッツ", "natja":"コラッツ", "en":"collatz", "naten":"collatz"}$;
	実数:${"ja":"結果", "natja":"結果", "en":"result", "naten":"result"}$;
	実数:${"ja":"かける数", "natja":"かける数", "en":"numberToMultiply", "naten":"numberToMultiply"}$;
	実数:${"ja":"ワールド", "natja":"ワールド", "en":"world", "naten":"world"}$;
	実数:${"ja":"光源座標", "natja":"光源座標", "en":"lightPosition", "naten":"lightPosition"}$;
	実数:${"ja":"回転軸", "natja":"回転軸", "en":"axis", "naten":"axis"}$;
	実数:${"ja":"位置", "natja":"位置", "en":"position", "naten":"position"}$;
	実数:${"ja":"キューブID", "natja":"キューブID", "en":"cubeID", "naten":"cubeID"}$;
	実数:${"ja":"光源ID", "natja":"光源ID", "en":"lightID", "naten":"lightID"}$;
	実数:${"ja":"キューブIDリスト", "natja":"キューブIDリスト", "en":"cubeIDlist", "naten":"cubeIDlist"}$;
	実数:${"ja":"回数", "natja":"回数", "en":"numberOfTimes", "naten":"numberOfTimes"}$;
	実数:${"ja":"初期位置", "natja":"初期位置", "en":"initialPosition", "naten":"initialPosition"}$;
	実数:${"ja":"幅", "natja":"幅", "en":"width", "naten":"width"}$;
	実数:${"ja":"高さ", "natja":"高さ", "en":"height", "naten":"height"}$;
	実数:${"ja":"質量", "natja":"質量", "en":"mass", "naten":"mass"}$;
	実数:${"ja":"慣性モーメント", "natja":"慣性モーメント", "en":"momentOfInertia", "naten":"momentOfInertia"}$;
	実数:${"ja":"速度", "natja":"速度", "en":"velocity", "naten":"velocity"}$;
	実数:${"ja":"角度", "natja":"角度", "en":"angle", "naten":"angle"}$;
	実数:${"ja":"角速度", "natja":"角速度", "en":"angularVelocity", "naten":"angularVelocity"}$;
	実数:${"ja":"力", "natja":"力", "en":"force", "naten":"force"}$;
	実数:${"ja":"トルク", "natja":"トルク", "en":"torque", "naten":"torque"}$;
	実数:${"ja":"形", "natja":"形", "en":"shape", "naten":"shape"}$;
	実数:${"ja":"物理ワールド2D", "natja":"物理ワールド2D", "en":"physicsWorld2D", "naten":"physicsWorld2D"}$;
	実数:${"ja":"物体配列", "natja":"物体配列", "en":"bodyArray", "naten":"bodyArray"}$;
	実数:${"ja":"重力加速度", "natja":"重力加速度", "en":"gravitationalAccelaration", "naten":"gravitationalAccelaration"}$;
	実数:${"ja":"前回の時間", "natja":"前回の時間", "en":"timeBefore", "naten":"timeBefore"}$;
	実数:${"ja":"物体追加", "natja":"物体追加", "en":"addBody", "naten":"addBody"}$;
	実数:${"ja":"重力", "natja":"重力", "en":"gravity", "naten":"gravity"}$;
	実数:${"ja":"アップデート", "natja":"アップデート", "en":"update", "naten":"update"}$;
	実数:${"ja":"経過時間", "natja":"経過時間", "en":"timePassed", "naten":"timePassed"}$;
	実数:${"ja":"角加速度", "natja":"角加速度", "en":"angularAccelaration", "naten":"angularAccelaration"}$;
	実数:${"ja":"物理ワールド", "natja":"物理ワールド", "en":"physicsWorld", "naten":"physicsWorld"}$;
	実数:${"ja":"初速度", "natja":"初速度", "en":"initialVelocity", "naten":"initialVelocity"}$;
	実数:${"ja":"初速度", "natja":"初速度", "en":"initialVelocity", "naten":"initialVelocity"}$;
	実数:${"ja":"素数", "natja":"素数", "en":"primeNumbers", "naten":"primeNumbers"}$;
	実数:${"ja":"フラグ", "natja":"フラグ", "en":"flag", "naten":"flag"}$;
	実数:${"ja":"漸化式", "natja":"漸化式", "en":"recursion", "naten":"recursion"}$;
	実数:${"ja":"変数1", "natja":"変数1", "en":"variable1", "naten":"variable1"}$;
	実数:${"ja":"変数2", "natja":"変数2", "en":"variable2", "naten":"variable2"}$;
	実数:${"ja":"変数3", "natja":"変数3", "en":"variable3", "naten":"variable3"}$;
	実数:${"ja":"変数4", "natja":"変数4", "en":"variable4", "naten":"variable4"}$;
	実数:${"ja":"変数5", "natja":"変数5", "en":"variable5", "naten":"variable5"}$;
	実数:${"ja":"変数6", "natja":"変数6", "en":"variable6", "naten":"variable6"}$;
	実数:${"ja":"変数7", "natja":"変数7", "en":"variable7", "naten":"variable7"}$;
	実数:${"ja":"変数8", "natja":"変数8", "en":"variable8", "naten":"variable8"}$;
	実数:${"ja":"変数9", "natja":"変数9", "en":"variable9", "naten":"variable9"}$;
	実数: ${"ja":"ロボット", "natja":"ロボット", "en":"robot", "naten":"robot"}$;
	実数: ${"ja":"コース", "natja":"コース", "en":"course", "naten":"course"}$;
}
クラス:ArduinoClass{
	文字:${"ja":"出力ピン", "natja":"出力ピン", "en":"OUTPUT", "naten":"OUTPUT"}$;
	文字:${"ja":"入力ピン", "natja":"入力ピン", "en":"INPUT", "naten":"INPUT"}$;
	関数:ArduinoClass()=>(){
		出力ピン = '出';
		入力ピン = '入';
	}
}
関数:${"ja":"Arduino5V送る", "natja":"Arduino5V送る", "en":"ArduinoOutput5V", "naten":"ArduinoOutput5V"}$(整数:ピン番号) => (){
	Arduinoコマンド送信('H', ピン番号);
}
関数:${"ja":"Arduino0V送る", "natja":"Arduino0V送る", "en":"ArduinoOutput0V", "naten":"ArduinoOutput0V"}$(整数:ピン番号) => (){
	Arduinoコマンド送信('L', ピン番号);
}
関数:${"ja":"Arduinoピン入出力設定", "natja":"Arduinoピン入出力設定", "en":"ArduinoSetPinmode", "naten":"ArduinoSetPinmode"}$(整数:ピン番号, 文字:入出力) => (){
	// Arduinoコマンド送信(入出力, ピン番号);
	もし(入出力 == '入')ならば{
		Arduinoコマンド送信('I', ピン番号);
	}
	もし(入出力 == '出')ならば{
		Arduinoコマンド送信('O', ピン番号);
	}
}
関数:${"ja":"Arduinoアナログ入力ピン設定", "natja":"Arduinoアナログ入力ピン設定", "en":"ArduinoSetAnalogInputPin", "naten":"ArduinoSetAnalogInputPin"}$(整数:ピン番号) => (){
    Arduinoコマンド送信('A', ピン番号);
}
関数:${"ja":"ArduinoHCSR04設定", "natja":"ArduinoHCSR04設定", "en":"ArduinoHCSR04Trigger", "naten":"ArduinoHCSR04Trigger"}$(整数:ピン番号) => (){
    Arduinoコマンド送信('T', ピン番号);
}
クラス:${"ja":"ベクトル4D", "natja":"ベクトル4D", "en":"Vector4D", "naten":"Vector4D"}${
	公開:
		実数:データ[4];
		関数:ベクトル4D(実数:ax, 実数:ay, 実数:bx, 実数:by) => (){
			データ[0] = ax;
			データ[1] = ay;
			データ[2] = bx;
			データ[3] = by;
		}
		関数: 演算子 != (ベクトル4D: a) => (真偽:b){
			b = (データ[0] != a.データ[0] || データ[1] != a.データ[1] || データ[2] != a.データ[2] || データ[3] != a.データ[3]);
		}
		関数: 演算子 == (ベクトル4D: a) => (真偽:b){
			b = (データ[0] == a.データ[0] && データ[1] == a.データ[1] && データ[2] == a.データ[2] && データ[3] == a.データ[3]);
		}
		関数: 交わるか(ベクトル4D: a) => (真偽:b){
			b = 線分当たり判定(データ[0], データ[1], データ[2], データ[3], a.データ[0], a.データ[1], a.データ[2], a.データ[3]);
		}
}
クラス:${"ja":"ライントレースシミュレーション", "natja":"ライントレースシミュレーション", "en":"linetraceSimulation", "naten":"linetraceSimulation"}${
	公開:
	シーン:ワールド;
	配列<ベクトル2D>:直線データ;
	実数:${"ja":"センサー値", "natja":"センサー値", "en":"sensorValue", "naten":"sensorValue"}$[2];
	実数:${"ja":"左センサー値", "natja":"左センサー値", "en":"leftSensorValue", "naten":"leftSensorValue"}$;
	実数:${"ja":"右センサー値", "natja":"右センサー値", "en":"rightSensorValue", "naten":"rightSensorValue"}$;
	整数:${"ja":"左モーターON", "natja":"左モーターON", "en":"leftMotorON", "naten":"leftMotorON"}$;
	整数:${"ja":"右モーターON", "natja":"右モーターON", "en":"rightMotorON", "naten":"rightMotorON"}$;
	整数:${"ja":"左モーター向き", "natja":"左モーター向き", "en":"leftMotorSequence", "naten":"leftMotorSequence"}$;
	整数:${"ja":"右モーター向き", "natja":"右モーター向き", "en":"rightMotorSequence", "naten":"rightMotorSequence"}$;
	実数:${"ja":"左モーター速度", "natja":"左モーター速度", "en":"leftMotorSpeed", "naten":"leftMotorSpeed"}$;
	実数:${"ja":"右モーター速度", "natja":"右モーター速度", "en":"rightMotorSpeed", "naten":"rightMotorSpeed"}$;
	実数:スタートタイム;
	実数:エンドタイム;
	関数:ライントレースシミュレーション(配列<実数>:points, ベクトル2D:firstPos, 実数:ax, 実数:ay, 実数:bx, 実数:byp) => (){
		直線データ.配列();
		通過点.配列();
		通過点ID.配列();
		ワールド.シーン();
		ロボット移動方向.ベクトル2D(0.0, 1.0);
		スタートマーク[0] = ax;
		スタートマーク[1] = ay;
		スタートマーク[2] = bx;
		スタートマーク[3] = byp;
		左モーター速度 = 3;
		右モーター速度 = 3;
		左モーター向き = 1;
		右モーター向き = 1;
		左モーターON = 0;
		右モーターON = 0;
		通過済み = -1;
		スタートタイム = 時間計測();
		ロボット速度 = 1.0;
		ロボット座標 = firstPos;
		ベクトル3D:灰色(0.8, 0.8, 0.8);
		ベクトル3D:白(1.0, 1.0, 1.0);
		ベクトル3D:黒(0.0, 0.0, 0.0);
		ベクトル3D:初期位置1(firstPos.x, 0.0, firstPos.y);
		ベクトル3D:初期位置2(5.0, 5.0, 5.0);
		ベクトル3D:初期位置3(0.0, -0.5, 0.0);
		ベクトル3D:初期位置4(firstPos.x, 10.0, firstPos.y);
		ベクトル3D:回転軸(0.0, 1.0, 0.0);
		points.追加(points.取得(0));
		points.追加(points.取得(1));
    ワールド.平行光源設定(初期位置3, 白, 0.05, 0.05, 0.0);
		ワールド.目.感度設定(5.0);
		ワールド.目.座標設定(初期位置4);
		ワールド.目.視点角度設定(90.0, -90.0);
    	ロボットID = ワールド.モデル追加(サンプルモデルロード("robot"), 灰色, 初期位置1);
		ワールド.スプライト配列.取得(ロボットID) -> 回転設定(ベクトル3D(0.0, 1.0, 0.0), ラジアンへ(180));
    	ライトID = ワールド.ライト追加(1.0, 白, 初期位置2, 1000.0);
		センサー1ID = ワールド.キューブ追加(0.2, ベクトル3D(0.0, 0.0, 0.0), ベクトル3D(0.0, 0.0, 0.0));
		センサー2ID = ワールド.キューブ追加(0.2, ベクトル3D(0.0, 0.0, 0.0), ベクトル3D(0.0, 0.0, 0.0));
    	ワールド.直方体追加(100.0, 1.0, 100.0, 白, 初期位置3);
		(整数:カウンタ = 0;)から(カウンタ == (points.長さ() - 2))まで(カウンタ += 2;){
			ベクトル2D:A(points.取得(カウンタ), points.取得(カウンタ + 1));
			ベクトル2D:B(points.取得(カウンタ + 2), points.取得(カウンタ + 3));
			もし(A != B)ならば{
				ベクトル2D:差 = B - A;
				ベクトル2D:和 = A + B;
				実数:傾き = (A.y - B.y)/(A.x - B.x);
				直線データ.追加(A);
				実数:長さ = 差.長さ();
				ベクトル2D:temp座標 = 和 * 0.5;
				ベクトル3D:temp3D座標(temp座標.x, 0.0, temp座標.y);
				整数:tempID = ワールド.直方体追加(長さ, 0.25, 0.25, 黒, temp3D座標);
				ワールド.スプライト配列.取得(tempID) -> 回転設定(回転軸, -jsArcTan(傾き));
			}
		}
		直線データ.追加(ベクトル2D(points.取得(0), points.取得(1)));
	}
	関数:ライントレースシミュレーション(整数: level) => (){
		通過点.配列();
		通過点ID.配列();
		配列<実数>: points();
		ワールド.シーン();
		ベクトル2D:firstPos(0.0, 0.0);
		もし(level == 0)ならば{
			ワールド.目.座標設定(ベクトル3D(2.0, 10.0, 3.0));
			ワールド.目.視点角度設定(45.0, -45.0);
			整数: 数 = 12;
			(12)回繰り返す{
				points.追加(10.0 * cos(ラジアンへ((360.0 / 数) * カウンタ)) + 10.0);
				points.追加(10.0 * sin(ラジアンへ((360.0 / 数) * カウンタ)) + 10.0);
			}
			firstPos.x = 0.0;
			firstPos.y = 10.0;
			ベクトル4D: チェックポイント(19.0, 10.5, 21.0, 9.5);
			通過点.追加(チェックポイント);
			ベクトル4D: ゴール(-1.0, 9.5, 1.0, 8.5);
			通過点.追加(ゴール);
		}
		もし(level == 1)ならば{
			ワールド.目.座標設定(ベクトル3D(-10.0, 10.0, -15.0));
			ワールド.目.視点角度設定(45.0, -45.0);
			整数: 数 = 12;
			(6)回繰り返す{
					points.追加(10.0 * cos(ラジアンへ((360.0 / 数) * (カウンタ + 1))));
					points.追加(10.0 * sin(ラジアンへ((360.0 / 数) * (カウンタ + 1))) + 10.0);
			}
			(6)回繰り返す{
					points.追加(10.0 * cos(ラジアンへ((360.0 / 数) * (カウンタ + 7))));
					points.追加(10.0 * sin(ラジアンへ((360.0 / 数) * (カウンタ + 7))) - 10.0);
			}
			firstPos.x = 9.0;
			firstPos.y = 1.0;
			ベクトル4D: チェックポイント(-8.0, -1.0, -10.0, 0.0);
			通過点.追加(チェックポイント);
			ベクトル4D: ゴール(8.0, 0.0, 10.0, -1.0);
			通過点.追加(ゴール);
		}
		もし(level == 2)ならば{
			ワールド.目.座標設定(ベクトル3D(-10.0, 10.0, -15.0));
			ワールド.目.視点角度設定(45.0, -45.0);
			ロボット角度 = 45.0;
			整数: 数 = 12;
			points.追加(10.0);
			points.追加(10.0);
			points.追加(10.0);
			points.追加(16.0);
			(6)回繰り返す{
					points.追加(10.0 * cos(ラジアンへ((360.0 / 数) * (カウンタ + 1))));
					points.追加(10.0 * sin(ラジアンへ((360.0 / 数) * (カウンタ + 1))) + 16.0);
			}
			points.追加(10.0 * cos(ラジアンへ((360.0 / 数) * 6)));
			points.追加(10.0 * sin(ラジアンへ((360.0 / 数) * 6)) + 10.0);
			points.追加(10.0);
			points.追加(-8.0);
			(7)回繰り返す{
					points.追加(10.0 * cos(ラジアンへ((360.0 / 数) * (-カウンタ))));
					points.追加(10.0 * sin(ラジアンへ((360.0 / 数) * (-カウンタ))) - 10.0);
			}
			points.追加(-10.0);
			points.追加(-8.0);
			firstPos.x = 3.0;
			firstPos.y = -2.0;
			ベクトル4D: チェックポイント1(-1.0, 24.0, 1.0, 28.0);
			通過点.追加(チェックポイント1);
			ベクトル4D: チェックポイント2(2.0, -16.0, -2.0, -24.0);
			通過点.追加(チェックポイント2);
			ベクトル4D: ゴール(4.0, 0.0, 4.0, -4.0);
			通過点.追加(ゴール);
		}
		直線データ.配列();
		ロボット移動方向.ベクトル2D(0.0, 1.0);
		左モーター速度 = 3;
		右モーター速度 = 3;
		左モーター向き = 1;
		右モーター向き = 1;
		左モーターON = 0;
		右モーターON = 0;
		通過済み = -1;
		スタートタイム = 時間計測();
		ロボット速度 = 1.0;
		ロボット座標 = firstPos;
		ベクトル3D:灰色(0.8, 0.8, 0.8);
		ベクトル3D:白(1.0, 1.0, 1.0);
		ベクトル3D:黒(0.0, 0.0, 0.0);
		ベクトル3D:初期位置1(firstPos.x, 0.0, firstPos.y);
		ベクトル3D:初期位置2(5.0, 5.0, 5.0);
		ベクトル3D:初期位置3(0.0, -0.5, 0.0);
		ベクトル3D:初期位置4(firstPos.x, 10.0, firstPos.y);
		ベクトル3D:回転軸(0.0, 1.0, 0.0);
		points.追加(points.取得(0));
		points.追加(points.取得(1));
    ワールド.平行光源設定(初期位置3, 白, 0.05, 0.05, 0.0);
		ワールド.目.感度設定(5.0);
		(通過点.長さ())回繰り返す{
			ベクトル3D:色 = 灰色;
			ベクトル4D: チェックポイント = 通過点.取得(カウンタ);
			ベクトル3D:位置((チェックポイント.データ[0] + チェックポイント.データ[2])/2.0, 0.0, (チェックポイント.データ[1] + チェックポイント.データ[3])/2.0);
			もし(カウンタ == (通過済み + 1))ならば{
				色 = ベクトル3D(0.7, 0.3, 0.0);
			}
    	整数: id = ワールド.モデル追加(サンプルモデルロード("checkpoint"), 色, 位置);
			通過点ID.追加(id);
			実数: PI = 3.141592653589793;
			実数: 角度 = jsArcTan((チェックポイント.データ[3] - チェックポイント.データ[1])/(チェックポイント.データ[2] - チェックポイント.データ[0])) + PI/6.0;
			ワールド.スプライト配列.取得(id) -> 回転設定(ベクトル3D(0.0, 1.0, 0.0), 角度);
		}
    	ロボットID = ワールド.モデル追加(サンプルモデルロード("robot"), 灰色, 初期位置1);
		ワールド.スプライト配列.取得(ロボットID) -> 回転設定(ベクトル3D(0.0, 1.0, 0.0), ラジアンへ(180));
    	ライトID = ワールド.ライト追加(1.0, 白, 初期位置2, 1000.0);
		センサー1ID = ワールド.キューブ追加(0.2, ベクトル3D(0.0, 0.0, 0.0), ベクトル3D(0.0, 0.0, 0.0));
		センサー2ID = ワールド.キューブ追加(0.2, ベクトル3D(0.0, 0.0, 0.0), ベクトル3D(0.0, 0.0, 0.0));
    	ワールド.直方体追加(100.0, 1.0, 100.0, 白, 初期位置3);
		(整数:カウンタ = 0;)から(カウンタ == (points.長さ() - 2))まで(カウンタ += 2;){
			ベクトル2D:A(points.取得(カウンタ), points.取得(カウンタ + 1));
			ベクトル2D:B(points.取得(カウンタ + 2), points.取得(カウンタ + 3));
			もし(A != B)ならば{
				ベクトル2D:差 = B - A;
				ベクトル2D:和 = A + B;
				実数:傾き = (A.y - B.y)/(A.x - B.x);
				直線データ.追加(A);
				実数:長さ = 差.長さ();
				ベクトル2D:temp座標 = 和 * 0.5;
				ベクトル3D:temp3D座標(temp座標.x, 0.0, temp座標.y);
				整数:tempID = ワールド.直方体追加(長さ, 0.25, 0.25, 黒, temp3D座標);
				ワールド.スプライト配列.取得(tempID) -> 回転設定(回転軸, -jsArcTan(傾き));
			}
		}
		直線データ.追加(ベクトル2D(points.取得(0), points.取得(1)));
	}
	関数:移動() => (){
		実数: PI = 3.14159265358979312;
		実数:左モーター距離 = 左モーター速度 * 左モーターON * 左モーター向き * 0.016;
		実数:右モーター距離 = 右モーター速度 * 右モーターON * 右モーター向き * 0.016;
		実数:基本距離 = 右モーター距離;
		実数:a = 1.0;
		もし(右モーター距離 >= 左モーター距離)ならば{
			基本距離 = 左モーター距離;
			a = -1.0;
		}
		実数:b = -1.0;
		実数:theta = 180.0 * jsArcTan(右モーター距離 - 左モーター距離)/PI;
		もし(右モーター距離 == 左モーター距離)ならば{
			theta = 0;
			a = 0.0;
			b = 0.0;
		}
		a *= -1.0;
		b *= -1.0;
		ロボット角度 += theta;
    ロボット移動方向.x = cos(ラジアンへ(ロボット角度 + 90.0));
    ロボット移動方向.y = sin(ラジアンへ(ロボット角度 + 90.0));
		// ロボットoffset.x = (cos(ラジアンへ(45.0 + ロボット角度)) - cos(ラジアンへ(45.0))) * (平方根(2));
		ロボット座標.x += a * cos(ラジアンへ(ロボット角度)) - b * sin(ラジアンへ(ロボット角度)) - a;
		ロボット座標.x -= a * cos(ラジアンへ(ロボット角度 - theta)) - b * sin(ラジアンへ(ロボット角度 - theta)) - a;
		// ロボットoffset.y = (sin(ラジアンへ(45.0 + ロボット角度)) - sin(ラジアンへ(45.0))) * (平方根(2));
		ロボット座標.y += a * sin(ラジアンへ(ロボット角度)) + b * cos(ラジアンへ(ロボット角度)) - b;
		ロボット座標.y -= a * sin(ラジアンへ(ロボット角度 - theta)) + b * cos(ラジアンへ(ロボット角度 - theta)) - b;
		// デバッグ表示(ロボットoffset.x);
		ワールド.スプライト配列.取得(ロボットID) -> 回転設定(ベクトル3D(0.0, 1.0, 0.0), ラジアンへ(-ロボット角度 + 180));
        ロボット座標 += (ロボット移動方向 * 基本距離);
	}
	関数:アップデート() => (){
		ベクトル2D:センサー座標[2] = ロボット座標;
		もし(!おわり)ならば{
			移動();
			センサー座標[0].x = 1.75 * cos(ラジアンへ(ロボット角度 + 79.0)) + ロボット座標.x;
			センサー座標[0].y = 1.75 * sin(ラジアンへ(ロボット角度 + 79.0)) + ロボット座標.y;
			センサー座標[1].x = 1.75 * cos(ラジアンへ(ロボット角度 + 101.0)) + ロボット座標.x;
			センサー座標[1].y = 1.75 * sin(ラジアンへ(ロボット角度 + 101.0)) + ロボット座標.y;
			ワールド.スプライト配列.取得(センサー1ID) -> 座標設定(ベクトル3D(センサー座標[0].x, 0.4, センサー座標[0].y));
			ワールド.スプライト配列.取得(センサー2ID) -> 座標設定(ベクトル3D(センサー座標[1].x, 0.4, センサー座標[1].y));
			ワールド.スプライト配列.取得(センサー1ID) -> 回転設定(ベクトル3D(0.0, 1.0, 0.0), ラジアンへ(-ロボット角度 + 180));
			ワールド.スプライト配列.取得(センサー2ID) -> 回転設定(ベクトル3D(0.0, 1.0, 0.0), ラジアンへ(-ロボット角度 + 180));

			ベクトル3D:緑(0.0, 1.0, 0.0);

			もし(通過点.長さ() >= 1 && 通過点ID.長さ() >= 1)ならば{
				ベクトル4D: チェックポイント = 通過点.取得(通過済み + 1);
				ベクトル4D: ロボット線分(2.0 * cos(ラジアンへ(ロボット角度)) + ロボット座標.x, 2.0 * sin(ラジアンへ(ロボット角度)) + ロボット座標.y, 2.0 * cos(ラジアンへ(ロボット角度 + 180)) + ロボット座標.x, 2.0 * sin(ラジアンへ(ロボット角度 + 180)) + ロボット座標.y);

				もし(チェックポイント.交わるか(ロボット線分))ならば{
					もし((通過済み + 2) == 通過点.長さ())ならば{
						ワールド.スプライト配列.取得(通過点ID.取得(通過済み + 1)) -> 色設定(緑);
						おわり = 真;
						エンドタイム = 時間計測();
						updateLinetraceTime((エンドタイム - スタートタイム)/1000);
					}でなければ{
						通過済み += 1;
						ワールド.スプライト配列.取得(通過点ID.取得(通過済み)) -> 色設定(緑);
						ワールド.スプライト配列.取得(通過点ID.取得(通過済み + 1)) -> 色設定(ベクトル3D(0.7, 0.3, 0.0));
					}
				}
			}

			実数:センサー距離[2] = [10000.0, 10000.0];
			整数:センサー数 = 2;
			(センサー数)回繰り返す{
				(整数:i = 0;)から(i == (直線データ.長さ() - 1))まで(i += 1;){
					ベクトル2D:A = 直線データ.取得(i);
					ベクトル2D:B = 直線データ.取得(i + 1);
					ベクトル2D:AB = B - A;
					ベクトル2D:Aセンサー座標 = センサー座標[カウンタ] - A;
					ベクトル2D:Bセンサー座標 = センサー座標[カウンタ] - B;
					もし((ベクトル2Dの内積(AB, Aセンサー座標) >= 0) && (ベクトル2Dの内積(AB * -1.0, Bセンサー座標) >= 0))ならば{
						実数:傾き = (A.y - B.y)/(A.x - B.x);
						実数:y切片 = A.y - (傾き * A.x);
						実数:距離 = 絶対値(傾き * センサー座標[カウンタ].x - センサー座標[カウンタ].y + y切片) / 平方根(1.0 + 傾き * 傾き);
						もし(絶対値(傾き) > 10000.0)ならば{
							距離 = 絶対値(A.x - センサー座標[カウンタ].x);
						}
						もし(センサー距離[カウンタ] > 距離)ならば{
							センサー距離[カウンタ] = 距離;
						}
					}
					でなければ{
						もし(センサー距離[カウンタ] > Aセンサー座標.長さ())ならば{
							センサー距離[カウンタ] = Aセンサー座標.長さ();
						}
						もし(センサー距離[カウンタ] > Bセンサー座標.長さ())ならば{
							センサー距離[カウンタ] = Bセンサー座標.長さ();
						}
					}
				}
			}
			センサー値[0] = センサー距離[0] * 768.0;
			センサー値[1] = センサー距離[1] * 768.0;
			もし(センサー値[0] > 255)ならば{
				センサー値[0] = 255.0;
			}
			もし(センサー値[1] > 255)ならば{
				センサー値[1] = 255.0;
			}
			右センサー値 = センサー値[0];
			左センサー値 = センサー値[1];
			ベクトル3D:ロボット座標3D(ロボット座標.x, 0.0, ロボット座標.y);
			ベクトル3D:ライト座標3D(ロボット座標.x + 5.0, 5.0, ロボット座標.y + 5.0);
    	ワールド.スプライト配列.取得(ロボットID) -> 座標設定(ロボット座標3D);
    	ワールド.スプライト配列.取得(ライトID) -> 座標設定(ライト座標3D);
		}
    ワールド.描画();
	}
	非公開:
	整数:ロボットID;
	整数:ライトID;
	実数:ロボット角度;
	ベクトル2D:ロボット移動方向;
	実数:ロボット速度;
	ベクトル2D:ロボット座標;
	ベクトル2D:ロボット初期位置;
	整数:センサー1ID;
	整数:センサー2ID;
	ベクトル2D:ロボットoffset;
	真偽:おわり;
	実数:スタートマーク[4];
	配列<ベクトル4D>: 通過点;
	配列<整数>: 通過点ID;
	整数:通過済み;
}